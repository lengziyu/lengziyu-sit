{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-snippet/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/assets/highlight.pack.js","path":"assets/highlight.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/assets/tagcanvas.min.js","path":"assets/tagcanvas.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/branding.png","path":"img/branding.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/head-img.jpg","path":"img/head-img.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/reward-wepay.jpg","path":"img/reward-wepay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/timeline-clock.gif","path":"img/timeline-clock.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/timeline-dot.gif","path":"img/timeline-dot.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/timeline.gif","path":"img/timeline.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/assets/valine.min.js","path":"assets/valine.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-snippet/.travis.yml","hash":"4deaa0954aa7b0f62628557cc7ba4bc2f6be73ac","modified":1563333171121},{"_id":"themes/hexo-theme-snippet/.gitignore","hash":"5636464498c54867468ad1459c76b960af9c275c","modified":1563333171121},{"_id":"themes/hexo-theme-snippet/LICENSE","hash":"c976aafe3bc44246a978850b18102966afe3eeb5","modified":1563333171121},{"_id":"themes/hexo-theme-snippet/README.md","hash":"c6dd64e134d1bf4e65087995f57b58b6a7cdb2cd","modified":1563333171122},{"_id":"themes/hexo-theme-snippet/_config.yml","hash":"0742c12e2f375d5f91acd9fa2c362b0aca65f50f","modified":1566659311866},{"_id":"themes/hexo-theme-snippet/_travis.sh","hash":"030b5b59dc485b5fa7d155a1da30d9c5c4868f6b","modified":1563333171122},{"_id":"themes/hexo-theme-snippet/gulpfile.js","hash":"41ab8395f1aea0af1467c58ecda05ae04145dfd3","modified":1563333171122},{"_id":"themes/hexo-theme-snippet/package.json","hash":"455943ea7597169f21ef39ec0d1f491d3a9d3041","modified":1563333171134},{"_id":"source/about/index.md","hash":"25a1b900a1d5f290b081529790ee06885949eae2","modified":1563346489207},{"_id":"source/_posts/ES6-to-let-and-const.md","hash":"67e9ff95a95dc92ec59b5f53146573f02087f869","modified":1565881413955},{"_id":"source/_posts/MongoDB-learn-note.md","hash":"5b3b0455546a78e8e94eaf435a90d2d7d7816825","modified":1565881413958},{"_id":"source/_posts/MongoDB-install-for-windows.md","hash":"78eb3d68d8d67863978c52d8548097b90f664c68","modified":1565881413957},{"_id":"source/_posts/Redux-学习笔记.md","hash":"640d6a642418326ba859705ab315c51491f35dae","modified":1565881413980},{"_id":"source/_posts/ajax-to-fetch.md","hash":"153ed07b799ed9069bed2c5b4a0660c14b587634","modified":1565881413953},{"_id":"source/_posts/es6-new-grammar.md","hash":"122709a6cc00f7a77baf4a05f0d3ad76bffad15b","modified":1565881413954},{"_id":"source/_posts/hello-2017.md","hash":"579289c2a71e6e2c94d874f813cd360c7aa10d31","modified":1565881413955},{"_id":"source/_posts/linux-nodejs.md","hash":"2988791be0c76f98da940db389b8f1794fab2b77","modified":1565881413956},{"_id":"source/_posts/node-use-fs-modules.md","hash":"e7d315223f4215e6e1d9546c53a16e281ef794b8","modified":1565881413958},{"_id":"source/_posts/react-early-know.md","hash":"ebc0168d8d5abed1a6f7fe901c7b33e25dc6c034","modified":1565881413959},{"_id":"source/_posts/react-jsx-grammar.md","hash":"f3c0fcfbf56564f4bd648cab25574ed8aa9617af","modified":1565881413960},{"_id":"source/_posts/react-props-and-state-plus.md","hash":"e4d36f2f5111187fea53d83d0093485980c105da","modified":1565881413961},{"_id":"source/_posts/react-props-and-state.md","hash":"a8e607eb9e6cb77c4104aed86edf118403f24e33","modified":1565881413961},{"_id":"source/_posts/react-to-biaodan.md","hash":"2989302a61fb6bb784897b3aa2042e31a59a0d9e","modified":1565881413979},{"_id":"source/_posts/react-use-dmo-refs.md","hash":"6f64944d65a0dbb51387fdf2a6607a06c1e35f57","modified":1565881413962},{"_id":"source/_posts/redux-basics.md","hash":"34133d3fbcc6cef96b74a44ac726c275adf64c21","modified":1565881413979},{"_id":"source/_posts/vue-seo.md","hash":"9c5eb01b4625aec0e1903ccc0c7e067eb99cc1bd","modified":1565882288743},{"_id":"source/_posts/webpack-use-expo.md","hash":"75f56331f3ce71b241fca5d345b08308731b87eb","modified":1565881413981},{"_id":"source/_posts/windows-flutter-install.md","hash":"cb4d6a50e27c05c7582966a986aaa5aa09feec0b","modified":1565882309122},{"_id":"source/_posts/yarn-a-new-javascript-pkg.md","hash":"08c6044ae0c10a5420a8095263d70acbd7c0e041","modified":1565881413982},{"_id":"source/_posts/公众号用vue开发百度地图.md","hash":"1d0f58c195f0cf9c1c0e59b9ca7836dac680c028","modified":1568127678671},{"_id":"themes/hexo-theme-snippet/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1563333171113},{"_id":"themes/hexo-theme-snippet/.git/config","hash":"df40e1ae5b75cd04f7d476826e76ab7f30de669f","modified":1563333171117},{"_id":"themes/hexo-theme-snippet/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1563333164789},{"_id":"themes/hexo-theme-snippet/.git/index","hash":"3bdf309725270ca6204506a4b74ed9a5fe66eab4","modified":1565833149334},{"_id":"themes/hexo-theme-snippet/.git/packed-refs","hash":"451416a215c88a55001739230727890704a25dfb","modified":1563333171109},{"_id":"themes/hexo-theme-snippet/.github/ISSUE_TEMPLATE.md","hash":"c32422877f786b7a1a35aa59fd9bcbc9c869b583","modified":1563333171120},{"_id":"themes/hexo-theme-snippet/languages/default.yml","hash":"70f843ab2c39ded6c30bc6c31e85a3b82f2e3c93","modified":1565840795964},{"_id":"themes/hexo-theme-snippet/languages/ja.yml","hash":"c9deaf06b0edffdcc12c3e48fa649bac094e3f8c","modified":1563333171123},{"_id":"themes/hexo-theme-snippet/languages/zh-CN.yml","hash":"f64f65bb89dc7cc8e22a7323f5a36c2beb87a2d7","modified":1563333171123},{"_id":"themes/hexo-theme-snippet/languages/zh-TW.yml","hash":"e440a8a29dc4266d9ae06ed3601796f7ef3dddee","modified":1563333171123},{"_id":"themes/hexo-theme-snippet/layout/category.ejs","hash":"91d904f43ae2ad5ec2b05bf1e2473657a8315b5c","modified":1563333171133},{"_id":"themes/hexo-theme-snippet/layout/archive.ejs","hash":"71d95943fe978f6f85922800e801cfdd3d06b958","modified":1563333171133},{"_id":"themes/hexo-theme-snippet/layout/index.ejs","hash":"b0d49ace1c6333b352a37d54c1448b74c8a6c0b0","modified":1563333171133},{"_id":"themes/hexo-theme-snippet/layout/layout.ejs","hash":"46ffb9f6df8c318710b4cec321c59e89dcb16da5","modified":1563346290537},{"_id":"themes/hexo-theme-snippet/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1563333171134},{"_id":"themes/hexo-theme-snippet/layout/post.ejs","hash":"5e680b006ee207303443889f263b541150791f9b","modified":1563333171134},{"_id":"themes/hexo-theme-snippet/layout/tag.ejs","hash":"e7062d08cfff13dfe8b8c8915a2eb0fafb0ae567","modified":1563333171134},{"_id":"themes/hexo-theme-snippet/scripts/helper.js","hash":"5502d8b4937be2463cd76ca82dcb8bd23c0090f6","modified":1563333171135},{"_id":"themes/hexo-theme-snippet/scripts/process.js","hash":"3b3ca8da64cacd9070ea8d888872348f301be2ac","modified":1563333171135},{"_id":"themes/hexo-theme-snippet/source/favicon.ico","hash":"30c96826811ee529fb2d332101394c670dd1d4ad","modified":1565840197140},{"_id":"themes/hexo-theme-snippet/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1563333164789},{"_id":"themes/hexo-theme-snippet/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1563333164790},{"_id":"themes/hexo-theme-snippet/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1563333164790},{"_id":"themes/hexo-theme-snippet/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1563333164790},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1563333164791},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1563333164791},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1563333164792},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1563333164792},{"_id":"themes/hexo-theme-snippet/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1563333164793},{"_id":"themes/hexo-theme-snippet/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1563333164793},{"_id":"themes/hexo-theme-snippet/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1563333164794},{"_id":"themes/hexo-theme-snippet/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1563333164794},{"_id":"themes/hexo-theme-snippet/.git/logs/HEAD","hash":"2dcc75910b2a045bca157592d8ec33630d51a38a","modified":1563333171115},{"_id":"themes/hexo-theme-snippet/.github/ISSUE_TEMPLATE/bug_report.md","hash":"c30b145df577faed45a8b0f6da4aa8c3f06849dd","modified":1563333171120},{"_id":"themes/hexo-theme-snippet/.github/ISSUE_TEMPLATE/feature_request.md","hash":"73a98280892b1a46317dad9721b6de5244ded398","modified":1563333171120},{"_id":"themes/hexo-theme-snippet/layout/_partial/archive.ejs","hash":"9a1733694878bad23daca553cbdbcb28b1078afa","modified":1563333171125},{"_id":"themes/hexo-theme-snippet/layout/_partial/article-meta.ejs","hash":"66db0f8171cbdf4398e6b520d0f6c2499730a6ba","modified":1563333171125},{"_id":"themes/hexo-theme-snippet/layout/_partial/article.ejs","hash":"5f7c7bdfbc09acf5ae86293a9cf6018c812a3250","modified":1563333171125},{"_id":"themes/hexo-theme-snippet/layout/_partial/busuanzi.ejs","hash":"eaec9cbda41e085e5ea627083116b758ffb14c93","modified":1563333171125},{"_id":"themes/hexo-theme-snippet/layout/_partial/footer.ejs","hash":"4985f82693b922e03382af244f4699d5703242a6","modified":1563333171126},{"_id":"themes/hexo-theme-snippet/layout/_partial/copyright.ejs","hash":"cb08a0a281c0010411c16279782c523e5516cbed","modified":1565837439531},{"_id":"themes/hexo-theme-snippet/layout/_partial/gallery.ejs","hash":"aecfcee48528c5e8cbf7d23765e030a3fbdd1baf","modified":1563333171126},{"_id":"themes/hexo-theme-snippet/layout/_partial/head.ejs","hash":"ac1639c0b6dbbaeb3f6c4c9139ad389e80d24197","modified":1563333171126},{"_id":"themes/hexo-theme-snippet/layout/_partial/header.ejs","hash":"70e3a3b46b39f789c3a4605328bb999c82538e9d","modified":1563333171126},{"_id":"themes/hexo-theme-snippet/layout/_partial/nav.ejs","hash":"197741d4d213fa560e830da855efae286a9729ec","modified":1563333171127},{"_id":"themes/hexo-theme-snippet/layout/_partial/pagination.ejs","hash":"20eff43ad205febe8fc675d669b2be0b88c7158e","modified":1563333171127},{"_id":"themes/hexo-theme-snippet/layout/_partial/reward.ejs","hash":"b7b164419efa94e45345aef05d7a0ed95491b5e4","modified":1563333171127},{"_id":"themes/hexo-theme-snippet/layout/_partial/script.ejs","hash":"19b1a16e070deac7ff3cd21598692566ff8b078f","modified":1563333171127},{"_id":"themes/hexo-theme-snippet/layout/_partial/sidebar.ejs","hash":"7a4dd0aa5a5acf3a56734385152c28591c45602e","modified":1563333171127},{"_id":"themes/hexo-theme-snippet/layout/_partial/toc.ejs","hash":"57a144a4680936731c853a5d79c893584fc6a8f0","modified":1563333171128},{"_id":"themes/hexo-theme-snippet/layout/_vendor/baidu_sitemap.ejs","hash":"6ed45973126cd3fc75810d32216760f7be0ef60f","modified":1563333171129},{"_id":"themes/hexo-theme-snippet/layout/_widget/archive.ejs","hash":"5af5f3b56c90c7ebd015233bce1059754c31befb","modified":1563333171131},{"_id":"themes/hexo-theme-snippet/layout/_widget/category.ejs","hash":"dcdb7a08a2f17beaf610de4e937047c291f39a90","modified":1563333171131},{"_id":"themes/hexo-theme-snippet/layout/_widget/friends.ejs","hash":"26eb71dd79f1e7d222b210ecd3afd2e177e1250e","modified":1563333171132},{"_id":"themes/hexo-theme-snippet/layout/_widget/notification.ejs","hash":"bb64a2149ea88c75419b706877e1d1a94d7f3e01","modified":1563333171132},{"_id":"themes/hexo-theme-snippet/layout/_widget/search.ejs","hash":"f94a530179225d88fbc3a7b23ec63e06da30a972","modified":1563333171132},{"_id":"themes/hexo-theme-snippet/layout/_widget/social.ejs","hash":"83be8c71b5b40b79aed50263c28c99282559c23a","modified":1563333171132},{"_id":"themes/hexo-theme-snippet/layout/_widget/tagcloud.ejs","hash":"e5d4a31e96f91179a23c0487bb86e97e1970c9bb","modified":1563333171133},{"_id":"themes/hexo-theme-snippet/source/assets/highlight.pack.js","hash":"b93558f0b97e233132a8ccf7f0275053f2df4628","modified":1563333171136},{"_id":"themes/hexo-theme-snippet/source/assets/tagcanvas.min.js","hash":"8102d7651a1f65b1bd8f8dd62f2d68cdd6b746dd","modified":1563333171136},{"_id":"themes/hexo-theme-snippet/source/css/font-awesome.min.css","hash":"624e4a106f0cf385ff4bd6a65c52cecd84f42ef9","modified":1563333171138},{"_id":"themes/hexo-theme-snippet/source/css/style.css","hash":"1b506ab4985d9f0300184e32966e008e9abc56ca","modified":1565851445233},{"_id":"themes/hexo-theme-snippet/source/img/avatar.jpg","hash":"f308ab307cc5bf138f460ae98608fa58293eb171","modified":1565881185423},{"_id":"themes/hexo-theme-snippet/source/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1563333171150},{"_id":"themes/hexo-theme-snippet/source/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1563333171151},{"_id":"themes/hexo-theme-snippet/source/img/reward-wepay.jpg","hash":"2a56391f2b6282b49e724b72bf610b0dabf53742","modified":1563333171152},{"_id":"themes/hexo-theme-snippet/source/img/timeline-clock.gif","hash":"2bec1bf5efd948ab2e5942b6da8164faa41b62b2","modified":1563333171152},{"_id":"themes/hexo-theme-snippet/source/img/timeline-dot.gif","hash":"c85ef87be5b631c009e7c5737d33b61dfe580a4d","modified":1563333171152},{"_id":"themes/hexo-theme-snippet/source/img/timeline.gif","hash":"b7c7aac44e618df19626d882dc46db48a4aa3673","modified":1563333171153},{"_id":"themes/hexo-theme-snippet/source/js/app.js","hash":"ea09fee9577cda06f27a57a7a889e758545b05cb","modified":1563333171153},{"_id":"themes/hexo-theme-snippet/source/js/search.js","hash":"1d53b5efc08512b3b186c88eee7ddc37c77d2d1a","modified":1563333171153},{"_id":"themes/hexo-theme-snippet/source/assets/valine.min.js","hash":"61d8a2678c19153cda6bbd45746648816cc3400f","modified":1563333171137},{"_id":"themes/hexo-theme-snippet/source/css/bootstrap.min.css","hash":"224c9f9ad11b495358aa61dbd53e838e9b61015b","modified":1563333171138},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1563333171149},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1563333171150},{"_id":"themes/hexo-theme-snippet/source/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1563333171152},{"_id":"themes/hexo-theme-snippet/.git/objects/pack/pack-ab3e13c1c76e9fa9f82c1ebce933a83759685225.idx","hash":"8e584815ef4ecb40afb91dc6ce316eceef7f68a8","modified":1563333171065},{"_id":"themes/hexo-theme-snippet/.git/refs/heads/master","hash":"059b9d4f1b351859550b42dd219f0d16cad3b48d","modified":1563333171115},{"_id":"themes/hexo-theme-snippet/layout/_partial/_head-sections/IE.ejs","hash":"7cdbf6bc632c135925e00d5e27243d94a44c8031","modified":1563333171124},{"_id":"themes/hexo-theme-snippet/layout/_partial/_head-sections/seo.ejs","hash":"e06f9dac2fc3f22286c77941b8f0c3ebccc27b29","modified":1563333171124},{"_id":"themes/hexo-theme-snippet/layout/_partial/_head-sections/style.ejs","hash":"8ff2d85b26e0a5b844bfbfbdd55a7cf5628cfc03","modified":1563333171124},{"_id":"themes/hexo-theme-snippet/layout/_partial/_head-sections/title.ejs","hash":"0b55f4dcab22788bb5b9b4f0246264278145a424","modified":1563333171125},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/baidu.ejs","hash":"e616c6d618d2aa34baa0f244de770abcee8b56f4","modified":1563333171128},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/cnzz.ejs","hash":"e12c2cba1b0a9447e7a46b88a1c4d175e65bbf98","modified":1563333171128},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/google.ejs","hash":"1ee0f1fadedc00633b3ab30b93bdeffe22b18afe","modified":1563333171129},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/index.ejs","hash":"68b3680acd34f62b0b4e0017e3d8bab20d4e459f","modified":1563333171129},{"_id":"themes/hexo-theme-snippet/layout/_vendor/analytics/tencent.ejs","hash":"52e4f2541482ae473a750921dfc6bf088fd78b33","modified":1563333171129},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/disqus.ejs","hash":"0713d00c14a9b5f3b6814f5a9ea6cf21142a511c","modified":1563333171130},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/gitalk.ejs","hash":"a9352b4c28be7c48c188bbf583b5c967731cc66b","modified":1563333171130},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/changyan.ejs","hash":"c75ac620d6a336921fa61090d22e5cf0a09019a1","modified":1563333171129},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/gitment.ejs","hash":"61572c2616c319d798024597c2fb8ca470767ca5","modified":1563333171130},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/index.ejs","hash":"54e7ed2c9403a84b2911d595d9675709ce489497","modified":1563333171130},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/livere.ejs","hash":"084108977f3767b961361495216271972b1ada39","modified":1563333171130},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/uyan.ejs","hash":"4d5e43c69eb28d2f45bba3c1cee25d773b02f0d0","modified":1563333171131},{"_id":"themes/hexo-theme-snippet/layout/_vendor/comments/valine.ejs","hash":"ab1d025b2e3f236dd7cd0f6d366a251b8b5ef9bd","modified":1563333171131},{"_id":"themes/hexo-theme-snippet/source/css/less/_highlight.less","hash":"62e0505c4c1be54291964cfad26ac838cee04e0c","modified":1563333171138},{"_id":"themes/hexo-theme-snippet/source/css/less/_mixins.less","hash":"74f250b8c287ca5840f4d09a87eb23b69a722a8a","modified":1563333171139},{"_id":"themes/hexo-theme-snippet/source/css/less/_scrollbar.less","hash":"d6ef59cac4da4994e925786edff920628fa4fb14","modified":1563333171139},{"_id":"themes/hexo-theme-snippet/source/css/less/_reward.less","hash":"77c4b55040e6b8063db1404adf60b7492452be01","modified":1563333171139},{"_id":"themes/hexo-theme-snippet/source/css/less/_style.less","hash":"787e77ae9b1eda6f84f5e413f3ba3ef534d6b0bf","modified":1563333171140},{"_id":"themes/hexo-theme-snippet/source/css/less/_timeline.less","hash":"d5c375ecf21cd276725cb6f367c6230b3a2229d7","modified":1563333171140},{"_id":"themes/hexo-theme-snippet/source/css/less/_variable.less","hash":"6879b512c4777d0dbf9f84ed2f488f3ac79d0d73","modified":1563333171140},{"_id":"themes/hexo-theme-snippet/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1563333171142},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1563333171144},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1563333171148},{"_id":"themes/hexo-theme-snippet/source/img/bg.jpg","hash":"187a215aa1a33995d376307dd0348c4a1f3d3500","modified":1565850467010},{"_id":"themes/hexo-theme-snippet/.git/logs/refs/heads/master","hash":"2dcc75910b2a045bca157592d8ec33630d51a38a","modified":1563333171116},{"_id":"themes/hexo-theme-snippet/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1563333171112},{"_id":"themes/hexo-theme-snippet/.git/logs/refs/remotes/origin/HEAD","hash":"2dcc75910b2a045bca157592d8ec33630d51a38a","modified":1563333171112},{"_id":"themes/hexo-theme-snippet/source/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1563333171147},{"_id":"themes/hexo-theme-snippet/.git/objects/pack/pack-ab3e13c1c76e9fa9f82c1ebce933a83759685225.pack","hash":"d93ffd618306f16e1e1df9a87eeea5d829331da1","modified":1563333171068}],"Category":[{"name":"es6","_id":"ck0dyqhjb0003xknwjtvl7sax"},{"name":"redux","_id":"ck0dyqhji0008xknwb3gfxx5c"},{"name":"fetch","_id":"ck0dyqhjm000exknwb29zvuui"},{"name":"node","_id":"ck0dyqhjr000mxknw3akjvsfk"},{"name":"react","_id":"ck0dyqhjv000uxknw1oq25203"},{"name":"Vue","_id":"ck0dyqhks001txknwlj53dk2c"},{"name":"Flutter","_id":"ck0dyqhkv001zxknw72pnczdv"},{"name":"yarn","_id":"ck0dyqhkw0022xknw5gpzjtby"}],"Data":[],"Page":[{"title":"about","date":"2019-07-17T06:23:09.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-07-17 14:23:09\n---\n","updated":"2019-07-17T06:54:49.207Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck0dyqhj40000xknwavgn2b42","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES6笔记之 let 和 const","abbrlink":19172,"date":"2016-10-17T13:51:50.000Z","_content":"ES6新增了 let 和 const 命令，用来声明变量。它的用法类似于var，却有所区别。\n<!--more-->\n## let\nlet声明的变量只在其所在的代码块内有效。\n\n```\n{\n    let a = 1;\n}\nconsole.log(a)   //ReferenceError:a is not defined\n```\n\n\n**let声明变量不存在变量提升**\nlet不像var那样会发生“变量提升”现象，所以，变量一定要在声明后使用，不然就会报错。\n\n```\nconsole.log(a)   //ReferenceError:a is not defined\nlet a = 1;\n```\n\n\n**暂时性死区**\n只要块级作用域内存在let关键字，它所声明的变量就绑定这个区域，不再受外部影响。\n\n```\nvar tmp = 20;\nif(true){\n    tmp = 'abc';    //ReferenceError:tmp is not defined\n    let tmp;\n}\n```\n上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定了这个块级作用域，所以在let声明变量前，对tmp赋值会报错。\n<div class=\"tip\">ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。在语法上称为“暂时性死区(temporal dead zone,TDZ)”</div>有时候，会不经间遇到比较隐蔽的“死区”，不太容易被发现。\n```\nfunction bar(x=y,y=2){\n    return [x,y];\n}\nbar() //报错\n```\n上面的代码中是因为参数x的默认值等于另一个参数y，而此时y还没有声明，属于死区。\n\n**不允许重复声明**\nlet不允许在相同的作用域内声明同一个变量。\n```\nfunction bar(){\n    let a = 10;\n    var a = 20;\n}\n//报错\n\nfunction bat(){\n    let a = 10;\n    let a = 20;\n}\n//报错\n```\n因此，所以也不能在函数内重复声明参数：\n```\nfunction bar(args){\n    let args = 10;  \n}\nbar() //报错\n\nfunction bar(args){\n    {\n        let args = 20;\n    }\n}\nbar()  //不报错\n```\n\n**块级作用域**\n\n使用let和const可以实现块级作用域：\n\n1. 外层代码块不受内层代码块的影响。\n2. 外层作用域无法读取内层作用域的变量。\n3. 内层作用域可以定义外层作用域的同名变量。\n\n块级作用域的实现，使得广泛使用的自执行匿名函数(IIFE)变得不再必要了。\n```\n//自执行模式\n(function(){\n    var a = 10;\n})()\n\n\n//块级作用域写法\nfunction(){\n    let a = 10;\n}\n```\n<div class=\"tip\">函数本身的作用域也在其所在的块级作用域之内。</div>\n\n## const\n\nconst用来声明常量。一旦声明，其值就不能再改变。\n```\nconst PI = 3.1415;\nconst PI = 3  //TypeErrorL \"PI\" is read-only\n```\n<div class=\"tip\">const声明的变量不得改变值，意味着 const 一旦声明常量就必须立即初始化，不能留到后面赋值。</div>\nconst与let关键字一样，只在声明所在的块级作用域内有效；const关键字声明的常量也不提升，同样存在暂时性死区，只能在声明后使用。\n<div class=\"tip\">对于复合型数据类型，常量名不指向数据，而是指向数据所在的地址。const关键字只是保证常量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须注意该点。</div>\n","source":"_posts/ES6-to-let-and-const.md","raw":"---\ntitle: ES6笔记之 let 和 const\ntags: es6\ncategories: es6\nabbrlink: 19172\ndate: 2016-10-17 21:51:50\n---\nES6新增了 let 和 const 命令，用来声明变量。它的用法类似于var，却有所区别。\n<!--more-->\n## let\nlet声明的变量只在其所在的代码块内有效。\n\n```\n{\n    let a = 1;\n}\nconsole.log(a)   //ReferenceError:a is not defined\n```\n\n\n**let声明变量不存在变量提升**\nlet不像var那样会发生“变量提升”现象，所以，变量一定要在声明后使用，不然就会报错。\n\n```\nconsole.log(a)   //ReferenceError:a is not defined\nlet a = 1;\n```\n\n\n**暂时性死区**\n只要块级作用域内存在let关键字，它所声明的变量就绑定这个区域，不再受外部影响。\n\n```\nvar tmp = 20;\nif(true){\n    tmp = 'abc';    //ReferenceError:tmp is not defined\n    let tmp;\n}\n```\n上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定了这个块级作用域，所以在let声明变量前，对tmp赋值会报错。\n<div class=\"tip\">ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。在语法上称为“暂时性死区(temporal dead zone,TDZ)”</div>有时候，会不经间遇到比较隐蔽的“死区”，不太容易被发现。\n```\nfunction bar(x=y,y=2){\n    return [x,y];\n}\nbar() //报错\n```\n上面的代码中是因为参数x的默认值等于另一个参数y，而此时y还没有声明，属于死区。\n\n**不允许重复声明**\nlet不允许在相同的作用域内声明同一个变量。\n```\nfunction bar(){\n    let a = 10;\n    var a = 20;\n}\n//报错\n\nfunction bat(){\n    let a = 10;\n    let a = 20;\n}\n//报错\n```\n因此，所以也不能在函数内重复声明参数：\n```\nfunction bar(args){\n    let args = 10;  \n}\nbar() //报错\n\nfunction bar(args){\n    {\n        let args = 20;\n    }\n}\nbar()  //不报错\n```\n\n**块级作用域**\n\n使用let和const可以实现块级作用域：\n\n1. 外层代码块不受内层代码块的影响。\n2. 外层作用域无法读取内层作用域的变量。\n3. 内层作用域可以定义外层作用域的同名变量。\n\n块级作用域的实现，使得广泛使用的自执行匿名函数(IIFE)变得不再必要了。\n```\n//自执行模式\n(function(){\n    var a = 10;\n})()\n\n\n//块级作用域写法\nfunction(){\n    let a = 10;\n}\n```\n<div class=\"tip\">函数本身的作用域也在其所在的块级作用域之内。</div>\n\n## const\n\nconst用来声明常量。一旦声明，其值就不能再改变。\n```\nconst PI = 3.1415;\nconst PI = 3  //TypeErrorL \"PI\" is read-only\n```\n<div class=\"tip\">const声明的变量不得改变值，意味着 const 一旦声明常量就必须立即初始化，不能留到后面赋值。</div>\nconst与let关键字一样，只在声明所在的块级作用域内有效；const关键字声明的常量也不提升，同样存在暂时性死区，只能在声明后使用。\n<div class=\"tip\">对于复合型数据类型，常量名不指向数据，而是指向数据所在的地址。const关键字只是保证常量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须注意该点。</div>\n","slug":"ES6-to-let-and-const","published":1,"updated":"2019-08-15T15:03:33.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhj50001xknw3ztol3v0","content":"<p>ES6新增了 let 和 const 命令，用来声明变量。它的用法类似于var，却有所区别。<br><a id=\"more\"></a></p>\n<h2 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h2><p>let声明的变量只在其所在的代码块内有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    let a = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a)   //ReferenceError:a is not defined</span><br></pre></td></tr></table></figure>\n<p><strong>let声明变量不存在变量提升</strong><br>let不像var那样会发生“变量提升”现象，所以，变量一定要在声明后使用，不然就会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a)   //ReferenceError:a is not defined</span><br><span class=\"line\">let a = 1;</span><br></pre></td></tr></table></figure>\n<p><strong>暂时性死区</strong><br>只要块级作用域内存在let关键字，它所声明的变量就绑定这个区域，不再受外部影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tmp = 20;</span><br><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    tmp = &apos;abc&apos;;    //ReferenceError:tmp is not defined</span><br><span class=\"line\">    let tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定了这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>\n<div class=\"tip\">ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。在语法上称为“暂时性死区(temporal dead zone,TDZ)”</div>有时候，会不经间遇到比较隐蔽的“死区”，不太容易被发现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bar(x=y,y=2)&#123;</span><br><span class=\"line\">    return [x,y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar() //报错</span><br></pre></td></tr></table></figure><br><br>上面的代码中是因为参数x的默认值等于另一个参数y，而此时y还没有声明，属于死区。<br><br><strong>不允许重复声明</strong><br>let不允许在相同的作用域内声明同一个变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bar()&#123;</span><br><span class=\"line\">    let a = 10;</span><br><span class=\"line\">    var a = 20;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//报错</span><br><span class=\"line\"></span><br><span class=\"line\">function bat()&#123;</span><br><span class=\"line\">    let a = 10;</span><br><span class=\"line\">    let a = 20;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//报错</span><br></pre></td></tr></table></figure><br><br>因此，所以也不能在函数内重复声明参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bar(args)&#123;</span><br><span class=\"line\">    let args = 10;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar() //报错</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(args)&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        let args = 20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar()  //不报错</span><br></pre></td></tr></table></figure><br><br><strong>块级作用域</strong><br><br>使用let和const可以实现块级作用域：<br><br>1. 外层代码块不受内层代码块的影响。<br>2. 外层作用域无法读取内层作用域的变量。<br>3. 内层作用域可以定义外层作用域的同名变量。<br><br>块级作用域的实现，使得广泛使用的自执行匿名函数(IIFE)变得不再必要了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//自执行模式</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    var a = 10;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//块级作用域写法</span><br><span class=\"line\">function()&#123;</span><br><span class=\"line\">    let a = 10;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><div class=\"tip\">函数本身的作用域也在其所在的块级作用域之内。</div>\n\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><p>const用来声明常量。一旦声明，其值就不能再改变。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PI = 3.1415;</span><br><span class=\"line\">const PI = 3  //TypeErrorL &quot;PI&quot; is read-only</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\">const声明的变量不得改变值，意味着 const 一旦声明常量就必须立即初始化，不能留到后面赋值。</div><br>const与let关键字一样，只在声明所在的块级作用域内有效；const关键字声明的常量也不提升，同样存在暂时性死区，只能在声明后使用。<br><div class=\"tip\">对于复合型数据类型，常量名不指向数据，而是指向数据所在的地址。const关键字只是保证常量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须注意该点。</div>\n","site":{"data":{}},"excerpt":"<p>ES6新增了 let 和 const 命令，用来声明变量。它的用法类似于var，却有所区别。<br>","more":"</p>\n<h2 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h2><p>let声明的变量只在其所在的代码块内有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    let a = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a)   //ReferenceError:a is not defined</span><br></pre></td></tr></table></figure>\n<p><strong>let声明变量不存在变量提升</strong><br>let不像var那样会发生“变量提升”现象，所以，变量一定要在声明后使用，不然就会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a)   //ReferenceError:a is not defined</span><br><span class=\"line\">let a = 1;</span><br></pre></td></tr></table></figure>\n<p><strong>暂时性死区</strong><br>只要块级作用域内存在let关键字，它所声明的变量就绑定这个区域，不再受外部影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tmp = 20;</span><br><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    tmp = &apos;abc&apos;;    //ReferenceError:tmp is not defined</span><br><span class=\"line\">    let tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定了这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>\n<div class=\"tip\">ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。在语法上称为“暂时性死区(temporal dead zone,TDZ)”</div>有时候，会不经间遇到比较隐蔽的“死区”，不太容易被发现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bar(x=y,y=2)&#123;</span><br><span class=\"line\">    return [x,y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar() //报错</span><br></pre></td></tr></table></figure><br><br>上面的代码中是因为参数x的默认值等于另一个参数y，而此时y还没有声明，属于死区。<br><br><strong>不允许重复声明</strong><br>let不允许在相同的作用域内声明同一个变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bar()&#123;</span><br><span class=\"line\">    let a = 10;</span><br><span class=\"line\">    var a = 20;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//报错</span><br><span class=\"line\"></span><br><span class=\"line\">function bat()&#123;</span><br><span class=\"line\">    let a = 10;</span><br><span class=\"line\">    let a = 20;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//报错</span><br></pre></td></tr></table></figure><br><br>因此，所以也不能在函数内重复声明参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bar(args)&#123;</span><br><span class=\"line\">    let args = 10;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar() //报错</span><br><span class=\"line\"></span><br><span class=\"line\">function bar(args)&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        let args = 20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar()  //不报错</span><br></pre></td></tr></table></figure><br><br><strong>块级作用域</strong><br><br>使用let和const可以实现块级作用域：<br><br>1. 外层代码块不受内层代码块的影响。<br>2. 外层作用域无法读取内层作用域的变量。<br>3. 内层作用域可以定义外层作用域的同名变量。<br><br>块级作用域的实现，使得广泛使用的自执行匿名函数(IIFE)变得不再必要了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//自执行模式</span><br><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    var a = 10;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//块级作用域写法</span><br><span class=\"line\">function()&#123;</span><br><span class=\"line\">    let a = 10;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><div class=\"tip\">函数本身的作用域也在其所在的块级作用域之内。</div>\n\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><p>const用来声明常量。一旦声明，其值就不能再改变。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PI = 3.1415;</span><br><span class=\"line\">const PI = 3  //TypeErrorL &quot;PI&quot; is read-only</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\">const声明的变量不得改变值，意味着 const 一旦声明常量就必须立即初始化，不能留到后面赋值。</div><br>const与let关键字一样，只在声明所在的块级作用域内有效；const关键字声明的常量也不提升，同样存在暂时性死区，只能在声明后使用。<br><div class=\"tip\">对于复合型数据类型，常量名不指向数据，而是指向数据所在的地址。const关键字只是保证常量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须注意该点。</div>"},{"title":"MongoDB 学习笔记","abbrlink":6031,"date":"2016-11-05T09:15:25.000Z","_content":"简介：MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\n<!--more-->\n## 常用shell\n开启服务：\n```\n$ net start MongoDB\n```\n停止服务：\n```\n$ net stop MongoDB\n```\n删除服务：\n```\n$ \"D:\\MongoDB\\bin\\Server\\3.2\\mongod.exe\" --remove\n```\n## 简单操作\n\n命令用于查看当前操作的文档（数据库）：\n```\n> db          //显示当前数据库对象或集合\n> show dbs     //显示所有数据的列表\n> use test    //运行\"use\"命令，可以连接到一个指定的数据库，这里连接到test数据库，如果连接的不存在，则自动新建\n> db.runoob.insert({\"name\":\"lengziyu\"}) //向 runoob 数据库插入一些数据\n> db.dropDatabase()   //删除当前数据库\n\n```\n","source":"_posts/MongoDB-learn-note.md","raw":"---\ntitle: MongoDB 学习笔记\ntags: mongodb\nabbrlink: 6031\ndate: 2016-11-05 17:15:25\ncategories:\n---\n简介：MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\n<!--more-->\n## 常用shell\n开启服务：\n```\n$ net start MongoDB\n```\n停止服务：\n```\n$ net stop MongoDB\n```\n删除服务：\n```\n$ \"D:\\MongoDB\\bin\\Server\\3.2\\mongod.exe\" --remove\n```\n## 简单操作\n\n命令用于查看当前操作的文档（数据库）：\n```\n> db          //显示当前数据库对象或集合\n> show dbs     //显示所有数据的列表\n> use test    //运行\"use\"命令，可以连接到一个指定的数据库，这里连接到test数据库，如果连接的不存在，则自动新建\n> db.runoob.insert({\"name\":\"lengziyu\"}) //向 runoob 数据库插入一些数据\n> db.dropDatabase()   //删除当前数据库\n\n```\n","slug":"MongoDB-learn-note","published":1,"updated":"2019-08-15T15:03:33.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhj90002xknwkm4i0t3t","content":"<p>简介：MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br><a id=\"more\"></a></p>\n<h2 id=\"常用shell\"><a href=\"#常用shell\" class=\"headerlink\" title=\"常用shell\"></a>常用shell</h2><p>开启服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ net start MongoDB</span><br></pre></td></tr></table></figure></p>\n<p>停止服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ net stop MongoDB</span><br></pre></td></tr></table></figure></p>\n<p>删除服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ &quot;D:\\MongoDB\\bin\\Server\\3.2\\mongod.exe&quot; --remove</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"简单操作\"><a href=\"#简单操作\" class=\"headerlink\" title=\"简单操作\"></a>简单操作</h2><p>命令用于查看当前操作的文档（数据库）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db          //显示当前数据库对象或集合</span><br><span class=\"line\">&gt; show dbs     //显示所有数据的列表</span><br><span class=\"line\">&gt; use test    //运行&quot;use&quot;命令，可以连接到一个指定的数据库，这里连接到test数据库，如果连接的不存在，则自动新建</span><br><span class=\"line\">&gt; db.runoob.insert(&#123;&quot;name&quot;:&quot;lengziyu&quot;&#125;) //向 runoob 数据库插入一些数据</span><br><span class=\"line\">&gt; db.dropDatabase()   //删除当前数据库</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>简介：MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>","more":"</p>\n<h2 id=\"常用shell\"><a href=\"#常用shell\" class=\"headerlink\" title=\"常用shell\"></a>常用shell</h2><p>开启服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ net start MongoDB</span><br></pre></td></tr></table></figure></p>\n<p>停止服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ net stop MongoDB</span><br></pre></td></tr></table></figure></p>\n<p>删除服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ &quot;D:\\MongoDB\\bin\\Server\\3.2\\mongod.exe&quot; --remove</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"简单操作\"><a href=\"#简单操作\" class=\"headerlink\" title=\"简单操作\"></a>简单操作</h2><p>命令用于查看当前操作的文档（数据库）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db          //显示当前数据库对象或集合</span><br><span class=\"line\">&gt; show dbs     //显示所有数据的列表</span><br><span class=\"line\">&gt; use test    //运行&quot;use&quot;命令，可以连接到一个指定的数据库，这里连接到test数据库，如果连接的不存在，则自动新建</span><br><span class=\"line\">&gt; db.runoob.insert(&#123;&quot;name&quot;:&quot;lengziyu&quot;&#125;) //向 runoob 数据库插入一些数据</span><br><span class=\"line\">&gt; db.dropDatabase()   //删除当前数据库</span><br></pre></td></tr></table></figure></p>"},{"title":"Redux 简明教程（转）","abbrlink":51341,"date":"2016-10-13T12:26:49.000Z","_content":"Redux 是 JavaScript 状态容器，提供可预测化的状态管理。\n\n可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个[时间旅行调试器可以编辑后实时预览](https://github.com/gaearon/redux-devtools)。\n<!--more-->\n\nRedux 除了和 React 一起用外，还支持其它界面库。\n它体小精悍（只有2kB）且没有任何依赖。\n\n## 启示\nRedux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性。\n\n## Store\n首先要区分 `store` 和 `state`\n`state` 是应用的状态，一般本质上是一个普通对象\n例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能\n那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）：\n```\n/** 应用初始 state，本代码块记为 code-1 **/\n{\n  counter: 0,\n  todos: []\n}\n```\n`store` 是应用状态 `state` 的管理者，包含下列四个函数：\n- getState() # 获取整个 state\n- dispatch(action) # ※ 触发 state 改变的【唯一途径】※\n- subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener\n- replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用\n\n二者的关系是：`state = store.getState()`\nRedux 规定，一个应用只应有一个单一的 `store`，其管理着唯一的应用状态 `state`\nRedux 还规定，不能直接修改应用的状态 `state`，也就是说，下面的行为是不允许的：\n\n```\nvar state = store.getState()\nstate.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state\n```\n若要改变 `state`，必须 `dispatch` 一个 `action`，这是修改应用状态的不二法门\n<div class=\"tip\">\n现在您只需要记住 action 只是一个包含 type 属性的普通对象即可\n例如 { type: 'INCREMENT' }\n</div>\n上面提到，`state` 是通过 `store.getState()` 获取，那么 `store` 又是怎么来的呢？\n想生成一个 `store`，我们需要调用 Redux 的 `createStore`：\n```\nimport { createStore } from 'redux'\n...\nconst store = createStore(reducer, initialState) // store 是靠传入 reducer 生成的哦！\n```\n<div class=\"tip\">\n现在您只需要记住 reducer 是一个 函数，负责更新并返回一个新的 state\n而 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染）\n</div>\n\n## Action\n上面提到，`action`（动作）实质上是包含 `type` 属性的普通对象，这个 `type` 是我们实现用户行为追踪的关键\n例如，增加一个待办事项 的 `action` 可能是像下面一样：\n```\n/** 本代码块记为 code-2 **/\n{\n  type: 'ADD_TODO',\n  payload: {\n    id: 1,\n    content: '待办事项1',\n    completed: false\n  }\n}\n```\n当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了\n也就是说，下面这些 action 都是合法的：\n```\n/** 如下都是合法的，但就是不够规范 **/\n{\n  type: 'ADD_TODO',\n  id: 1,\n  content: '待办事项1',\n  completed: false\n}\n\n{\n  type: 'ADD_TODO',\n  abcdefg: {\n    id: 1,\n    content: '待办事项1',\n    completed: false\n  }\n}\n```\n**虽说没有约束，但最好还是遵循[规范](https://github.com/acdlite/flux-standard-action)**\n如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）：\n```\n/** 本代码块记为 code-3 **/\n{\n  counter: 0,\n  todos: [{\n    id: 1,\n    content: '待办事项1',\n    completed: false\n  }]\n}\n```\n刨根问底，action 是谁生成的呢？\n\n## Action Creator\n<div class=\"tip\">\nAction Creator 可以是同步的，也可以是异步的\n</div>\n顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）\n例如下面就是一个 “新增一个待办事项” 的 Action Creator：\n```\n/** 本代码块记为 code-4 **/\nvar id = 1\nfunction addTodo(content) {\n  return {\n    type: 'ADD_TODO',\n    payload: {\n      id: id++,\n      content: content, // 待办事项内容\n      completed: false  // 是否完成的标识\n    }\n  }\n}\n```\n将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）：\n```\n<--! 本代码块记为 code-5 -->\n<input type=\"text\" id=\"todoInput\" />\n<button id=\"btn\">提交</button>\n\n<script>\n$('#btn').on('click', function() {\n  var content = $('#todoInput').val() // 获取输入框的值\n  var action = addTodo(content) // 执行 Action Creator 获得 action\n  store.dispatch(action) // 改变 state 的不二法门：dispatch 一个 action！！！\n})\n</script>\n```\n在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了：\n```\n/** 本代码块记为 code-6 **/\n{\n  counter: 0,\n  todos: [{\n    id: 1,\n    content: '待办事项1',\n    completed: false\n  }, {\n    id: 2,\n    content: '待办事项2',\n    completed: false\n  }]\n}\n```\n**通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action)**\n刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，\nRedux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？\n又是谁负责“写入”的呢？悬念即将揭晓...\n\n## Reducer\n**Reducer 必须是同步的纯函数**\n用户每次 dispatch(action) 后，都会触发 reducer 的执行\nreducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState\n最后会用 reducer 的返回值 nextState 完全替换掉原来的 state\n<div class=\"tip\">\n注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改\nRedux 规定，须先复制一份 state，在副本 nextState 上进行修改操作\n例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ ... 等返回副本的函数\n</div>\n在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)：\n```\n/** 本代码块记为 code-7 **/\nvar initState = {\n  counter: 0,\n  todos: []\n}\n\nfunction reducer(state, action) {\n  // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※\n  if (!state) state = initState\n\n  switch (action.type) {\n    case 'ADD_TODO':\n      var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆\n      nextState.todos.push(action.payload)\n      return nextState\n\n    default:\n    // 由于 nextState 会把原 state 整个替换掉\n    // 若无修改，必须返回原 state（否则就是 undefined）\n      return state\n  }\n}\n```\n通俗点讲，就是 reducer 返回啥，state 就被替换成啥\n\n## 总结\n- store 由 Redux 的 createStore(reducer) 生成\n- state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象\n- action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生\n- 改变 state 必须 dispatch 一个 action\n- reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数\n- reducer 必须返回值，否则 nextState 即为 undefined\n- 实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单）\n\n**Action Creator => action => store.dispatch(action) => reducer(state, action) => 原 state state = nextState**\n\n原文地址：[Redux 简明教程](https://github.com/kenberkeley/redux-simple-tutorial)\n","source":"_posts/Redux-学习笔记.md","raw":"---\ntitle: Redux 简明教程（转）\ntags: redux\ncategories: redux\nabbrlink: 51341\ndate: 2016-10-13 20:26:49\n---\nRedux 是 JavaScript 状态容器，提供可预测化的状态管理。\n\n可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个[时间旅行调试器可以编辑后实时预览](https://github.com/gaearon/redux-devtools)。\n<!--more-->\n\nRedux 除了和 React 一起用外，还支持其它界面库。\n它体小精悍（只有2kB）且没有任何依赖。\n\n## 启示\nRedux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性。\n\n## Store\n首先要区分 `store` 和 `state`\n`state` 是应用的状态，一般本质上是一个普通对象\n例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能\n那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）：\n```\n/** 应用初始 state，本代码块记为 code-1 **/\n{\n  counter: 0,\n  todos: []\n}\n```\n`store` 是应用状态 `state` 的管理者，包含下列四个函数：\n- getState() # 获取整个 state\n- dispatch(action) # ※ 触发 state 改变的【唯一途径】※\n- subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener\n- replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用\n\n二者的关系是：`state = store.getState()`\nRedux 规定，一个应用只应有一个单一的 `store`，其管理着唯一的应用状态 `state`\nRedux 还规定，不能直接修改应用的状态 `state`，也就是说，下面的行为是不允许的：\n\n```\nvar state = store.getState()\nstate.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state\n```\n若要改变 `state`，必须 `dispatch` 一个 `action`，这是修改应用状态的不二法门\n<div class=\"tip\">\n现在您只需要记住 action 只是一个包含 type 属性的普通对象即可\n例如 { type: 'INCREMENT' }\n</div>\n上面提到，`state` 是通过 `store.getState()` 获取，那么 `store` 又是怎么来的呢？\n想生成一个 `store`，我们需要调用 Redux 的 `createStore`：\n```\nimport { createStore } from 'redux'\n...\nconst store = createStore(reducer, initialState) // store 是靠传入 reducer 生成的哦！\n```\n<div class=\"tip\">\n现在您只需要记住 reducer 是一个 函数，负责更新并返回一个新的 state\n而 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染）\n</div>\n\n## Action\n上面提到，`action`（动作）实质上是包含 `type` 属性的普通对象，这个 `type` 是我们实现用户行为追踪的关键\n例如，增加一个待办事项 的 `action` 可能是像下面一样：\n```\n/** 本代码块记为 code-2 **/\n{\n  type: 'ADD_TODO',\n  payload: {\n    id: 1,\n    content: '待办事项1',\n    completed: false\n  }\n}\n```\n当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了\n也就是说，下面这些 action 都是合法的：\n```\n/** 如下都是合法的，但就是不够规范 **/\n{\n  type: 'ADD_TODO',\n  id: 1,\n  content: '待办事项1',\n  completed: false\n}\n\n{\n  type: 'ADD_TODO',\n  abcdefg: {\n    id: 1,\n    content: '待办事项1',\n    completed: false\n  }\n}\n```\n**虽说没有约束，但最好还是遵循[规范](https://github.com/acdlite/flux-standard-action)**\n如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）：\n```\n/** 本代码块记为 code-3 **/\n{\n  counter: 0,\n  todos: [{\n    id: 1,\n    content: '待办事项1',\n    completed: false\n  }]\n}\n```\n刨根问底，action 是谁生成的呢？\n\n## Action Creator\n<div class=\"tip\">\nAction Creator 可以是同步的，也可以是异步的\n</div>\n顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）\n例如下面就是一个 “新增一个待办事项” 的 Action Creator：\n```\n/** 本代码块记为 code-4 **/\nvar id = 1\nfunction addTodo(content) {\n  return {\n    type: 'ADD_TODO',\n    payload: {\n      id: id++,\n      content: content, // 待办事项内容\n      completed: false  // 是否完成的标识\n    }\n  }\n}\n```\n将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）：\n```\n<--! 本代码块记为 code-5 -->\n<input type=\"text\" id=\"todoInput\" />\n<button id=\"btn\">提交</button>\n\n<script>\n$('#btn').on('click', function() {\n  var content = $('#todoInput').val() // 获取输入框的值\n  var action = addTodo(content) // 执行 Action Creator 获得 action\n  store.dispatch(action) // 改变 state 的不二法门：dispatch 一个 action！！！\n})\n</script>\n```\n在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了：\n```\n/** 本代码块记为 code-6 **/\n{\n  counter: 0,\n  todos: [{\n    id: 1,\n    content: '待办事项1',\n    completed: false\n  }, {\n    id: 2,\n    content: '待办事项2',\n    completed: false\n  }]\n}\n```\n**通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action)**\n刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，\nRedux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？\n又是谁负责“写入”的呢？悬念即将揭晓...\n\n## Reducer\n**Reducer 必须是同步的纯函数**\n用户每次 dispatch(action) 后，都会触发 reducer 的执行\nreducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState\n最后会用 reducer 的返回值 nextState 完全替换掉原来的 state\n<div class=\"tip\">\n注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改\nRedux 规定，须先复制一份 state，在副本 nextState 上进行修改操作\n例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ ... 等返回副本的函数\n</div>\n在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)：\n```\n/** 本代码块记为 code-7 **/\nvar initState = {\n  counter: 0,\n  todos: []\n}\n\nfunction reducer(state, action) {\n  // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※\n  if (!state) state = initState\n\n  switch (action.type) {\n    case 'ADD_TODO':\n      var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆\n      nextState.todos.push(action.payload)\n      return nextState\n\n    default:\n    // 由于 nextState 会把原 state 整个替换掉\n    // 若无修改，必须返回原 state（否则就是 undefined）\n      return state\n  }\n}\n```\n通俗点讲，就是 reducer 返回啥，state 就被替换成啥\n\n## 总结\n- store 由 Redux 的 createStore(reducer) 生成\n- state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象\n- action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生\n- 改变 state 必须 dispatch 一个 action\n- reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数\n- reducer 必须返回值，否则 nextState 即为 undefined\n- 实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单）\n\n**Action Creator => action => store.dispatch(action) => reducer(state, action) => 原 state state = nextState**\n\n原文地址：[Redux 简明教程](https://github.com/kenberkeley/redux-simple-tutorial)\n","slug":"Redux-学习笔记","published":1,"updated":"2019-08-15T15:03:33.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhje0005xknwoemosqtl","content":"<p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>\n<p>可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个<a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\" rel=\"noopener\">时间旅行调试器可以编辑后实时预览</a>。<br><a id=\"more\"></a></p>\n<p>Redux 除了和 React 一起用外，还支持其它界面库。<br>它体小精悍（只有2kB）且没有任何依赖。</p>\n<h2 id=\"启示\"><a href=\"#启示\" class=\"headerlink\" title=\"启示\"></a>启示</h2><p>Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性。</p>\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2><p>首先要区分 <code>store</code> 和 <code>state</code><br><code>state</code> 是应用的状态，一般本质上是一个普通对象<br>例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能<br>那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 应用初始 state，本代码块记为 code-1 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  counter: 0,</span><br><span class=\"line\">  todos: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>store</code> 是应用状态 <code>state</code> 的管理者，包含下列四个函数：</p>\n<ul>\n<li>getState() # 获取整个 state</li>\n<li>dispatch(action) # ※ 触发 state 改变的【唯一途径】※</li>\n<li>subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener</li>\n<li>replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用</li>\n</ul>\n<p>二者的关系是：<code>state = store.getState()</code><br>Redux 规定，一个应用只应有一个单一的 <code>store</code>，其管理着唯一的应用状态 <code>state</code><br>Redux 还规定，不能直接修改应用的状态 <code>state</code>，也就是说，下面的行为是不允许的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var state = store.getState()</span><br><span class=\"line\">state.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state</span><br></pre></td></tr></table></figure>\n<p>若要改变 <code>state</code>，必须 <code>dispatch</code> 一个 <code>action</code>，这是修改应用状态的不二法门</p>\n<div class=\"tip\"><br>现在您只需要记住 action 只是一个包含 type 属性的普通对象即可<br>例如 { type: ‘INCREMENT’ }<br></div><br>上面提到，<code>state</code> 是通过 <code>store.getState()</code> 获取，那么 <code>store</code> 又是怎么来的呢？<br>想生成一个 <code>store</code>，我们需要调用 Redux 的 <code>createStore</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class=\"line\">...</span><br><span class=\"line\">const store = createStore(reducer, initialState) // store 是靠传入 reducer 生成的哦！</span><br></pre></td></tr></table></figure><br><br><div class=\"tip\"><br>现在您只需要记住 reducer 是一个 函数，负责更新并返回一个新的 state<br>而 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染）<br></div>\n\n<h2 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h2><p>上面提到，<code>action</code>（动作）实质上是包含 <code>type</code> 属性的普通对象，这个 <code>type</code> 是我们实现用户行为追踪的关键<br>例如，增加一个待办事项 的 <code>action</code> 可能是像下面一样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-2 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  payload: &#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    content: &apos;待办事项1&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了<br>也就是说，下面这些 action 都是合法的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 如下都是合法的，但就是不够规范 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  id: 1,</span><br><span class=\"line\">  content: &apos;待办事项1&apos;,</span><br><span class=\"line\">  completed: false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  abcdefg: &#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    content: &apos;待办事项1&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>虽说没有约束，但最好还是遵循<a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\" rel=\"noopener\">规范</a></strong><br>如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-3 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  counter: 0,</span><br><span class=\"line\">  todos: [&#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    content: &apos;待办事项1&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>刨根问底，action 是谁生成的呢？</p>\n<h2 id=\"Action-Creator\"><a href=\"#Action-Creator\" class=\"headerlink\" title=\"Action Creator\"></a>Action Creator</h2><p><div class=\"tip\"><br>Action Creator 可以是同步的，也可以是异步的<br></div><br>顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）<br>例如下面就是一个 “新增一个待办事项” 的 Action Creator：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-4 **/</span><br><span class=\"line\">var id = 1</span><br><span class=\"line\">function addTodo(content) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">    payload: &#123;</span><br><span class=\"line\">      id: id++,</span><br><span class=\"line\">      content: content, // 待办事项内容</span><br><span class=\"line\">      completed: false  // 是否完成的标识</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;--! 本代码块记为 code-5 --&gt;</span><br><span class=\"line\">&lt;input type=&quot;text&quot; id=&quot;todoInput&quot; /&gt;</span><br><span class=\"line\">&lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123;</span><br><span class=\"line\">  var content = $(&apos;#todoInput&apos;).val() // 获取输入框的值</span><br><span class=\"line\">  var action = addTodo(content) // 执行 Action Creator 获得 action</span><br><span class=\"line\">  store.dispatch(action) // 改变 state 的不二法门：dispatch 一个 action！！！</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-6 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  counter: 0,</span><br><span class=\"line\">  todos: [&#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    content: &apos;待办事项1&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;, &#123;</span><br><span class=\"line\">    id: 2,</span><br><span class=\"line\">    content: &apos;待办事项2&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action)</strong><br>刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，<br>Redux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？<br>又是谁负责“写入”的呢？悬念即将揭晓…</p>\n<h2 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h2><p><strong>Reducer 必须是同步的纯函数</strong><br>用户每次 dispatch(action) 后，都会触发 reducer 的执行<br>reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState<br>最后会用 reducer 的返回值 nextState 完全替换掉原来的 state</p>\n<p><div class=\"tip\"><br>注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改<br>Redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作<br>例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ … 等返回副本的函数<br></div><br>在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-7 **/</span><br><span class=\"line\">var initState = &#123;</span><br><span class=\"line\">  counter: 0,</span><br><span class=\"line\">  todos: []</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function reducer(state, action) &#123;</span><br><span class=\"line\">  // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※</span><br><span class=\"line\">  if (!state) state = initState</span><br><span class=\"line\"></span><br><span class=\"line\">  switch (action.type) &#123;</span><br><span class=\"line\">    case &apos;ADD_TODO&apos;:</span><br><span class=\"line\">      var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆</span><br><span class=\"line\">      nextState.todos.push(action.payload)</span><br><span class=\"line\">      return nextState</span><br><span class=\"line\"></span><br><span class=\"line\">    default:</span><br><span class=\"line\">    // 由于 nextState 会把原 state 整个替换掉</span><br><span class=\"line\">    // 若无修改，必须返回原 state（否则就是 undefined）</span><br><span class=\"line\">      return state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通俗点讲，就是 reducer 返回啥，state 就被替换成啥</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>store 由 Redux 的 createStore(reducer) 生成</li>\n<li>state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象</li>\n<li>action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生</li>\n<li>改变 state 必须 dispatch 一个 action</li>\n<li>reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数</li>\n<li>reducer 必须返回值，否则 nextState 即为 undefined</li>\n<li>实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单）</li>\n</ul>\n<p><strong>Action Creator =&gt; action =&gt; store.dispatch(action) =&gt; reducer(state, action) =&gt; 原 state state = nextState</strong></p>\n<p>原文地址：<a href=\"https://github.com/kenberkeley/redux-simple-tutorial\" target=\"_blank\" rel=\"noopener\">Redux 简明教程</a></p>\n","site":{"data":{}},"excerpt":"<p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>\n<p>可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个<a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\" rel=\"noopener\">时间旅行调试器可以编辑后实时预览</a>。<br>","more":"</p>\n<p>Redux 除了和 React 一起用外，还支持其它界面库。<br>它体小精悍（只有2kB）且没有任何依赖。</p>\n<h2 id=\"启示\"><a href=\"#启示\" class=\"headerlink\" title=\"启示\"></a>启示</h2><p>Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性。</p>\n<h2 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h2><p>首先要区分 <code>store</code> 和 <code>state</code><br><code>state</code> 是应用的状态，一般本质上是一个普通对象<br>例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能<br>那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 应用初始 state，本代码块记为 code-1 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  counter: 0,</span><br><span class=\"line\">  todos: []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>store</code> 是应用状态 <code>state</code> 的管理者，包含下列四个函数：</p>\n<ul>\n<li>getState() # 获取整个 state</li>\n<li>dispatch(action) # ※ 触发 state 改变的【唯一途径】※</li>\n<li>subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener</li>\n<li>replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用</li>\n</ul>\n<p>二者的关系是：<code>state = store.getState()</code><br>Redux 规定，一个应用只应有一个单一的 <code>store</code>，其管理着唯一的应用状态 <code>state</code><br>Redux 还规定，不能直接修改应用的状态 <code>state</code>，也就是说，下面的行为是不允许的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var state = store.getState()</span><br><span class=\"line\">state.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state</span><br></pre></td></tr></table></figure>\n<p>若要改变 <code>state</code>，必须 <code>dispatch</code> 一个 <code>action</code>，这是修改应用状态的不二法门</p>\n<div class=\"tip\"><br>现在您只需要记住 action 只是一个包含 type 属性的普通对象即可<br>例如 { type: ‘INCREMENT’ }<br></div><br>上面提到，<code>state</code> 是通过 <code>store.getState()</code> 获取，那么 <code>store</code> 又是怎么来的呢？<br>想生成一个 <code>store</code>，我们需要调用 Redux 的 <code>createStore</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class=\"line\">...</span><br><span class=\"line\">const store = createStore(reducer, initialState) // store 是靠传入 reducer 生成的哦！</span><br></pre></td></tr></table></figure><br><br><div class=\"tip\"><br>现在您只需要记住 reducer 是一个 函数，负责更新并返回一个新的 state<br>而 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染）<br></div>\n\n<h2 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h2><p>上面提到，<code>action</code>（动作）实质上是包含 <code>type</code> 属性的普通对象，这个 <code>type</code> 是我们实现用户行为追踪的关键<br>例如，增加一个待办事项 的 <code>action</code> 可能是像下面一样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-2 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  payload: &#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    content: &apos;待办事项1&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了<br>也就是说，下面这些 action 都是合法的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 如下都是合法的，但就是不够规范 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  id: 1,</span><br><span class=\"line\">  content: &apos;待办事项1&apos;,</span><br><span class=\"line\">  completed: false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  abcdefg: &#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    content: &apos;待办事项1&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>虽说没有约束，但最好还是遵循<a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\" rel=\"noopener\">规范</a></strong><br>如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-3 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  counter: 0,</span><br><span class=\"line\">  todos: [&#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    content: &apos;待办事项1&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>刨根问底，action 是谁生成的呢？</p>\n<h2 id=\"Action-Creator\"><a href=\"#Action-Creator\" class=\"headerlink\" title=\"Action Creator\"></a>Action Creator</h2><p><div class=\"tip\"><br>Action Creator 可以是同步的，也可以是异步的<br></div><br>顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）<br>例如下面就是一个 “新增一个待办事项” 的 Action Creator：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-4 **/</span><br><span class=\"line\">var id = 1</span><br><span class=\"line\">function addTodo(content) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">    payload: &#123;</span><br><span class=\"line\">      id: id++,</span><br><span class=\"line\">      content: content, // 待办事项内容</span><br><span class=\"line\">      completed: false  // 是否完成的标识</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;--! 本代码块记为 code-5 --&gt;</span><br><span class=\"line\">&lt;input type=&quot;text&quot; id=&quot;todoInput&quot; /&gt;</span><br><span class=\"line\">&lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123;</span><br><span class=\"line\">  var content = $(&apos;#todoInput&apos;).val() // 获取输入框的值</span><br><span class=\"line\">  var action = addTodo(content) // 执行 Action Creator 获得 action</span><br><span class=\"line\">  store.dispatch(action) // 改变 state 的不二法门：dispatch 一个 action！！！</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-6 **/</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  counter: 0,</span><br><span class=\"line\">  todos: [&#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    content: &apos;待办事项1&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;, &#123;</span><br><span class=\"line\">    id: 2,</span><br><span class=\"line\">    content: &apos;待办事项2&apos;,</span><br><span class=\"line\">    completed: false</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action)</strong><br>刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，<br>Redux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？<br>又是谁负责“写入”的呢？悬念即将揭晓…</p>\n<h2 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h2><p><strong>Reducer 必须是同步的纯函数</strong><br>用户每次 dispatch(action) 后，都会触发 reducer 的执行<br>reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState<br>最后会用 reducer 的返回值 nextState 完全替换掉原来的 state</p>\n<p><div class=\"tip\"><br>注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改<br>Redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作<br>例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ … 等返回副本的函数<br></div><br>在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 本代码块记为 code-7 **/</span><br><span class=\"line\">var initState = &#123;</span><br><span class=\"line\">  counter: 0,</span><br><span class=\"line\">  todos: []</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function reducer(state, action) &#123;</span><br><span class=\"line\">  // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※</span><br><span class=\"line\">  if (!state) state = initState</span><br><span class=\"line\"></span><br><span class=\"line\">  switch (action.type) &#123;</span><br><span class=\"line\">    case &apos;ADD_TODO&apos;:</span><br><span class=\"line\">      var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆</span><br><span class=\"line\">      nextState.todos.push(action.payload)</span><br><span class=\"line\">      return nextState</span><br><span class=\"line\"></span><br><span class=\"line\">    default:</span><br><span class=\"line\">    // 由于 nextState 会把原 state 整个替换掉</span><br><span class=\"line\">    // 若无修改，必须返回原 state（否则就是 undefined）</span><br><span class=\"line\">      return state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通俗点讲，就是 reducer 返回啥，state 就被替换成啥</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>store 由 Redux 的 createStore(reducer) 生成</li>\n<li>state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象</li>\n<li>action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生</li>\n<li>改变 state 必须 dispatch 一个 action</li>\n<li>reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数</li>\n<li>reducer 必须返回值，否则 nextState 即为 undefined</li>\n<li>实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单）</li>\n</ul>\n<p><strong>Action Creator =&gt; action =&gt; store.dispatch(action) =&gt; reducer(state, action) =&gt; 原 state state = nextState</strong></p>\n<p>原文地址：<a href=\"https://github.com/kenberkeley/redux-simple-tutorial\" target=\"_blank\" rel=\"noopener\">Redux 简明教程</a></p>"},{"title":"fetch 学习笔记","abbrlink":53312,"date":"2016-10-23T11:58:14.000Z","_content":"XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。\n<!--more-->\n## 安装\nnpm ：\n```\n$ npm install whatwg-fetch --save\n```\n如果你项目在node.js环境运行，可以使用 [node-fetch](https://github.com/bitinn/node-fetch).\n\n对于 babel 和 es2015+，可以这样导入 fetch：\n```\nimport 'whatwg-fetch';\nfetch(...);\n```\n## 兼容性及解决方案\n原生支持率并不高，幸运的是，引入下面这些 `polyfill` 后可以完美支持 IE8+ ：\n\n- 由于 IE8 是 ES3，需要引入 ES5 的 `polyfill`: `es5-shim`, `es5-sham`；\n- 引入 Promise 的 `polyfill`: `es6-promise`；\n- 引入 fetch 探测库：fetch-detector；\n- 引入 fetch 的 polyfill: fetch-ie8；\n- 可选：如果你还使用了 jsonp，引入 fetch-jsonp；\n\n## 使用\nfetch 支持 HTTP 方法，下面主要用例子讲解 POST 和 GET 的请求。\n**HTML 请求：**\n```\nfetch('/users.html')\n  .then(function(response) {\n    return response.text()\n  }).then(function(body) {\n    document.body.innerHTML = body\n  })\n```\n**JSON 请求：**\n```\nfetch('/users.json')\n  .then(function(response) {\n    return response.json()\n  }).then(function(json) {\n    console.log('parsed json', json)\n  }).catch(function(ex) {\n    console.log('parsing failed', ex)\n  })\n```\n**响应头设置：**\n```\nfetch('/users.json').then(function(response) {\n  console.log(response.headers.get('Content-Type'))\n  console.log(response.headers.get('Date'))\n  console.log(response.status)\n  console.log(response.statusText)\n})\n```\n**Post 表单提交：**\n```\nvar form = document.querySelector('form')\n\nfetch('/users', {\n  method: 'POST',\n  body: new FormData(form)\n})\n```\n**Post JSON：**\n```\nfetch('/users', {\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    name: 'Hubot',\n    login: 'hubot',\n  })\n})\n```\n**上传文件：**\n```\nvar input = document.querySelector('input[type=\"file\"]')\n\nvar data = new FormData()\ndata.append('file', input.files[0])\ndata.append('user', 'hubot')\n\nfetch('/avatars', {\n  method: 'POST',\n  body: data\n})\n```\n## 使用注意：\n- Fetch 请求默认是不带 cookie 的，需要设置 `fetch(url, {credentials: 'include'})`\n- 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\n","source":"_posts/ajax-to-fetch.md","raw":"---\ntitle: fetch 学习笔记\ntags: fetch\ncategories: fetch\nabbrlink: 53312\ndate: 2016-10-23 19:58:14\n---\nXMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。\n<!--more-->\n## 安装\nnpm ：\n```\n$ npm install whatwg-fetch --save\n```\n如果你项目在node.js环境运行，可以使用 [node-fetch](https://github.com/bitinn/node-fetch).\n\n对于 babel 和 es2015+，可以这样导入 fetch：\n```\nimport 'whatwg-fetch';\nfetch(...);\n```\n## 兼容性及解决方案\n原生支持率并不高，幸运的是，引入下面这些 `polyfill` 后可以完美支持 IE8+ ：\n\n- 由于 IE8 是 ES3，需要引入 ES5 的 `polyfill`: `es5-shim`, `es5-sham`；\n- 引入 Promise 的 `polyfill`: `es6-promise`；\n- 引入 fetch 探测库：fetch-detector；\n- 引入 fetch 的 polyfill: fetch-ie8；\n- 可选：如果你还使用了 jsonp，引入 fetch-jsonp；\n\n## 使用\nfetch 支持 HTTP 方法，下面主要用例子讲解 POST 和 GET 的请求。\n**HTML 请求：**\n```\nfetch('/users.html')\n  .then(function(response) {\n    return response.text()\n  }).then(function(body) {\n    document.body.innerHTML = body\n  })\n```\n**JSON 请求：**\n```\nfetch('/users.json')\n  .then(function(response) {\n    return response.json()\n  }).then(function(json) {\n    console.log('parsed json', json)\n  }).catch(function(ex) {\n    console.log('parsing failed', ex)\n  })\n```\n**响应头设置：**\n```\nfetch('/users.json').then(function(response) {\n  console.log(response.headers.get('Content-Type'))\n  console.log(response.headers.get('Date'))\n  console.log(response.status)\n  console.log(response.statusText)\n})\n```\n**Post 表单提交：**\n```\nvar form = document.querySelector('form')\n\nfetch('/users', {\n  method: 'POST',\n  body: new FormData(form)\n})\n```\n**Post JSON：**\n```\nfetch('/users', {\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    name: 'Hubot',\n    login: 'hubot',\n  })\n})\n```\n**上传文件：**\n```\nvar input = document.querySelector('input[type=\"file\"]')\n\nvar data = new FormData()\ndata.append('file', input.files[0])\ndata.append('user', 'hubot')\n\nfetch('/avatars', {\n  method: 'POST',\n  body: data\n})\n```\n## 使用注意：\n- Fetch 请求默认是不带 cookie 的，需要设置 `fetch(url, {credentials: 'include'})`\n- 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\n","slug":"ajax-to-fetch","published":1,"updated":"2019-08-15T15:03:33.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjf0006xknwvctaz48x","content":"<p>XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。<br><a id=\"more\"></a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>npm ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install whatwg-fetch --save</span><br></pre></td></tr></table></figure></p>\n<p>如果你项目在node.js环境运行，可以使用 <a href=\"https://github.com/bitinn/node-fetch\" target=\"_blank\" rel=\"noopener\">node-fetch</a>.</p>\n<p>对于 babel 和 es2015+，可以这样导入 fetch：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;whatwg-fetch&apos;;</span><br><span class=\"line\">fetch(...);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"兼容性及解决方案\"><a href=\"#兼容性及解决方案\" class=\"headerlink\" title=\"兼容性及解决方案\"></a>兼容性及解决方案</h2><p>原生支持率并不高，幸运的是，引入下面这些 <code>polyfill</code> 后可以完美支持 IE8+ ：</p>\n<ul>\n<li>由于 IE8 是 ES3，需要引入 ES5 的 <code>polyfill</code>: <code>es5-shim</code>, <code>es5-sham</code>；</li>\n<li>引入 Promise 的 <code>polyfill</code>: <code>es6-promise</code>；</li>\n<li>引入 fetch 探测库：fetch-detector；</li>\n<li>引入 fetch 的 polyfill: fetch-ie8；</li>\n<li>可选：如果你还使用了 jsonp，引入 fetch-jsonp；</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>fetch 支持 HTTP 方法，下面主要用例子讲解 POST 和 GET 的请求。<br><strong>HTML 请求：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&apos;/users.html&apos;)</span><br><span class=\"line\">  .then(function(response) &#123;</span><br><span class=\"line\">    return response.text()</span><br><span class=\"line\">  &#125;).then(function(body) &#123;</span><br><span class=\"line\">    document.body.innerHTML = body</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>JSON 请求：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&apos;/users.json&apos;)</span><br><span class=\"line\">  .then(function(response) &#123;</span><br><span class=\"line\">    return response.json()</span><br><span class=\"line\">  &#125;).then(function(json) &#123;</span><br><span class=\"line\">    console.log(&apos;parsed json&apos;, json)</span><br><span class=\"line\">  &#125;).catch(function(ex) &#123;</span><br><span class=\"line\">    console.log(&apos;parsing failed&apos;, ex)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>响应头设置：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&apos;/users.json&apos;).then(function(response) &#123;</span><br><span class=\"line\">  console.log(response.headers.get(&apos;Content-Type&apos;))</span><br><span class=\"line\">  console.log(response.headers.get(&apos;Date&apos;))</span><br><span class=\"line\">  console.log(response.status)</span><br><span class=\"line\">  console.log(response.statusText)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>Post 表单提交：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var form = document.querySelector(&apos;form&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&apos;/users&apos;, &#123;</span><br><span class=\"line\">  method: &apos;POST&apos;,</span><br><span class=\"line\">  body: new FormData(form)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>Post JSON：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&apos;/users&apos;, &#123;</span><br><span class=\"line\">  method: &apos;POST&apos;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class=\"line\">    &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: JSON.stringify(&#123;</span><br><span class=\"line\">    name: &apos;Hubot&apos;,</span><br><span class=\"line\">    login: &apos;hubot&apos;,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>上传文件：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var input = document.querySelector(&apos;input[type=&quot;file&quot;]&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var data = new FormData()</span><br><span class=\"line\">data.append(&apos;file&apos;, input.files[0])</span><br><span class=\"line\">data.append(&apos;user&apos;, &apos;hubot&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&apos;/avatars&apos;, &#123;</span><br><span class=\"line\">  method: &apos;POST&apos;,</span><br><span class=\"line\">  body: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用注意：\"><a href=\"#使用注意：\" class=\"headerlink\" title=\"使用注意：\"></a>使用注意：</h2><ul>\n<li>Fetch 请求默认是不带 cookie 的，需要设置 <code>fetch(url, {credentials: &#39;include&#39;})</code></li>\n<li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。<br>","more":"</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>npm ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install whatwg-fetch --save</span><br></pre></td></tr></table></figure></p>\n<p>如果你项目在node.js环境运行，可以使用 <a href=\"https://github.com/bitinn/node-fetch\" target=\"_blank\" rel=\"noopener\">node-fetch</a>.</p>\n<p>对于 babel 和 es2015+，可以这样导入 fetch：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;whatwg-fetch&apos;;</span><br><span class=\"line\">fetch(...);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"兼容性及解决方案\"><a href=\"#兼容性及解决方案\" class=\"headerlink\" title=\"兼容性及解决方案\"></a>兼容性及解决方案</h2><p>原生支持率并不高，幸运的是，引入下面这些 <code>polyfill</code> 后可以完美支持 IE8+ ：</p>\n<ul>\n<li>由于 IE8 是 ES3，需要引入 ES5 的 <code>polyfill</code>: <code>es5-shim</code>, <code>es5-sham</code>；</li>\n<li>引入 Promise 的 <code>polyfill</code>: <code>es6-promise</code>；</li>\n<li>引入 fetch 探测库：fetch-detector；</li>\n<li>引入 fetch 的 polyfill: fetch-ie8；</li>\n<li>可选：如果你还使用了 jsonp，引入 fetch-jsonp；</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>fetch 支持 HTTP 方法，下面主要用例子讲解 POST 和 GET 的请求。<br><strong>HTML 请求：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&apos;/users.html&apos;)</span><br><span class=\"line\">  .then(function(response) &#123;</span><br><span class=\"line\">    return response.text()</span><br><span class=\"line\">  &#125;).then(function(body) &#123;</span><br><span class=\"line\">    document.body.innerHTML = body</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>JSON 请求：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&apos;/users.json&apos;)</span><br><span class=\"line\">  .then(function(response) &#123;</span><br><span class=\"line\">    return response.json()</span><br><span class=\"line\">  &#125;).then(function(json) &#123;</span><br><span class=\"line\">    console.log(&apos;parsed json&apos;, json)</span><br><span class=\"line\">  &#125;).catch(function(ex) &#123;</span><br><span class=\"line\">    console.log(&apos;parsing failed&apos;, ex)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>响应头设置：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&apos;/users.json&apos;).then(function(response) &#123;</span><br><span class=\"line\">  console.log(response.headers.get(&apos;Content-Type&apos;))</span><br><span class=\"line\">  console.log(response.headers.get(&apos;Date&apos;))</span><br><span class=\"line\">  console.log(response.status)</span><br><span class=\"line\">  console.log(response.statusText)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>Post 表单提交：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var form = document.querySelector(&apos;form&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&apos;/users&apos;, &#123;</span><br><span class=\"line\">  method: &apos;POST&apos;,</span><br><span class=\"line\">  body: new FormData(form)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>Post JSON：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&apos;/users&apos;, &#123;</span><br><span class=\"line\">  method: &apos;POST&apos;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class=\"line\">    &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: JSON.stringify(&#123;</span><br><span class=\"line\">    name: &apos;Hubot&apos;,</span><br><span class=\"line\">    login: &apos;hubot&apos;,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>上传文件：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var input = document.querySelector(&apos;input[type=&quot;file&quot;]&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var data = new FormData()</span><br><span class=\"line\">data.append(&apos;file&apos;, input.files[0])</span><br><span class=\"line\">data.append(&apos;user&apos;, &apos;hubot&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&apos;/avatars&apos;, &#123;</span><br><span class=\"line\">  method: &apos;POST&apos;,</span><br><span class=\"line\">  body: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用注意：\"><a href=\"#使用注意：\" class=\"headerlink\" title=\"使用注意：\"></a>使用注意：</h2><ul>\n<li>Fetch 请求默认是不带 cookie 的，需要设置 <code>fetch(url, {credentials: &#39;include&#39;})</code></li>\n<li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>\n</ul>"},{"title":"在win7上安装MongoDB","abbrlink":41631,"date":"2016-11-05T09:14:45.000Z","_content":"最近用了一星期linux，感觉需要学习一门后端语言和一个数据库。暂时选定nodejs和MongoDB。\n<!--more-->\n## 下载安装\n官网下载地址：https://www.mongodb.com/download-center#community\n老是提示下载不了，附百度云盘下载：http://pan.baidu.com/s/1c2KFwGC 密码:7vu0\n安装过程中我选择`D:\\MongoDB`安装目录，傻瓜式安装完成。\n\n**打开管理员命令提示**\n需要通过管理员模式的命令提示符，来执行安装命令。\n管理员打开cmd输入以下命令：\n在MongoDB文件下创建`data\\db`：\n```\nmkdir D:\\MongoDB\\data\\db\n```\nMongoDB需要数据目录来存储所有的数据，其默认的数据目录为`\\data\\db` ，可以通过mongod.exe --dbpath命令来指定MongoDB的数据目录。例如：\n```\nD:\\MongoDB\\Server\\3.2\\bin\\mongod.exe --dbpath D:\\MongoDB\\data\\db\n```\n看到上面的提示底部出现waiting for connections 字样，则表示dbpath配置完成，且MongoDB启动成功。\n而且此时打开资源管理器，进入MongoDB的dbpath目录，可以看见本地确实初始化数据库了。\n\n## 运行MongoDB\n通过运行mongo.exe启动MongoDB。例如：\n```\nD:\\MongoDB\\Server\\3.2\\bin\\mongo.exe\n```\n命令行窗口显示如下内容：\n```\n2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files\nMongoDB shell version: 3.2.10\ncommecting to: test\n```\n窗口中可以看到当前MongoDB shell的版本，及此时连接的数据库。\n\n## 设置全局path变量\n在计算机右键 ==> 属性 ==> 高级系统设置 ==> 环境变量 ==> 选择Path编辑 ==>\n在最后面加`;`然后添加你安装的路径:`D:\\MongoDB\\Server\\3.2\\bin\\mongo.exe`\n确定保存。\n然后在cmd上输入：\n```\nmongo\n```\n此时会出现：\n```\n2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files\nMongoDB shell version: 3.2.10\nconnecting to: test\n```\n恭喜你，说明安装完成！\n","source":"_posts/MongoDB-install-for-windows.md","raw":"---\ntitle: 在win7上安装MongoDB\ntags: mongodb\nabbrlink: 41631\ndate: 2016-11-05 17:14:45\ncategories:\n---\n最近用了一星期linux，感觉需要学习一门后端语言和一个数据库。暂时选定nodejs和MongoDB。\n<!--more-->\n## 下载安装\n官网下载地址：https://www.mongodb.com/download-center#community\n老是提示下载不了，附百度云盘下载：http://pan.baidu.com/s/1c2KFwGC 密码:7vu0\n安装过程中我选择`D:\\MongoDB`安装目录，傻瓜式安装完成。\n\n**打开管理员命令提示**\n需要通过管理员模式的命令提示符，来执行安装命令。\n管理员打开cmd输入以下命令：\n在MongoDB文件下创建`data\\db`：\n```\nmkdir D:\\MongoDB\\data\\db\n```\nMongoDB需要数据目录来存储所有的数据，其默认的数据目录为`\\data\\db` ，可以通过mongod.exe --dbpath命令来指定MongoDB的数据目录。例如：\n```\nD:\\MongoDB\\Server\\3.2\\bin\\mongod.exe --dbpath D:\\MongoDB\\data\\db\n```\n看到上面的提示底部出现waiting for connections 字样，则表示dbpath配置完成，且MongoDB启动成功。\n而且此时打开资源管理器，进入MongoDB的dbpath目录，可以看见本地确实初始化数据库了。\n\n## 运行MongoDB\n通过运行mongo.exe启动MongoDB。例如：\n```\nD:\\MongoDB\\Server\\3.2\\bin\\mongo.exe\n```\n命令行窗口显示如下内容：\n```\n2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files\nMongoDB shell version: 3.2.10\ncommecting to: test\n```\n窗口中可以看到当前MongoDB shell的版本，及此时连接的数据库。\n\n## 设置全局path变量\n在计算机右键 ==> 属性 ==> 高级系统设置 ==> 环境变量 ==> 选择Path编辑 ==>\n在最后面加`;`然后添加你安装的路径:`D:\\MongoDB\\Server\\3.2\\bin\\mongo.exe`\n确定保存。\n然后在cmd上输入：\n```\nmongo\n```\n此时会出现：\n```\n2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files\nMongoDB shell version: 3.2.10\nconnecting to: test\n```\n恭喜你，说明安装完成！\n","slug":"MongoDB-install-for-windows","published":1,"updated":"2019-08-15T15:03:33.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjh0007xknw6vlhmxhe","content":"<p>最近用了一星期linux，感觉需要学习一门后端语言和一个数据库。暂时选定nodejs和MongoDB。<br><a id=\"more\"></a></p>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>官网下载地址：<a href=\"https://www.mongodb.com/download-center#community\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/download-center#community</a><br>老是提示下载不了，附百度云盘下载：<a href=\"http://pan.baidu.com/s/1c2KFwGC\" target=\"_blank\" rel=\"noopener\">http://pan.baidu.com/s/1c2KFwGC</a> 密码:7vu0<br>安装过程中我选择<code>D:\\MongoDB</code>安装目录，傻瓜式安装完成。</p>\n<p><strong>打开管理员命令提示</strong><br>需要通过管理员模式的命令提示符，来执行安装命令。<br>管理员打开cmd输入以下命令：<br>在MongoDB文件下创建<code>data\\db</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure></p>\n<p>MongoDB需要数据目录来存储所有的数据，其默认的数据目录为<code>\\data\\db</code> ，可以通过mongod.exe –dbpath命令来指定MongoDB的数据目录。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\MongoDB\\Server\\3.2\\bin\\mongod.exe --dbpath D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure></p>\n<p>看到上面的提示底部出现waiting for connections 字样，则表示dbpath配置完成，且MongoDB启动成功。<br>而且此时打开资源管理器，进入MongoDB的dbpath目录，可以看见本地确实初始化数据库了。</p>\n<h2 id=\"运行MongoDB\"><a href=\"#运行MongoDB\" class=\"headerlink\" title=\"运行MongoDB\"></a>运行MongoDB</h2><p>通过运行mongo.exe启动MongoDB。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\MongoDB\\Server\\3.2\\bin\\mongo.exe</span><br></pre></td></tr></table></figure></p>\n<p>命令行窗口显示如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files</span><br><span class=\"line\">MongoDB shell version: 3.2.10</span><br><span class=\"line\">commecting to: test</span><br></pre></td></tr></table></figure></p>\n<p>窗口中可以看到当前MongoDB shell的版本，及此时连接的数据库。</p>\n<h2 id=\"设置全局path变量\"><a href=\"#设置全局path变量\" class=\"headerlink\" title=\"设置全局path变量\"></a>设置全局path变量</h2><p>在计算机右键 ==&gt; 属性 ==&gt; 高级系统设置 ==&gt; 环境变量 ==&gt; 选择Path编辑 ==&gt;<br>在最后面加<code>;</code>然后添加你安装的路径:<code>D:\\MongoDB\\Server\\3.2\\bin\\mongo.exe</code><br>确定保存。<br>然后在cmd上输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo</span><br></pre></td></tr></table></figure></p>\n<p>此时会出现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files</span><br><span class=\"line\">MongoDB shell version: 3.2.10</span><br><span class=\"line\">connecting to: test</span><br></pre></td></tr></table></figure></p>\n<p>恭喜你，说明安装完成！</p>\n","site":{"data":{}},"excerpt":"<p>最近用了一星期linux，感觉需要学习一门后端语言和一个数据库。暂时选定nodejs和MongoDB。<br>","more":"</p>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>官网下载地址：<a href=\"https://www.mongodb.com/download-center#community\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/download-center#community</a><br>老是提示下载不了，附百度云盘下载：<a href=\"http://pan.baidu.com/s/1c2KFwGC\" target=\"_blank\" rel=\"noopener\">http://pan.baidu.com/s/1c2KFwGC</a> 密码:7vu0<br>安装过程中我选择<code>D:\\MongoDB</code>安装目录，傻瓜式安装完成。</p>\n<p><strong>打开管理员命令提示</strong><br>需要通过管理员模式的命令提示符，来执行安装命令。<br>管理员打开cmd输入以下命令：<br>在MongoDB文件下创建<code>data\\db</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure></p>\n<p>MongoDB需要数据目录来存储所有的数据，其默认的数据目录为<code>\\data\\db</code> ，可以通过mongod.exe –dbpath命令来指定MongoDB的数据目录。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\MongoDB\\Server\\3.2\\bin\\mongod.exe --dbpath D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure></p>\n<p>看到上面的提示底部出现waiting for connections 字样，则表示dbpath配置完成，且MongoDB启动成功。<br>而且此时打开资源管理器，进入MongoDB的dbpath目录，可以看见本地确实初始化数据库了。</p>\n<h2 id=\"运行MongoDB\"><a href=\"#运行MongoDB\" class=\"headerlink\" title=\"运行MongoDB\"></a>运行MongoDB</h2><p>通过运行mongo.exe启动MongoDB。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\MongoDB\\Server\\3.2\\bin\\mongo.exe</span><br></pre></td></tr></table></figure></p>\n<p>命令行窗口显示如下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files</span><br><span class=\"line\">MongoDB shell version: 3.2.10</span><br><span class=\"line\">commecting to: test</span><br></pre></td></tr></table></figure></p>\n<p>窗口中可以看到当前MongoDB shell的版本，及此时连接的数据库。</p>\n<h2 id=\"设置全局path变量\"><a href=\"#设置全局path变量\" class=\"headerlink\" title=\"设置全局path变量\"></a>设置全局path变量</h2><p>在计算机右键 ==&gt; 属性 ==&gt; 高级系统设置 ==&gt; 环境变量 ==&gt; 选择Path编辑 ==&gt;<br>在最后面加<code>;</code>然后添加你安装的路径:<code>D:\\MongoDB\\Server\\3.2\\bin\\mongo.exe</code><br>确定保存。<br>然后在cmd上输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo</span><br></pre></td></tr></table></figure></p>\n<p>此时会出现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files</span><br><span class=\"line\">MongoDB shell version: 3.2.10</span><br><span class=\"line\">connecting to: test</span><br></pre></td></tr></table></figure></p>\n<p>恭喜你，说明安装完成！</p>"},{"title":"回顾我的2016","abbrlink":23162,"date":"2016-12-31T14:38:13.000Z","_content":"\n原来今天已经是2016最后一天，是时候写一个总结了。一方面可以总结这一年的收获和不足之处进行反思，一方面为新的一年埋下信念。\n<!--more-->\n\n## 关于工作\n今年3月份，公司内部管理发生变动。我们网站部被合并到发行部，遭遇发行部老大强势管理，气氛突然紧张起来。\n平时没事做也要陪发行部的加班到九点，还有老大之前和我们几个提工资也被取消了。钱没够心里也受尽委屈，渐渐也有了离职的打算。后来被老大约谈说公司准备在我们网站部和设计部分别裁员2人，我平时太闲，所以入了名单。最后争取了一个月赔偿金，总之感觉还不错吧~\n\n**找工作**\n之后的一星期，面试了几家，还在知乎回答了一个问题呢，[Web前端岗位面试题有哪些？- 冷子欲的回答](https://www.zhihu.com/question/41466747/answer/93430578)，就这样交了几个朋友。\n面试当中也算是遇上形形色色的面试官，大概面试了7家，收到了3家offer，过程学到了不少，也了解到自己需要加强的地方，最后选择了一家离租房近点，薪资高点，规模大点的 - 恒拓开源（开源中国）。\n\n**学习还是学习**\n7月份，外包派驻到“南方航空”，离租房太远，被迫搬到白云区了。负责“新技术研究”这块，每天学习webpack、node、react、ES6/ES7 ，当然除了学习，也有活要做的：\n- 搭建了一个内部用的gulp-webpack脚手架；\n- 个人用react开发了\"额外付费行李\"项目；\n- 用sinopia在linux服务器上搭建了南航内部npm管理系统；\n- 和同事研究海外版react项目，并编写简单易懂的开发文档，并展开了技术分享会（供南航团队内部人学习）；\n\n直到现在。\n\n## 关于技术\n\n[ 2015.04 - 2016.04 ] 公司只有一个前端，活很少，所以见识和接触到的也比较少，空闲时间比较喜欢折腾新技术。并写一些小demo经过分析和测试，实战到工作当中，解决了一些痛点、提高了开发效率以及优化网站访问速度。 比如：fis3、requirejs、sass、gulp、按需加载、懒加载等等。\n[ 2016.04 - 2016.07 ] 这段时间，用阿里开源的sui开发，采用前后端分离模式...不多说了。\n[ 2016.07 - 至今 ] react全家桶、webpack从简单配置到大项目应用、ES6/ES7语法、node。\n当中也陆陆续续的用过vue，从vue1到vue2，并在 [createjs中文网](http://createjs.cc)改版中实战了一把vue2，感觉小清新，比较快上手。\n学习webpack过程中综合了一些资源和教程，收获100多start [github learn-webpack](https://github.com/lengziyu/learn-webpack)。\n2016还在继续维护 [前端导航](http://fenav.com) 呢。\n\n## 关于创业？\n\n一个好朋友在筹备做一个DIY衣服的网站，已找到一些合伙人。某天听着他说的不错，我后来也加入了。我负责前端部分工作，一起商议搭建用的框架/技术，一起探讨盈利模式。\n我做了一部分，后来由于工作忙，而且我觉得创业这事我还未准备好，我就提出退出了。\n\n\n## 其他\n- 看了不少电影，最喜欢的是《碟中谍5》、《谍影重重5》啦；\n- 书籍：《js高程》、《js设计模式》，比较少看书；\n- 对于我家喵大人，平时当女孩纸养，绝育的时候才知道是蓝孩纸（尴尬）。还有就是5月份跑出去了几天，找到的时候真的很欣慰，2017继续做好铲屎君。\n- 工作已两年半，今年才23岁。没错我没上大学，理由不说了，现在是中技学历，今年末参加了成人高考，成功在华南理工大学报考了专科，见笑了~盲羊补牢，为时不晚嘛。\n## 关于2017\n计划赶不上变化，所以我也不轻言计划了。\n想怎样就怎样吧，当然是继续努力啦。\n\n\n相信2017将会发生更多有趣的故事，更多的改变。\n朋友，2017让我们一起为美好的生活而努力吧！！共勉。\n写文水平有限。\n","source":"_posts/hello-2017.md","raw":"---\ntitle: 回顾我的2016\nabbrlink: 23162\ndate: 2016-12-31 22:38:13\ntags:\ncategories:\n---\n\n原来今天已经是2016最后一天，是时候写一个总结了。一方面可以总结这一年的收获和不足之处进行反思，一方面为新的一年埋下信念。\n<!--more-->\n\n## 关于工作\n今年3月份，公司内部管理发生变动。我们网站部被合并到发行部，遭遇发行部老大强势管理，气氛突然紧张起来。\n平时没事做也要陪发行部的加班到九点，还有老大之前和我们几个提工资也被取消了。钱没够心里也受尽委屈，渐渐也有了离职的打算。后来被老大约谈说公司准备在我们网站部和设计部分别裁员2人，我平时太闲，所以入了名单。最后争取了一个月赔偿金，总之感觉还不错吧~\n\n**找工作**\n之后的一星期，面试了几家，还在知乎回答了一个问题呢，[Web前端岗位面试题有哪些？- 冷子欲的回答](https://www.zhihu.com/question/41466747/answer/93430578)，就这样交了几个朋友。\n面试当中也算是遇上形形色色的面试官，大概面试了7家，收到了3家offer，过程学到了不少，也了解到自己需要加强的地方，最后选择了一家离租房近点，薪资高点，规模大点的 - 恒拓开源（开源中国）。\n\n**学习还是学习**\n7月份，外包派驻到“南方航空”，离租房太远，被迫搬到白云区了。负责“新技术研究”这块，每天学习webpack、node、react、ES6/ES7 ，当然除了学习，也有活要做的：\n- 搭建了一个内部用的gulp-webpack脚手架；\n- 个人用react开发了\"额外付费行李\"项目；\n- 用sinopia在linux服务器上搭建了南航内部npm管理系统；\n- 和同事研究海外版react项目，并编写简单易懂的开发文档，并展开了技术分享会（供南航团队内部人学习）；\n\n直到现在。\n\n## 关于技术\n\n[ 2015.04 - 2016.04 ] 公司只有一个前端，活很少，所以见识和接触到的也比较少，空闲时间比较喜欢折腾新技术。并写一些小demo经过分析和测试，实战到工作当中，解决了一些痛点、提高了开发效率以及优化网站访问速度。 比如：fis3、requirejs、sass、gulp、按需加载、懒加载等等。\n[ 2016.04 - 2016.07 ] 这段时间，用阿里开源的sui开发，采用前后端分离模式...不多说了。\n[ 2016.07 - 至今 ] react全家桶、webpack从简单配置到大项目应用、ES6/ES7语法、node。\n当中也陆陆续续的用过vue，从vue1到vue2，并在 [createjs中文网](http://createjs.cc)改版中实战了一把vue2，感觉小清新，比较快上手。\n学习webpack过程中综合了一些资源和教程，收获100多start [github learn-webpack](https://github.com/lengziyu/learn-webpack)。\n2016还在继续维护 [前端导航](http://fenav.com) 呢。\n\n## 关于创业？\n\n一个好朋友在筹备做一个DIY衣服的网站，已找到一些合伙人。某天听着他说的不错，我后来也加入了。我负责前端部分工作，一起商议搭建用的框架/技术，一起探讨盈利模式。\n我做了一部分，后来由于工作忙，而且我觉得创业这事我还未准备好，我就提出退出了。\n\n\n## 其他\n- 看了不少电影，最喜欢的是《碟中谍5》、《谍影重重5》啦；\n- 书籍：《js高程》、《js设计模式》，比较少看书；\n- 对于我家喵大人，平时当女孩纸养，绝育的时候才知道是蓝孩纸（尴尬）。还有就是5月份跑出去了几天，找到的时候真的很欣慰，2017继续做好铲屎君。\n- 工作已两年半，今年才23岁。没错我没上大学，理由不说了，现在是中技学历，今年末参加了成人高考，成功在华南理工大学报考了专科，见笑了~盲羊补牢，为时不晚嘛。\n## 关于2017\n计划赶不上变化，所以我也不轻言计划了。\n想怎样就怎样吧，当然是继续努力啦。\n\n\n相信2017将会发生更多有趣的故事，更多的改变。\n朋友，2017让我们一起为美好的生活而努力吧！！共勉。\n写文水平有限。\n","slug":"hello-2017","published":1,"updated":"2019-08-15T15:03:33.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjj000bxknwrnpa44ry","content":"<p>原来今天已经是2016最后一天，是时候写一个总结了。一方面可以总结这一年的收获和不足之处进行反思，一方面为新的一年埋下信念。<br><a id=\"more\"></a></p>\n<h2 id=\"关于工作\"><a href=\"#关于工作\" class=\"headerlink\" title=\"关于工作\"></a>关于工作</h2><p>今年3月份，公司内部管理发生变动。我们网站部被合并到发行部，遭遇发行部老大强势管理，气氛突然紧张起来。<br>平时没事做也要陪发行部的加班到九点，还有老大之前和我们几个提工资也被取消了。钱没够心里也受尽委屈，渐渐也有了离职的打算。后来被老大约谈说公司准备在我们网站部和设计部分别裁员2人，我平时太闲，所以入了名单。最后争取了一个月赔偿金，总之感觉还不错吧~</p>\n<p><strong>找工作</strong><br>之后的一星期，面试了几家，还在知乎回答了一个问题呢，<a href=\"https://www.zhihu.com/question/41466747/answer/93430578\" target=\"_blank\" rel=\"noopener\">Web前端岗位面试题有哪些？- 冷子欲的回答</a>，就这样交了几个朋友。<br>面试当中也算是遇上形形色色的面试官，大概面试了7家，收到了3家offer，过程学到了不少，也了解到自己需要加强的地方，最后选择了一家离租房近点，薪资高点，规模大点的 - 恒拓开源（开源中国）。</p>\n<p><strong>学习还是学习</strong><br>7月份，外包派驻到“南方航空”，离租房太远，被迫搬到白云区了。负责“新技术研究”这块，每天学习webpack、node、react、ES6/ES7 ，当然除了学习，也有活要做的：</p>\n<ul>\n<li>搭建了一个内部用的gulp-webpack脚手架；</li>\n<li>个人用react开发了”额外付费行李”项目；</li>\n<li>用sinopia在linux服务器上搭建了南航内部npm管理系统；</li>\n<li>和同事研究海外版react项目，并编写简单易懂的开发文档，并展开了技术分享会（供南航团队内部人学习）；</li>\n</ul>\n<p>直到现在。</p>\n<h2 id=\"关于技术\"><a href=\"#关于技术\" class=\"headerlink\" title=\"关于技术\"></a>关于技术</h2><p>[ 2015.04 - 2016.04 ] 公司只有一个前端，活很少，所以见识和接触到的也比较少，空闲时间比较喜欢折腾新技术。并写一些小demo经过分析和测试，实战到工作当中，解决了一些痛点、提高了开发效率以及优化网站访问速度。 比如：fis3、requirejs、sass、gulp、按需加载、懒加载等等。<br>[ 2016.04 - 2016.07 ] 这段时间，用阿里开源的sui开发，采用前后端分离模式…不多说了。<br>[ 2016.07 - 至今 ] react全家桶、webpack从简单配置到大项目应用、ES6/ES7语法、node。<br>当中也陆陆续续的用过vue，从vue1到vue2，并在 <a href=\"http://createjs.cc\" target=\"_blank\" rel=\"noopener\">createjs中文网</a>改版中实战了一把vue2，感觉小清新，比较快上手。<br>学习webpack过程中综合了一些资源和教程，收获100多start <a href=\"https://github.com/lengziyu/learn-webpack\" target=\"_blank\" rel=\"noopener\">github learn-webpack</a>。<br>2016还在继续维护 <a href=\"http://fenav.com\" target=\"_blank\" rel=\"noopener\">前端导航</a> 呢。</p>\n<h2 id=\"关于创业？\"><a href=\"#关于创业？\" class=\"headerlink\" title=\"关于创业？\"></a>关于创业？</h2><p>一个好朋友在筹备做一个DIY衣服的网站，已找到一些合伙人。某天听着他说的不错，我后来也加入了。我负责前端部分工作，一起商议搭建用的框架/技术，一起探讨盈利模式。<br>我做了一部分，后来由于工作忙，而且我觉得创业这事我还未准备好，我就提出退出了。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>看了不少电影，最喜欢的是《碟中谍5》、《谍影重重5》啦；</li>\n<li>书籍：《js高程》、《js设计模式》，比较少看书；</li>\n<li>对于我家喵大人，平时当女孩纸养，绝育的时候才知道是蓝孩纸（尴尬）。还有就是5月份跑出去了几天，找到的时候真的很欣慰，2017继续做好铲屎君。</li>\n<li>工作已两年半，今年才23岁。没错我没上大学，理由不说了，现在是中技学历，今年末参加了成人高考，成功在华南理工大学报考了专科，见笑了~盲羊补牢，为时不晚嘛。<h2 id=\"关于2017\"><a href=\"#关于2017\" class=\"headerlink\" title=\"关于2017\"></a>关于2017</h2>计划赶不上变化，所以我也不轻言计划了。<br>想怎样就怎样吧，当然是继续努力啦。</li>\n</ul>\n<p>相信2017将会发生更多有趣的故事，更多的改变。<br>朋友，2017让我们一起为美好的生活而努力吧！！共勉。<br>写文水平有限。</p>\n","site":{"data":{}},"excerpt":"<p>原来今天已经是2016最后一天，是时候写一个总结了。一方面可以总结这一年的收获和不足之处进行反思，一方面为新的一年埋下信念。<br>","more":"</p>\n<h2 id=\"关于工作\"><a href=\"#关于工作\" class=\"headerlink\" title=\"关于工作\"></a>关于工作</h2><p>今年3月份，公司内部管理发生变动。我们网站部被合并到发行部，遭遇发行部老大强势管理，气氛突然紧张起来。<br>平时没事做也要陪发行部的加班到九点，还有老大之前和我们几个提工资也被取消了。钱没够心里也受尽委屈，渐渐也有了离职的打算。后来被老大约谈说公司准备在我们网站部和设计部分别裁员2人，我平时太闲，所以入了名单。最后争取了一个月赔偿金，总之感觉还不错吧~</p>\n<p><strong>找工作</strong><br>之后的一星期，面试了几家，还在知乎回答了一个问题呢，<a href=\"https://www.zhihu.com/question/41466747/answer/93430578\" target=\"_blank\" rel=\"noopener\">Web前端岗位面试题有哪些？- 冷子欲的回答</a>，就这样交了几个朋友。<br>面试当中也算是遇上形形色色的面试官，大概面试了7家，收到了3家offer，过程学到了不少，也了解到自己需要加强的地方，最后选择了一家离租房近点，薪资高点，规模大点的 - 恒拓开源（开源中国）。</p>\n<p><strong>学习还是学习</strong><br>7月份，外包派驻到“南方航空”，离租房太远，被迫搬到白云区了。负责“新技术研究”这块，每天学习webpack、node、react、ES6/ES7 ，当然除了学习，也有活要做的：</p>\n<ul>\n<li>搭建了一个内部用的gulp-webpack脚手架；</li>\n<li>个人用react开发了”额外付费行李”项目；</li>\n<li>用sinopia在linux服务器上搭建了南航内部npm管理系统；</li>\n<li>和同事研究海外版react项目，并编写简单易懂的开发文档，并展开了技术分享会（供南航团队内部人学习）；</li>\n</ul>\n<p>直到现在。</p>\n<h2 id=\"关于技术\"><a href=\"#关于技术\" class=\"headerlink\" title=\"关于技术\"></a>关于技术</h2><p>[ 2015.04 - 2016.04 ] 公司只有一个前端，活很少，所以见识和接触到的也比较少，空闲时间比较喜欢折腾新技术。并写一些小demo经过分析和测试，实战到工作当中，解决了一些痛点、提高了开发效率以及优化网站访问速度。 比如：fis3、requirejs、sass、gulp、按需加载、懒加载等等。<br>[ 2016.04 - 2016.07 ] 这段时间，用阿里开源的sui开发，采用前后端分离模式…不多说了。<br>[ 2016.07 - 至今 ] react全家桶、webpack从简单配置到大项目应用、ES6/ES7语法、node。<br>当中也陆陆续续的用过vue，从vue1到vue2，并在 <a href=\"http://createjs.cc\" target=\"_blank\" rel=\"noopener\">createjs中文网</a>改版中实战了一把vue2，感觉小清新，比较快上手。<br>学习webpack过程中综合了一些资源和教程，收获100多start <a href=\"https://github.com/lengziyu/learn-webpack\" target=\"_blank\" rel=\"noopener\">github learn-webpack</a>。<br>2016还在继续维护 <a href=\"http://fenav.com\" target=\"_blank\" rel=\"noopener\">前端导航</a> 呢。</p>\n<h2 id=\"关于创业？\"><a href=\"#关于创业？\" class=\"headerlink\" title=\"关于创业？\"></a>关于创业？</h2><p>一个好朋友在筹备做一个DIY衣服的网站，已找到一些合伙人。某天听着他说的不错，我后来也加入了。我负责前端部分工作，一起商议搭建用的框架/技术，一起探讨盈利模式。<br>我做了一部分，后来由于工作忙，而且我觉得创业这事我还未准备好，我就提出退出了。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>看了不少电影，最喜欢的是《碟中谍5》、《谍影重重5》啦；</li>\n<li>书籍：《js高程》、《js设计模式》，比较少看书；</li>\n<li>对于我家喵大人，平时当女孩纸养，绝育的时候才知道是蓝孩纸（尴尬）。还有就是5月份跑出去了几天，找到的时候真的很欣慰，2017继续做好铲屎君。</li>\n<li>工作已两年半，今年才23岁。没错我没上大学，理由不说了，现在是中技学历，今年末参加了成人高考，成功在华南理工大学报考了专科，见笑了~盲羊补牢，为时不晚嘛。<h2 id=\"关于2017\"><a href=\"#关于2017\" class=\"headerlink\" title=\"关于2017\"></a>关于2017</h2>计划赶不上变化，所以我也不轻言计划了。<br>想怎样就怎样吧，当然是继续努力啦。</li>\n</ul>\n<p>相信2017将会发生更多有趣的故事，更多的改变。<br>朋友，2017让我们一起为美好的生活而努力吧！！共勉。<br>写文水平有限。</p>"},{"title":"ES6 function* yield yield*","abbrlink":63793,"date":"2016-12-08T14:03:09.000Z","_content":"这里主要讲解es6新语法`function*`、`yield`和`yield*`。\n<!--more-->\n# function*\n### 简介\n定义一个generator（生成器）函数，返回一个Generator对象。\n\n### 语法\n```\nfunction* name[ param[ param[ param…]]] { statements }\n```\n- name 函数名\n- param 传入函数的参数名，一个函数最多可有255个参数\n- statements 函数的主体\n\n### 描述\n生成器是一种可以在从中退出并在之后重新进入的函数。生成器环境在执行后会被保存，下次执行可继续使用。\n\n调用生成器函数，并不立即执行主体，而是返回这个生成器函数的迭代器对象，当这个迭代器调用next()方法时，生成器函数主体会被执行至第一个 yield 表达式，该表达式定义了迭代器返回的值，或者，被 yield* 委托至另一个生成器函数。next() 方法返回一个对象，该对象有一个value属性，表示产出的值，和一个done属性，表示生成器是否已经产出了它最后的值。\n\n### 基本事例\n```\nfunction* idMaker(){\n  var index = 0;\n  while(index<3)\n    yield index++;\n}\n\nvar gen = idMaker();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // undefined\n```\n\n### yield* 事例\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\n\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\n\nvar gen = generator(10);\n\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n### 兼容性\n属于ES6规范，请使用babel转换\n\n\n# yield\n### 简介\nyield关键词用来停止或继续一个生成器函数。\n\n### 语法\n```\nyield[[ expression ]]\n```\n- expression 用作返回值，如果忽略，则返回undefined\n\n### 描述\nyield 关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值. 可以把它想成是 return 关键字的一个基于生成器的版本.\nyield 关键字实际返回一个对象，包含两个属性, value 和 done.  value 属性为 yield expression 的值,  done 是一个布尔值用来指示生成器函数是否已经全部完成.\n一旦在 yield expression 处暂停,  除非外部调用生成器的 next() 方法，否则生成器的代码将不能继续执行. 这使得可以对生成器的执行以及渐进式的返回值进行直接控制.\n\n### 事例\n```\nfunction* foo(){\n  var index = 0;\n  while (index <= 2) // when index reaches 3,\n                     // yield's done will be true\n                     // and its value will be undefined;\n    yield index++;\n}\n一旦生成器函数已定义，可以通过构造一个迭代器来使用它.\nvar iterator = foo();\nconsole.log(iterator.next()); // { value:0, done:false }\nconsole.log(iterator.next()); // { value:1, done:false }\nconsole.log(iterator.next()); // { value:2, done:false }\nconsole.log(iterator.next()); // { value:undefined, done:true }\n```\n\n# yield*\n### 简介\n在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。\n\n### 语法\nyield*[[ expression ]]\n- expression 任意可迭代的对象\n\n### 描述\nyield* 一个可迭代对象，就相当于把这个可迭代对象的所有迭代值分次 yield 出去。\nyield* 表达式本身的值就是当前可迭代对象迭代完毕（当done为true时）时的返回值。\n\n\n### 事例\n**委托给其他生成器**\n以下代码中，g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回，就像那些 yield 语句是写在 g2() 里一样。\n```\nfunction* g1() {\n  yield 2;\n  yield 3;\n  yield 4;\n}\n\nfunction* g2() {\n  yield 1;\n  yield* g1();\n  yield 5;\n}\n\nvar iterator = g2();\n\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: 4, done: false }\nconsole.log(iterator.next()); // { value: 5, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n**委托给其他类型的可迭代对象**\n除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。\n```\nfunction* g3() {\n  yield* [1, 2];\n  yield* \"34\";\n  yield* arguments;\n}\n\nvar iterator = g3(5, 6);\n\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: \"3\", done: false }\nconsole.log(iterator.next()); // { value: \"4\", done: false }\nconsole.log(iterator.next()); // { value: 5, done: false }\nconsole.log(iterator.next()); // { value: 6, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n### yield* 表达式的值\nyield* 是一个表达式，不是语句，所以它会有自己的值。\n```\nfunction* g4() {\n  yield* [1, 2, 3];\n  return \"foo\";\n}\n\nvar result;\n\nfunction* g5() {\n  result = yield* g4();\n}\n\nvar iterator = g5();\n\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true },\n                              // 此时 g4() 返回了 { value: \"foo\", done: true }\n\nconsole.log(result);          // \"foo\"\n```\n","source":"_posts/es6-new-grammar.md","raw":"---\ntitle: ES6 function* yield yield*\ntags: es6\ncategories: es6\nabbrlink: 63793\ndate: 2016-12-08 22:03:09\n---\n这里主要讲解es6新语法`function*`、`yield`和`yield*`。\n<!--more-->\n# function*\n### 简介\n定义一个generator（生成器）函数，返回一个Generator对象。\n\n### 语法\n```\nfunction* name[ param[ param[ param…]]] { statements }\n```\n- name 函数名\n- param 传入函数的参数名，一个函数最多可有255个参数\n- statements 函数的主体\n\n### 描述\n生成器是一种可以在从中退出并在之后重新进入的函数。生成器环境在执行后会被保存，下次执行可继续使用。\n\n调用生成器函数，并不立即执行主体，而是返回这个生成器函数的迭代器对象，当这个迭代器调用next()方法时，生成器函数主体会被执行至第一个 yield 表达式，该表达式定义了迭代器返回的值，或者，被 yield* 委托至另一个生成器函数。next() 方法返回一个对象，该对象有一个value属性，表示产出的值，和一个done属性，表示生成器是否已经产出了它最后的值。\n\n### 基本事例\n```\nfunction* idMaker(){\n  var index = 0;\n  while(index<3)\n    yield index++;\n}\n\nvar gen = idMaker();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // undefined\n```\n\n### yield* 事例\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\n\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\n\nvar gen = generator(10);\n\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n### 兼容性\n属于ES6规范，请使用babel转换\n\n\n# yield\n### 简介\nyield关键词用来停止或继续一个生成器函数。\n\n### 语法\n```\nyield[[ expression ]]\n```\n- expression 用作返回值，如果忽略，则返回undefined\n\n### 描述\nyield 关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值. 可以把它想成是 return 关键字的一个基于生成器的版本.\nyield 关键字实际返回一个对象，包含两个属性, value 和 done.  value 属性为 yield expression 的值,  done 是一个布尔值用来指示生成器函数是否已经全部完成.\n一旦在 yield expression 处暂停,  除非外部调用生成器的 next() 方法，否则生成器的代码将不能继续执行. 这使得可以对生成器的执行以及渐进式的返回值进行直接控制.\n\n### 事例\n```\nfunction* foo(){\n  var index = 0;\n  while (index <= 2) // when index reaches 3,\n                     // yield's done will be true\n                     // and its value will be undefined;\n    yield index++;\n}\n一旦生成器函数已定义，可以通过构造一个迭代器来使用它.\nvar iterator = foo();\nconsole.log(iterator.next()); // { value:0, done:false }\nconsole.log(iterator.next()); // { value:1, done:false }\nconsole.log(iterator.next()); // { value:2, done:false }\nconsole.log(iterator.next()); // { value:undefined, done:true }\n```\n\n# yield*\n### 简介\n在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。\n\n### 语法\nyield*[[ expression ]]\n- expression 任意可迭代的对象\n\n### 描述\nyield* 一个可迭代对象，就相当于把这个可迭代对象的所有迭代值分次 yield 出去。\nyield* 表达式本身的值就是当前可迭代对象迭代完毕（当done为true时）时的返回值。\n\n\n### 事例\n**委托给其他生成器**\n以下代码中，g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回，就像那些 yield 语句是写在 g2() 里一样。\n```\nfunction* g1() {\n  yield 2;\n  yield 3;\n  yield 4;\n}\n\nfunction* g2() {\n  yield 1;\n  yield* g1();\n  yield 5;\n}\n\nvar iterator = g2();\n\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: 4, done: false }\nconsole.log(iterator.next()); // { value: 5, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n**委托给其他类型的可迭代对象**\n除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。\n```\nfunction* g3() {\n  yield* [1, 2];\n  yield* \"34\";\n  yield* arguments;\n}\n\nvar iterator = g3(5, 6);\n\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: \"3\", done: false }\nconsole.log(iterator.next()); // { value: \"4\", done: false }\nconsole.log(iterator.next()); // { value: 5, done: false }\nconsole.log(iterator.next()); // { value: 6, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n### yield* 表达式的值\nyield* 是一个表达式，不是语句，所以它会有自己的值。\n```\nfunction* g4() {\n  yield* [1, 2, 3];\n  return \"foo\";\n}\n\nvar result;\n\nfunction* g5() {\n  result = yield* g4();\n}\n\nvar iterator = g5();\n\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true },\n                              // 此时 g4() 返回了 { value: \"foo\", done: true }\n\nconsole.log(result);          // \"foo\"\n```\n","slug":"es6-new-grammar","published":1,"updated":"2019-08-15T15:03:33.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjl000cxknwb06orlhr","content":"<p>这里主要讲解es6新语法<code>function*</code>、<code>yield</code>和<code>yield*</code>。<br><a id=\"more\"></a></p>\n<h1 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"function*\"></a>function*</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>定义一个generator（生成器）函数，返回一个Generator对象。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* name[ param[ param[ param…]]] &#123; statements &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name 函数名</li>\n<li>param 传入函数的参数名，一个函数最多可有255个参数</li>\n<li>statements 函数的主体</li>\n</ul>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>生成器是一种可以在从中退出并在之后重新进入的函数。生成器环境在执行后会被保存，下次执行可继续使用。</p>\n<p>调用生成器函数，并不立即执行主体，而是返回这个生成器函数的迭代器对象，当这个迭代器调用next()方法时，生成器函数主体会被执行至第一个 yield 表达式，该表达式定义了迭代器返回的值，或者，被 yield* 委托至另一个生成器函数。next() 方法返回一个对象，该对象有一个value属性，表示产出的值，和一个done属性，表示生成器是否已经产出了它最后的值。</p>\n<h3 id=\"基本事例\"><a href=\"#基本事例\" class=\"headerlink\" title=\"基本事例\"></a>基本事例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* idMaker()&#123;</span><br><span class=\"line\">  var index = 0;</span><br><span class=\"line\">  while(index&lt;3)</span><br><span class=\"line\">    yield index++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var gen = idMaker();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(gen.next().value); // 0</span><br><span class=\"line\">console.log(gen.next().value); // 1</span><br><span class=\"line\">console.log(gen.next().value); // 2</span><br><span class=\"line\">console.log(gen.next().value); // undefined</span><br></pre></td></tr></table></figure>\n<h3 id=\"yield-事例\"><a href=\"#yield-事例\" class=\"headerlink\" title=\"yield* 事例\"></a>yield* 事例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* anotherGenerator(i) &#123;</span><br><span class=\"line\">  yield i + 1;</span><br><span class=\"line\">  yield i + 2;</span><br><span class=\"line\">  yield i + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function* generator(i)&#123;</span><br><span class=\"line\">  yield i;</span><br><span class=\"line\">  yield* anotherGenerator(i);</span><br><span class=\"line\">  yield i + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var gen = generator(10);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(gen.next().value); // 10</span><br><span class=\"line\">console.log(gen.next().value); // 11</span><br><span class=\"line\">console.log(gen.next().value); // 12</span><br><span class=\"line\">console.log(gen.next().value); // 13</span><br><span class=\"line\">console.log(gen.next().value); // 20</span><br></pre></td></tr></table></figure>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>属于ES6规范，请使用babel转换</p>\n<h1 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h1><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>yield关键词用来停止或继续一个生成器函数。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yield[[ expression ]]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>expression 用作返回值，如果忽略，则返回undefined</li>\n</ul>\n<h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>yield 关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值. 可以把它想成是 return 关键字的一个基于生成器的版本.<br>yield 关键字实际返回一个对象，包含两个属性, value 和 done.  value 属性为 yield expression 的值,  done 是一个布尔值用来指示生成器函数是否已经全部完成.<br>一旦在 yield expression 处暂停,  除非外部调用生成器的 next() 方法，否则生成器的代码将不能继续执行. 这使得可以对生成器的执行以及渐进式的返回值进行直接控制.</p>\n<h3 id=\"事例\"><a href=\"#事例\" class=\"headerlink\" title=\"事例\"></a>事例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo()&#123;</span><br><span class=\"line\">  var index = 0;</span><br><span class=\"line\">  while (index &lt;= 2) // when index reaches 3,</span><br><span class=\"line\">                     // yield&apos;s done will be true</span><br><span class=\"line\">                     // and its value will be undefined;</span><br><span class=\"line\">    yield index++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">一旦生成器函数已定义，可以通过构造一个迭代器来使用它.</span><br><span class=\"line\">var iterator = foo();</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value:0, done:false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value:1, done:false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value:2, done:false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value:undefined, done:true &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"yield-1\"><a href=\"#yield-1\" class=\"headerlink\" title=\"yield*\"></a>yield*</h1><h3 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。</p>\n<h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>yield*[[ expression ]]</p>\n<ul>\n<li>expression 任意可迭代的对象</li>\n</ul>\n<h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>yield<em> 一个可迭代对象，就相当于把这个可迭代对象的所有迭代值分次 yield 出去。<br>yield</em> 表达式本身的值就是当前可迭代对象迭代完毕（当done为true时）时的返回值。</p>\n<h3 id=\"事例-1\"><a href=\"#事例-1\" class=\"headerlink\" title=\"事例\"></a>事例</h3><p><strong>委托给其他生成器</strong><br>以下代码中，g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回，就像那些 yield 语句是写在 g2() 里一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* g1() &#123;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">  yield 4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function* g2() &#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield* g1();</span><br><span class=\"line\">  yield 5;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var iterator = g2();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 4, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>委托给其他类型的可迭代对象</strong><br>除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* g3() &#123;</span><br><span class=\"line\">  yield* [1, 2];</span><br><span class=\"line\">  yield* &quot;34&quot;;</span><br><span class=\"line\">  yield* arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var iterator = g3(5, 6);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: &quot;3&quot;, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: &quot;4&quot;, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 6, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"yield-表达式的值\"><a href=\"#yield-表达式的值\" class=\"headerlink\" title=\"yield* 表达式的值\"></a>yield* 表达式的值</h3><p>yield* 是一个表达式，不是语句，所以它会有自己的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* g4() &#123;</span><br><span class=\"line\">  yield* [1, 2, 3];</span><br><span class=\"line\">  return &quot;foo&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result;</span><br><span class=\"line\"></span><br><span class=\"line\">function* g5() &#123;</span><br><span class=\"line\">  result = yield* g4();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var iterator = g5();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;,</span><br><span class=\"line\">                              // 此时 g4() 返回了 &#123; value: &quot;foo&quot;, done: true &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(result);          // &quot;foo&quot;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>这里主要讲解es6新语法<code>function*</code>、<code>yield</code>和<code>yield*</code>。<br>","more":"</p>\n<h1 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"function*\"></a>function*</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>定义一个generator（生成器）函数，返回一个Generator对象。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* name[ param[ param[ param…]]] &#123; statements &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name 函数名</li>\n<li>param 传入函数的参数名，一个函数最多可有255个参数</li>\n<li>statements 函数的主体</li>\n</ul>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>生成器是一种可以在从中退出并在之后重新进入的函数。生成器环境在执行后会被保存，下次执行可继续使用。</p>\n<p>调用生成器函数，并不立即执行主体，而是返回这个生成器函数的迭代器对象，当这个迭代器调用next()方法时，生成器函数主体会被执行至第一个 yield 表达式，该表达式定义了迭代器返回的值，或者，被 yield* 委托至另一个生成器函数。next() 方法返回一个对象，该对象有一个value属性，表示产出的值，和一个done属性，表示生成器是否已经产出了它最后的值。</p>\n<h3 id=\"基本事例\"><a href=\"#基本事例\" class=\"headerlink\" title=\"基本事例\"></a>基本事例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* idMaker()&#123;</span><br><span class=\"line\">  var index = 0;</span><br><span class=\"line\">  while(index&lt;3)</span><br><span class=\"line\">    yield index++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var gen = idMaker();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(gen.next().value); // 0</span><br><span class=\"line\">console.log(gen.next().value); // 1</span><br><span class=\"line\">console.log(gen.next().value); // 2</span><br><span class=\"line\">console.log(gen.next().value); // undefined</span><br></pre></td></tr></table></figure>\n<h3 id=\"yield-事例\"><a href=\"#yield-事例\" class=\"headerlink\" title=\"yield* 事例\"></a>yield* 事例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* anotherGenerator(i) &#123;</span><br><span class=\"line\">  yield i + 1;</span><br><span class=\"line\">  yield i + 2;</span><br><span class=\"line\">  yield i + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function* generator(i)&#123;</span><br><span class=\"line\">  yield i;</span><br><span class=\"line\">  yield* anotherGenerator(i);</span><br><span class=\"line\">  yield i + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var gen = generator(10);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(gen.next().value); // 10</span><br><span class=\"line\">console.log(gen.next().value); // 11</span><br><span class=\"line\">console.log(gen.next().value); // 12</span><br><span class=\"line\">console.log(gen.next().value); // 13</span><br><span class=\"line\">console.log(gen.next().value); // 20</span><br></pre></td></tr></table></figure>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>属于ES6规范，请使用babel转换</p>\n<h1 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h1><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>yield关键词用来停止或继续一个生成器函数。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yield[[ expression ]]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>expression 用作返回值，如果忽略，则返回undefined</li>\n</ul>\n<h3 id=\"描述-1\"><a href=\"#描述-1\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>yield 关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值. 可以把它想成是 return 关键字的一个基于生成器的版本.<br>yield 关键字实际返回一个对象，包含两个属性, value 和 done.  value 属性为 yield expression 的值,  done 是一个布尔值用来指示生成器函数是否已经全部完成.<br>一旦在 yield expression 处暂停,  除非外部调用生成器的 next() 方法，否则生成器的代码将不能继续执行. 这使得可以对生成器的执行以及渐进式的返回值进行直接控制.</p>\n<h3 id=\"事例\"><a href=\"#事例\" class=\"headerlink\" title=\"事例\"></a>事例</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo()&#123;</span><br><span class=\"line\">  var index = 0;</span><br><span class=\"line\">  while (index &lt;= 2) // when index reaches 3,</span><br><span class=\"line\">                     // yield&apos;s done will be true</span><br><span class=\"line\">                     // and its value will be undefined;</span><br><span class=\"line\">    yield index++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">一旦生成器函数已定义，可以通过构造一个迭代器来使用它.</span><br><span class=\"line\">var iterator = foo();</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value:0, done:false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value:1, done:false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value:2, done:false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value:undefined, done:true &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"yield-1\"><a href=\"#yield-1\" class=\"headerlink\" title=\"yield*\"></a>yield*</h1><h3 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。</p>\n<h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>yield*[[ expression ]]</p>\n<ul>\n<li>expression 任意可迭代的对象</li>\n</ul>\n<h3 id=\"描述-2\"><a href=\"#描述-2\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>yield<em> 一个可迭代对象，就相当于把这个可迭代对象的所有迭代值分次 yield 出去。<br>yield</em> 表达式本身的值就是当前可迭代对象迭代完毕（当done为true时）时的返回值。</p>\n<h3 id=\"事例-1\"><a href=\"#事例-1\" class=\"headerlink\" title=\"事例\"></a>事例</h3><p><strong>委托给其他生成器</strong><br>以下代码中，g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回，就像那些 yield 语句是写在 g2() 里一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* g1() &#123;</span><br><span class=\"line\">  yield 2;</span><br><span class=\"line\">  yield 3;</span><br><span class=\"line\">  yield 4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function* g2() &#123;</span><br><span class=\"line\">  yield 1;</span><br><span class=\"line\">  yield* g1();</span><br><span class=\"line\">  yield 5;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var iterator = g2();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 4, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>委托给其他类型的可迭代对象</strong><br>除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* g3() &#123;</span><br><span class=\"line\">  yield* [1, 2];</span><br><span class=\"line\">  yield* &quot;34&quot;;</span><br><span class=\"line\">  yield* arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var iterator = g3(5, 6);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: &quot;3&quot;, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: &quot;4&quot;, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 6, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"yield-表达式的值\"><a href=\"#yield-表达式的值\" class=\"headerlink\" title=\"yield* 表达式的值\"></a>yield* 表达式的值</h3><p>yield* 是一个表达式，不是语句，所以它会有自己的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* g4() &#123;</span><br><span class=\"line\">  yield* [1, 2, 3];</span><br><span class=\"line\">  return &quot;foo&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result;</span><br><span class=\"line\"></span><br><span class=\"line\">function* g5() &#123;</span><br><span class=\"line\">  result = yield* g4();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var iterator = g5();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</span><br><span class=\"line\">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;,</span><br><span class=\"line\">                              // 此时 g4() 返回了 &#123; value: &quot;foo&quot;, done: true &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(result);          // &quot;foo&quot;</span><br></pre></td></tr></table></figure></p>"},{"title":"nodejs fs模块的使用","abbrlink":50444,"date":"2016-11-17T13:26:19.000Z","_content":"fs是nodejs的文件系统，使用方法均有异步和同步版本，建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。使用fs模块可以轻松地对文件/文件夹进行操作。\n<!--more-->\n## 异步和同步\n创建 test.txt 文件，内容如下：\n```\nblog.lengziyu.com\n文件读取test\n```\n创建 file.js 文件, 代码如下：\n```\nvar fs = require(\"fs\");\n\n// 异步读取\nfs.readFile('input.txt', function (err, data) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"异步读取: \" + data.toString());\n});\n\n// 同步读取\nvar data = fs.readFileSync('input.txt');\nconsole.log(\"同步读取: \" + data.toString());\n\nconsole.log(\"程序执行完毕。\");\n```\n## 打开文件\n**语法**\n```\nfs.open(path, flags[, mode], callback)\n```\n\n**参数**\n- path - 文件的路径。\n- flags - 文件打开的行为。具体值详见下文。\n- mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。\n- callback - 回调函数，带有两个参数如：callback(err, fd)。\n\n**例子**\n接下来我们创建 file.js 文件，并打开 test.txt 文件进行读写，代码如下所示：\n```\nvar fs = require(\"fs\");\n\n// 异步打开文件\nconsole.log(\"准备打开文件！\");\nfs.open('test.txt', 'r+', function(err, fd) {\n   if (err) {\n       return console.error(err);\n   }\n  console.log(\"文件打开成功！\");     \n});\n```\n## 获取文件信息\n**语法**\n```\nfs.stat(path, callback)\n```\n**参数**\n- path - 文件路径。\n- callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"准备打开文件！\");\nfs.stat('test.txt', function (err, stats) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(stats);\n   console.log(\"读取文件信息成功！\");\n\n   // 检测文件类型\n   console.log(\"是否为文件(isFile) ? \" + stats.isFile());\n   console.log(\"是否为目录(isDirectory) ? \" + stats.isDirectory());    \n});\n```\n## 写入文件\n**语法**\n```\nfs.writeFile(filename, data[, options], callback)\n```\n**参数**\n- path - 文件路径。\n- data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。\n- options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 'w'\n- callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"准备写入文件\");\nfs.writeFile('test.txt', '我是通过写入的文件内容！',  function(err) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"数据写入成功！\");\n   console.log(\"--------我是分割线-------------\")\n   console.log(\"读取写入的数据！\");\n   fs.readFile('test.txt', function (err, data) {\n      if (err) {\n         return console.error(err);\n      }\n      console.log(\"异步读取文件数据: \" + data.toString());\n   });\n});\n```\n## 读取文件\n**语法**\n```\nfs.read(fd, buffer, offset, length, position, callback)\n```\n**参数**\n- fd - 通过 fs.open() 方法返回的文件描述符。\n- buffer - 数据写入的缓冲区。\n- offset - 缓冲区写入的写入偏移量。\n- length - 要从文件中读取的字节数。\n- position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。\n- callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。\n\n**例子**\ntest.txt 文件内容为：\n```\nwww.lengziyu.com\n```\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\nvar buf = new Buffer(1024);\n\nconsole.log(\"准备打开已存在的文件！\");\nfs.open('test.txt', 'r+', function(err, fd) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"文件打开成功！\");\n   console.log(\"准备读取文件：\");\n   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){\n      if (err){\n         console.log(err);\n      }\n      console.log(bytes + \"  字节被读取\");\n\n      // 仅输出读取的字节\n      if(bytes > 0){\n         console.log(buf.slice(0, bytes).toString());\n      }\n   });\n});\n```\n## 删除文件\n**语法**\n```\nfs.unlink(path, callback)\n```\n**参数**\n- path - 文件路径。\n- callback - 回调函数，没有参数。\n\n**例子**\ntest.txt 文件内容为：\n```\nwww.lengziyu.com\n```\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"准备删除文件！\");\nfs.unlink('test.txt', function(err) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"文件删除成功！\");\n});\n```\n再去查看 test.txt 文件，发现已经不存在了。\n\n## 创建目录\n**语法**\n```\nfs.mkdir(path[, mode], callback)\n```\n**参数**\n- path - 文件路径。\n- mode - 设置目录权限，默认为 0777。\n- callback - 回调函数，没有参数。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"创建目录 /test/\");\nfs.mkdir(\"/test/\",function(err){\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"目录创建成功。\");\n});\n```\n\n## 读取目录\n**语法**\n```\nfs.readdir(path, callback)\n```\n**参数**\n- path - 文件路径。\n- callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"查看 /test 目录\");\nfs.readdir(\"/test/\",function(err, files){\n   if (err) {\n       return console.error(err);\n   }\n   files.forEach( function (file){\n       console.log( file );\n   });\n});\n```\n## 删除目录\n**语法**\n```\nfs.rmdir(path, callback)\n```\n**参数**\n- path - 文件路径。\n- callback - 回调函数，没有参数。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"准备删除目录 /tmp/test\");\nfs.rmdir(\"/tmp/test\",function(err){\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"读取 /tmp 目录\");\n   fs.readdir(\"/tmp/\",function(err, files){\n      if (err) {\n          return console.error(err);\n      }\n      files.forEach( function (file){\n          console.log( file );\n      });\n   });\n});\n```\n更多内容，请查看官网文件模块描述：[File System](https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback)。\n","source":"_posts/node-use-fs-modules.md","raw":"---\ntitle: nodejs fs模块的使用\ntags: node\ncategories: node\nabbrlink: 50444\ndate: 2016-11-17 21:26:19\n---\nfs是nodejs的文件系统，使用方法均有异步和同步版本，建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。使用fs模块可以轻松地对文件/文件夹进行操作。\n<!--more-->\n## 异步和同步\n创建 test.txt 文件，内容如下：\n```\nblog.lengziyu.com\n文件读取test\n```\n创建 file.js 文件, 代码如下：\n```\nvar fs = require(\"fs\");\n\n// 异步读取\nfs.readFile('input.txt', function (err, data) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"异步读取: \" + data.toString());\n});\n\n// 同步读取\nvar data = fs.readFileSync('input.txt');\nconsole.log(\"同步读取: \" + data.toString());\n\nconsole.log(\"程序执行完毕。\");\n```\n## 打开文件\n**语法**\n```\nfs.open(path, flags[, mode], callback)\n```\n\n**参数**\n- path - 文件的路径。\n- flags - 文件打开的行为。具体值详见下文。\n- mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。\n- callback - 回调函数，带有两个参数如：callback(err, fd)。\n\n**例子**\n接下来我们创建 file.js 文件，并打开 test.txt 文件进行读写，代码如下所示：\n```\nvar fs = require(\"fs\");\n\n// 异步打开文件\nconsole.log(\"准备打开文件！\");\nfs.open('test.txt', 'r+', function(err, fd) {\n   if (err) {\n       return console.error(err);\n   }\n  console.log(\"文件打开成功！\");     \n});\n```\n## 获取文件信息\n**语法**\n```\nfs.stat(path, callback)\n```\n**参数**\n- path - 文件路径。\n- callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"准备打开文件！\");\nfs.stat('test.txt', function (err, stats) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(stats);\n   console.log(\"读取文件信息成功！\");\n\n   // 检测文件类型\n   console.log(\"是否为文件(isFile) ? \" + stats.isFile());\n   console.log(\"是否为目录(isDirectory) ? \" + stats.isDirectory());    \n});\n```\n## 写入文件\n**语法**\n```\nfs.writeFile(filename, data[, options], callback)\n```\n**参数**\n- path - 文件路径。\n- data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。\n- options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 'w'\n- callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"准备写入文件\");\nfs.writeFile('test.txt', '我是通过写入的文件内容！',  function(err) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"数据写入成功！\");\n   console.log(\"--------我是分割线-------------\")\n   console.log(\"读取写入的数据！\");\n   fs.readFile('test.txt', function (err, data) {\n      if (err) {\n         return console.error(err);\n      }\n      console.log(\"异步读取文件数据: \" + data.toString());\n   });\n});\n```\n## 读取文件\n**语法**\n```\nfs.read(fd, buffer, offset, length, position, callback)\n```\n**参数**\n- fd - 通过 fs.open() 方法返回的文件描述符。\n- buffer - 数据写入的缓冲区。\n- offset - 缓冲区写入的写入偏移量。\n- length - 要从文件中读取的字节数。\n- position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。\n- callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。\n\n**例子**\ntest.txt 文件内容为：\n```\nwww.lengziyu.com\n```\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\nvar buf = new Buffer(1024);\n\nconsole.log(\"准备打开已存在的文件！\");\nfs.open('test.txt', 'r+', function(err, fd) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"文件打开成功！\");\n   console.log(\"准备读取文件：\");\n   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){\n      if (err){\n         console.log(err);\n      }\n      console.log(bytes + \"  字节被读取\");\n\n      // 仅输出读取的字节\n      if(bytes > 0){\n         console.log(buf.slice(0, bytes).toString());\n      }\n   });\n});\n```\n## 删除文件\n**语法**\n```\nfs.unlink(path, callback)\n```\n**参数**\n- path - 文件路径。\n- callback - 回调函数，没有参数。\n\n**例子**\ntest.txt 文件内容为：\n```\nwww.lengziyu.com\n```\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"准备删除文件！\");\nfs.unlink('test.txt', function(err) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"文件删除成功！\");\n});\n```\n再去查看 test.txt 文件，发现已经不存在了。\n\n## 创建目录\n**语法**\n```\nfs.mkdir(path[, mode], callback)\n```\n**参数**\n- path - 文件路径。\n- mode - 设置目录权限，默认为 0777。\n- callback - 回调函数，没有参数。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"创建目录 /test/\");\nfs.mkdir(\"/test/\",function(err){\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"目录创建成功。\");\n});\n```\n\n## 读取目录\n**语法**\n```\nfs.readdir(path, callback)\n```\n**参数**\n- path - 文件路径。\n- callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"查看 /test 目录\");\nfs.readdir(\"/test/\",function(err, files){\n   if (err) {\n       return console.error(err);\n   }\n   files.forEach( function (file){\n       console.log( file );\n   });\n});\n```\n## 删除目录\n**语法**\n```\nfs.rmdir(path, callback)\n```\n**参数**\n- path - 文件路径。\n- callback - 回调函数，没有参数。\n\n**例子**\n接下来我们创建 file.js 文件，代码如下所示：\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"准备删除目录 /tmp/test\");\nfs.rmdir(\"/tmp/test\",function(err){\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"读取 /tmp 目录\");\n   fs.readdir(\"/tmp/\",function(err, files){\n      if (err) {\n          return console.error(err);\n      }\n      files.forEach( function (file){\n          console.log( file );\n      });\n   });\n});\n```\n更多内容，请查看官网文件模块描述：[File System](https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback)。\n","slug":"node-use-fs-modules","published":1,"updated":"2019-08-15T15:03:33.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjn000gxknwy84yorsc","content":"<p>fs是nodejs的文件系统，使用方法均有异步和同步版本，建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。使用fs模块可以轻松地对文件/文件夹进行操作。<br><a id=\"more\"></a></p>\n<h2 id=\"异步和同步\"><a href=\"#异步和同步\" class=\"headerlink\" title=\"异步和同步\"></a>异步和同步</h2><p>创建 test.txt 文件，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blog.lengziyu.com</span><br><span class=\"line\">文件读取test</span><br></pre></td></tr></table></figure></p>\n<p>创建 file.js 文件, 代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 异步读取</span><br><span class=\"line\">fs.readFile(&apos;input.txt&apos;, function (err, data) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;异步读取: &quot; + data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 同步读取</span><br><span class=\"line\">var data = fs.readFileSync(&apos;input.txt&apos;);</span><br><span class=\"line\">console.log(&quot;同步读取: &quot; + data.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.open(path, flags[, mode], callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件的路径。</li>\n<li>flags - 文件打开的行为。具体值详见下文。</li>\n<li>mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>\n<li>callback - 回调函数，带有两个参数如：callback(err, fd)。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，并打开 test.txt 文件进行读写，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 异步打开文件</span><br><span class=\"line\">console.log(&quot;准备打开文件！&quot;);</span><br><span class=\"line\">fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function(err, fd) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  console.log(&quot;文件打开成功！&quot;);     </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"获取文件信息\"><a href=\"#获取文件信息\" class=\"headerlink\" title=\"获取文件信息\"></a>获取文件信息</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.stat(path, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备打开文件！&quot;);</span><br><span class=\"line\">fs.stat(&apos;test.txt&apos;, function (err, stats) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(stats);</span><br><span class=\"line\">   console.log(&quot;读取文件信息成功！&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 检测文件类型</span><br><span class=\"line\">   console.log(&quot;是否为文件(isFile) ? &quot; + stats.isFile());</span><br><span class=\"line\">   console.log(&quot;是否为目录(isDirectory) ? &quot; + stats.isDirectory());    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.writeFile(filename, data[, options], callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。</li>\n<li>options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</li>\n<li>callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备写入文件&quot;);</span><br><span class=\"line\">fs.writeFile(&apos;test.txt&apos;, &apos;我是通过写入的文件内容！&apos;,  function(err) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;数据写入成功！&quot;);</span><br><span class=\"line\">   console.log(&quot;--------我是分割线-------------&quot;)</span><br><span class=\"line\">   console.log(&quot;读取写入的数据！&quot;);</span><br><span class=\"line\">   fs.readFile(&apos;test.txt&apos;, function (err, data) &#123;</span><br><span class=\"line\">      if (err) &#123;</span><br><span class=\"line\">         return console.error(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(&quot;异步读取文件数据: &quot; + data.toString());</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.read(fd, buffer, offset, length, position, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>fd - 通过 fs.open() 方法返回的文件描述符。</li>\n<li>buffer - 数据写入的缓冲区。</li>\n<li>offset - 缓冲区写入的写入偏移量。</li>\n<li>length - 要从文件中读取的字节数。</li>\n<li>position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>\n<li>callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li>\n</ul>\n<p><strong>例子</strong><br>test.txt 文件内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">www.lengziyu.com</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\">var buf = new Buffer(1024);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备打开已存在的文件！&quot;);</span><br><span class=\"line\">fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function(err, fd) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;文件打开成功！&quot;);</span><br><span class=\"line\">   console.log(&quot;准备读取文件：&quot;);</span><br><span class=\"line\">   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class=\"line\">      if (err)&#123;</span><br><span class=\"line\">         console.log(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(bytes + &quot;  字节被读取&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 仅输出读取的字节</span><br><span class=\"line\">      if(bytes &gt; 0)&#123;</span><br><span class=\"line\">         console.log(buf.slice(0, bytes).toString());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.unlink(path, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>callback - 回调函数，没有参数。</li>\n</ul>\n<p><strong>例子</strong><br>test.txt 文件内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">www.lengziyu.com</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备删除文件！&quot;);</span><br><span class=\"line\">fs.unlink(&apos;test.txt&apos;, function(err) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;文件删除成功！&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>再去查看 test.txt 文件，发现已经不存在了。</p>\n<h2 id=\"创建目录\"><a href=\"#创建目录\" class=\"headerlink\" title=\"创建目录\"></a>创建目录</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.mkdir(path[, mode], callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>mode - 设置目录权限，默认为 0777。</li>\n<li>callback - 回调函数，没有参数。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;创建目录 /test/&quot;);</span><br><span class=\"line\">fs.mkdir(&quot;/test/&quot;,function(err)&#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;目录创建成功。&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"读取目录\"><a href=\"#读取目录\" class=\"headerlink\" title=\"读取目录\"></a>读取目录</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.readdir(path, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;查看 /test 目录&quot;);</span><br><span class=\"line\">fs.readdir(&quot;/test/&quot;,function(err, files)&#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   files.forEach( function (file)&#123;</span><br><span class=\"line\">       console.log( file );</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"删除目录\"><a href=\"#删除目录\" class=\"headerlink\" title=\"删除目录\"></a>删除目录</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.rmdir(path, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>callback - 回调函数，没有参数。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备删除目录 /tmp/test&quot;);</span><br><span class=\"line\">fs.rmdir(&quot;/tmp/test&quot;,function(err)&#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;读取 /tmp 目录&quot;);</span><br><span class=\"line\">   fs.readdir(&quot;/tmp/&quot;,function(err, files)&#123;</span><br><span class=\"line\">      if (err) &#123;</span><br><span class=\"line\">          return console.error(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      files.forEach( function (file)&#123;</span><br><span class=\"line\">          console.log( file );</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>更多内容，请查看官网文件模块描述：<a href=\"https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback\" target=\"_blank\" rel=\"noopener\">File System</a>。</p>\n","site":{"data":{}},"excerpt":"<p>fs是nodejs的文件系统，使用方法均有异步和同步版本，建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。使用fs模块可以轻松地对文件/文件夹进行操作。<br>","more":"</p>\n<h2 id=\"异步和同步\"><a href=\"#异步和同步\" class=\"headerlink\" title=\"异步和同步\"></a>异步和同步</h2><p>创建 test.txt 文件，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blog.lengziyu.com</span><br><span class=\"line\">文件读取test</span><br></pre></td></tr></table></figure></p>\n<p>创建 file.js 文件, 代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 异步读取</span><br><span class=\"line\">fs.readFile(&apos;input.txt&apos;, function (err, data) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;异步读取: &quot; + data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 同步读取</span><br><span class=\"line\">var data = fs.readFileSync(&apos;input.txt&apos;);</span><br><span class=\"line\">console.log(&quot;同步读取: &quot; + data.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.open(path, flags[, mode], callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件的路径。</li>\n<li>flags - 文件打开的行为。具体值详见下文。</li>\n<li>mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>\n<li>callback - 回调函数，带有两个参数如：callback(err, fd)。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，并打开 test.txt 文件进行读写，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 异步打开文件</span><br><span class=\"line\">console.log(&quot;准备打开文件！&quot;);</span><br><span class=\"line\">fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function(err, fd) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  console.log(&quot;文件打开成功！&quot;);     </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"获取文件信息\"><a href=\"#获取文件信息\" class=\"headerlink\" title=\"获取文件信息\"></a>获取文件信息</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.stat(path, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备打开文件！&quot;);</span><br><span class=\"line\">fs.stat(&apos;test.txt&apos;, function (err, stats) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(stats);</span><br><span class=\"line\">   console.log(&quot;读取文件信息成功！&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 检测文件类型</span><br><span class=\"line\">   console.log(&quot;是否为文件(isFile) ? &quot; + stats.isFile());</span><br><span class=\"line\">   console.log(&quot;是否为目录(isDirectory) ? &quot; + stats.isDirectory());    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.writeFile(filename, data[, options], callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。</li>\n<li>options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</li>\n<li>callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备写入文件&quot;);</span><br><span class=\"line\">fs.writeFile(&apos;test.txt&apos;, &apos;我是通过写入的文件内容！&apos;,  function(err) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;数据写入成功！&quot;);</span><br><span class=\"line\">   console.log(&quot;--------我是分割线-------------&quot;)</span><br><span class=\"line\">   console.log(&quot;读取写入的数据！&quot;);</span><br><span class=\"line\">   fs.readFile(&apos;test.txt&apos;, function (err, data) &#123;</span><br><span class=\"line\">      if (err) &#123;</span><br><span class=\"line\">         return console.error(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(&quot;异步读取文件数据: &quot; + data.toString());</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.read(fd, buffer, offset, length, position, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>fd - 通过 fs.open() 方法返回的文件描述符。</li>\n<li>buffer - 数据写入的缓冲区。</li>\n<li>offset - 缓冲区写入的写入偏移量。</li>\n<li>length - 要从文件中读取的字节数。</li>\n<li>position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>\n<li>callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li>\n</ul>\n<p><strong>例子</strong><br>test.txt 文件内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">www.lengziyu.com</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\">var buf = new Buffer(1024);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备打开已存在的文件！&quot;);</span><br><span class=\"line\">fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function(err, fd) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;文件打开成功！&quot;);</span><br><span class=\"line\">   console.log(&quot;准备读取文件：&quot;);</span><br><span class=\"line\">   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class=\"line\">      if (err)&#123;</span><br><span class=\"line\">         console.log(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(bytes + &quot;  字节被读取&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">      // 仅输出读取的字节</span><br><span class=\"line\">      if(bytes &gt; 0)&#123;</span><br><span class=\"line\">         console.log(buf.slice(0, bytes).toString());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.unlink(path, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>callback - 回调函数，没有参数。</li>\n</ul>\n<p><strong>例子</strong><br>test.txt 文件内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">www.lengziyu.com</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备删除文件！&quot;);</span><br><span class=\"line\">fs.unlink(&apos;test.txt&apos;, function(err) &#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;文件删除成功！&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>再去查看 test.txt 文件，发现已经不存在了。</p>\n<h2 id=\"创建目录\"><a href=\"#创建目录\" class=\"headerlink\" title=\"创建目录\"></a>创建目录</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.mkdir(path[, mode], callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>mode - 设置目录权限，默认为 0777。</li>\n<li>callback - 回调函数，没有参数。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;创建目录 /test/&quot;);</span><br><span class=\"line\">fs.mkdir(&quot;/test/&quot;,function(err)&#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;目录创建成功。&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"读取目录\"><a href=\"#读取目录\" class=\"headerlink\" title=\"读取目录\"></a>读取目录</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.readdir(path, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;查看 /test 目录&quot;);</span><br><span class=\"line\">fs.readdir(&quot;/test/&quot;,function(err, files)&#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   files.forEach( function (file)&#123;</span><br><span class=\"line\">       console.log( file );</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"删除目录\"><a href=\"#删除目录\" class=\"headerlink\" title=\"删除目录\"></a>删除目录</h2><p><strong>语法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.rmdir(path, callback)</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong></p>\n<ul>\n<li>path - 文件路径。</li>\n<li>callback - 回调函数，没有参数。</li>\n</ul>\n<p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&quot;fs&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&quot;准备删除目录 /tmp/test&quot;);</span><br><span class=\"line\">fs.rmdir(&quot;/tmp/test&quot;,function(err)&#123;</span><br><span class=\"line\">   if (err) &#123;</span><br><span class=\"line\">       return console.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   console.log(&quot;读取 /tmp 目录&quot;);</span><br><span class=\"line\">   fs.readdir(&quot;/tmp/&quot;,function(err, files)&#123;</span><br><span class=\"line\">      if (err) &#123;</span><br><span class=\"line\">          return console.error(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      files.forEach( function (file)&#123;</span><br><span class=\"line\">          console.log( file );</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>更多内容，请查看官网文件模块描述：<a href=\"https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback\" target=\"_blank\" rel=\"noopener\">File System</a>。</p>"},{"title":"React 学习笔记","abbrlink":44509,"date":"2016-10-09T12:17:35.000Z","_content":"\nReact是Facebook和Instagram用来创建用户界面的JavaScript库。很多人将React认为是MVC中的V。 React的创建是为了解决一个问题：如何构建一个数据交互频繁的大型应用程序？为了实现这个目标，React运用了两个思想：\n\n<!-- more -->\n\n### 实时更新数据\nReact使得展现数据变得简单，并且当数据改变时，React能自动保持UI的更新。\n\n### 构建通用组件\nReact旨在构建通用组件。试试想，写React代码就是在构建组件。因为组件式封装的，所以组件使得代码的复用性、测试性和关注分离变得简单。\n\n### 基本概念\n**React.js**\nReact.js 是 React 的核心库，在应用中必须先加载核心库。\n\n**ReactDOM.js**\nReactDOM.js 是 React 的 DOM 渲染器，React 将核心库和渲染器分离开了，为了在 web 页面中显示开发的组件，需要调用 ReactDOM.render 方法， 第一个参数是 React 组件，第二个参数为 HTMLElement。\n\n**JSX**\nJSX 是 React 自定义的语法，最终 JSX 会转化为 JS 运行于页面当中。\n\n**组件**\n组件是 React 中的核心概念，页面当中的所有元素都是通过 React 组件来表达， 我们将要写的 React 代码绝大部分都是在做 React 组件的开发。\n\n**VIRTUAL DOM**\nReact 抽象出来的虚拟 DOM 树，虚拟树是 React 高性能的关键。\n\n**单向数据流：one-way reactive data flow**\nReact 应用的核心设计模式，数据流向自顶向下\n\n### Hello World\n创建一个简单的 `Hello World`，新建 index.html：\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>React</title>\n</head>\n<body>\n\n<div id=\"example\"></div>\n\n<script src=\"js/react.js\"></script>\n<script src=\"js/JSXTransformer.js\"></script>\n<script src=\"js/app.js\" type=\"text/jsx\"></script>\n</body>\n</html>\n```\nReact独创了一种JS、CSS和HTML混写的JSX格式，可以通过在页面中引入JSXTransformer这个文件进行客户端的编译，不过还是推荐在服务端编译。\napp.js :\n```JS\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <div>Hello {this.props.name}</div>;\n  }\n});\n\nReact.render(\n  <HelloMessage name=\"John\" />,\n  document.getElementById('container')\n);\n```\n### React.createClass\n用来创建一个组件类，编写React代码主要就是构建通用的组件。\n\n### React.render\n将React的模板转化为HTML，并插入到相应的DOM结构中。要注意的是，React的渲染函数并不是简单地把HTML元素复制到页面上，而是维护了一张Virtual Dom映射表。\n","source":"_posts/react-early-know.md","raw":"---\ntitle: React 学习笔记\ntags: react\nabbrlink: 44509\ndate: 2016-10-09 20:17:35\n---\n\nReact是Facebook和Instagram用来创建用户界面的JavaScript库。很多人将React认为是MVC中的V。 React的创建是为了解决一个问题：如何构建一个数据交互频繁的大型应用程序？为了实现这个目标，React运用了两个思想：\n\n<!-- more -->\n\n### 实时更新数据\nReact使得展现数据变得简单，并且当数据改变时，React能自动保持UI的更新。\n\n### 构建通用组件\nReact旨在构建通用组件。试试想，写React代码就是在构建组件。因为组件式封装的，所以组件使得代码的复用性、测试性和关注分离变得简单。\n\n### 基本概念\n**React.js**\nReact.js 是 React 的核心库，在应用中必须先加载核心库。\n\n**ReactDOM.js**\nReactDOM.js 是 React 的 DOM 渲染器，React 将核心库和渲染器分离开了，为了在 web 页面中显示开发的组件，需要调用 ReactDOM.render 方法， 第一个参数是 React 组件，第二个参数为 HTMLElement。\n\n**JSX**\nJSX 是 React 自定义的语法，最终 JSX 会转化为 JS 运行于页面当中。\n\n**组件**\n组件是 React 中的核心概念，页面当中的所有元素都是通过 React 组件来表达， 我们将要写的 React 代码绝大部分都是在做 React 组件的开发。\n\n**VIRTUAL DOM**\nReact 抽象出来的虚拟 DOM 树，虚拟树是 React 高性能的关键。\n\n**单向数据流：one-way reactive data flow**\nReact 应用的核心设计模式，数据流向自顶向下\n\n### Hello World\n创建一个简单的 `Hello World`，新建 index.html：\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>React</title>\n</head>\n<body>\n\n<div id=\"example\"></div>\n\n<script src=\"js/react.js\"></script>\n<script src=\"js/JSXTransformer.js\"></script>\n<script src=\"js/app.js\" type=\"text/jsx\"></script>\n</body>\n</html>\n```\nReact独创了一种JS、CSS和HTML混写的JSX格式，可以通过在页面中引入JSXTransformer这个文件进行客户端的编译，不过还是推荐在服务端编译。\napp.js :\n```JS\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <div>Hello {this.props.name}</div>;\n  }\n});\n\nReact.render(\n  <HelloMessage name=\"John\" />,\n  document.getElementById('container')\n);\n```\n### React.createClass\n用来创建一个组件类，编写React代码主要就是构建通用的组件。\n\n### React.render\n将React的模板转化为HTML，并插入到相应的DOM结构中。要注意的是，React的渲染函数并不是简单地把HTML元素复制到页面上，而是维护了一张Virtual Dom映射表。\n","slug":"react-early-know","published":1,"updated":"2019-08-15T15:03:33.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjp000ixknwpkrnzb63","content":"<p>React是Facebook和Instagram用来创建用户界面的JavaScript库。很多人将React认为是MVC中的V。 React的创建是为了解决一个问题：如何构建一个数据交互频繁的大型应用程序？为了实现这个目标，React运用了两个思想：</p>\n<a id=\"more\"></a>\n<h3 id=\"实时更新数据\"><a href=\"#实时更新数据\" class=\"headerlink\" title=\"实时更新数据\"></a>实时更新数据</h3><p>React使得展现数据变得简单，并且当数据改变时，React能自动保持UI的更新。</p>\n<h3 id=\"构建通用组件\"><a href=\"#构建通用组件\" class=\"headerlink\" title=\"构建通用组件\"></a>构建通用组件</h3><p>React旨在构建通用组件。试试想，写React代码就是在构建组件。因为组件式封装的，所以组件使得代码的复用性、测试性和关注分离变得简单。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p><strong>React.js</strong><br>React.js 是 React 的核心库，在应用中必须先加载核心库。</p>\n<p><strong>ReactDOM.js</strong><br>ReactDOM.js 是 React 的 DOM 渲染器，React 将核心库和渲染器分离开了，为了在 web 页面中显示开发的组件，需要调用 ReactDOM.render 方法， 第一个参数是 React 组件，第二个参数为 HTMLElement。</p>\n<p><strong>JSX</strong><br>JSX 是 React 自定义的语法，最终 JSX 会转化为 JS 运行于页面当中。</p>\n<p><strong>组件</strong><br>组件是 React 中的核心概念，页面当中的所有元素都是通过 React 组件来表达， 我们将要写的 React 代码绝大部分都是在做 React 组件的开发。</p>\n<p><strong>VIRTUAL DOM</strong><br>React 抽象出来的虚拟 DOM 树，虚拟树是 React 高性能的关键。</p>\n<p><strong>单向数据流：one-way reactive data flow</strong><br>React 应用的核心设计模式，数据流向自顶向下</p>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>创建一个简单的 <code>Hello World</code>，新建 index.html：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>React<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/react.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/JSXTransformer.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/app.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/jsx\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>React独创了一种JS、CSS和HTML混写的JSX格式，可以通过在页面中引入JSXTransformer这个文件进行客户端的编译，不过还是推荐在服务端编译。<br>app.js :<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">React.render(</span><br><span class=\"line\">  &lt;HelloMessage name=<span class=\"string\">\"John\"</span> /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"React-createClass\"><a href=\"#React-createClass\" class=\"headerlink\" title=\"React.createClass\"></a>React.createClass</h3><p>用来创建一个组件类，编写React代码主要就是构建通用的组件。</p>\n<h3 id=\"React-render\"><a href=\"#React-render\" class=\"headerlink\" title=\"React.render\"></a>React.render</h3><p>将React的模板转化为HTML，并插入到相应的DOM结构中。要注意的是，React的渲染函数并不是简单地把HTML元素复制到页面上，而是维护了一张Virtual Dom映射表。</p>\n","site":{"data":{}},"excerpt":"<p>React是Facebook和Instagram用来创建用户界面的JavaScript库。很多人将React认为是MVC中的V。 React的创建是为了解决一个问题：如何构建一个数据交互频繁的大型应用程序？为了实现这个目标，React运用了两个思想：</p>","more":"<h3 id=\"实时更新数据\"><a href=\"#实时更新数据\" class=\"headerlink\" title=\"实时更新数据\"></a>实时更新数据</h3><p>React使得展现数据变得简单，并且当数据改变时，React能自动保持UI的更新。</p>\n<h3 id=\"构建通用组件\"><a href=\"#构建通用组件\" class=\"headerlink\" title=\"构建通用组件\"></a>构建通用组件</h3><p>React旨在构建通用组件。试试想，写React代码就是在构建组件。因为组件式封装的，所以组件使得代码的复用性、测试性和关注分离变得简单。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p><strong>React.js</strong><br>React.js 是 React 的核心库，在应用中必须先加载核心库。</p>\n<p><strong>ReactDOM.js</strong><br>ReactDOM.js 是 React 的 DOM 渲染器，React 将核心库和渲染器分离开了，为了在 web 页面中显示开发的组件，需要调用 ReactDOM.render 方法， 第一个参数是 React 组件，第二个参数为 HTMLElement。</p>\n<p><strong>JSX</strong><br>JSX 是 React 自定义的语法，最终 JSX 会转化为 JS 运行于页面当中。</p>\n<p><strong>组件</strong><br>组件是 React 中的核心概念，页面当中的所有元素都是通过 React 组件来表达， 我们将要写的 React 代码绝大部分都是在做 React 组件的开发。</p>\n<p><strong>VIRTUAL DOM</strong><br>React 抽象出来的虚拟 DOM 树，虚拟树是 React 高性能的关键。</p>\n<p><strong>单向数据流：one-way reactive data flow</strong><br>React 应用的核心设计模式，数据流向自顶向下</p>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>创建一个简单的 <code>Hello World</code>，新建 index.html：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>React<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"example\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/react.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/JSXTransformer.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/app.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/jsx\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>React独创了一种JS、CSS和HTML混写的JSX格式，可以通过在页面中引入JSXTransformer这个文件进行客户端的编译，不过还是推荐在服务端编译。<br>app.js :<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">React.render(</span><br><span class=\"line\">  &lt;HelloMessage name=<span class=\"string\">\"John\"</span> /&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"React-createClass\"><a href=\"#React-createClass\" class=\"headerlink\" title=\"React.createClass\"></a>React.createClass</h3><p>用来创建一个组件类，编写React代码主要就是构建通用的组件。</p>\n<h3 id=\"React-render\"><a href=\"#React-render\" class=\"headerlink\" title=\"React.render\"></a>React.render</h3><p>将React的模板转化为HTML，并插入到相应的DOM结构中。要注意的是，React的渲染函数并不是简单地把HTML元素复制到页面上，而是维护了一张Virtual Dom映射表。</p>"},{"title":"React JSX语法","abbrlink":56682,"date":"2016-10-12T12:00:40.000Z","_content":"JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。\n<!--more-->\n```\nJSX=JavaScriptXML\n```\nJSX可以理解为在JS中编写与XML类似的语言（与XML有本质上的不同），它的目的不是要在浏览器或者引擎中实现，也不是把其加入ECMAScript标准。它的目的是通过各种编译器将这些标记编译成标准的JS语言。\n\nJSX是：\n- 基于ECMAScript的一种新特性（并不是一种新语言）\n- 一种定义带属性树结构（DOM结构）的语法\n\nJSX不是：\n- XML或者HTML\n- 一种限制 （你不需要为了 React 使用 JSX，可以直接使用纯粹的 JS。但更建议使用 JSX , 因为它能定义简洁且我们熟知的包含属性的树状结构语法。）\n\nJSX的特点：\n* 类XML语法容易接受，结构清晰\n* 增强JS语义\n* 抽象程度高，屏蔽DOM操作，跨平台\n* 代码模块化\n\n\n## JSX语法\nJSX本身就和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式，例如：\n```JS\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <div>Hello {this.props.name}</div>;\n  }\n});\n\nReactDOM.render(<HelloMessage name=\"lengziyu\" />, mountNode);\n```\n**一、元素名**\n自定义出的组件标签名，React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。render渲染时，会把大写的组件名定义为自定义组件，把小写的组件名定义为HTML自带的标签名进行渲染。\n```\nvar HelloMessage =\n```\nJSX的标签与函数名都是使用的驼峰命名。\n\nhtmlFor和className\nfor和class为js的保留字，在书写for与class时需要修改为htmlFor何className，注意都是使用的驼峰命名。\n\n自闭合标签\n在 JSX 中， <MyComponent /> 是合法的，而 <MyComponent> 就不合法。 所有的标签都必须闭合，可以是自闭和的形式，也可以是常规的闭合。\n<div class=\"tip\">\n注意：所有 React component 都可以采用自闭和的形式，包括div等\n</div>\n\n**二、子节点**\n组件与组件之间就像标签与标签之间可以有嵌套关系，与HTML不同的是可以在子节点中使用求值表达式。目前， 一个 component 的 render，只能返回一个节点。如果你需要返回一堆 div ， 那你必须将你的组件用 一个div 或 span 或任何其他的组件包裹。\n<div class=\"tip\">\n切记，JSX 会被编译成常规的 JS； 因此返回两个函数也就没什么意义了，同样地，千万不要在三元操作符中放入超过一个子节点。\n</div>\n如果往原生 HTML 元素里传入 HTML 规范里不存在的属性，React 不会显示它们。如果需要使用自定义属性，要加 data- 前缀。\n\n\n**三、求值表达式**\n要使用 JavaScript 表达式作为属性值，只需把这个表达式用一对大括号 ( { } ) 包起来，不要用引号 ( \" \" )。求值表达式本身与JSX没有多大关系，是JS中的特性。它是会返回值的表达式，与语句有本质上的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。\n\n条件判断的写法\n你没法在JSX中使用 if-else 语句，因为 JSX 只是函数调用和对象创建的语法糖。在 { } 中使用，是不合法的JS代码，不过可以采用三元操作表达式。\n```\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <div>Hello {this.props.name ？ this.props.name : \"World\"}</div>;\n  }\n});\nReactDOM.render(<HelloMessage name=\"xiaowang\" />, document.body);\n```\n可以使用比较运算符“ || ”来书写，如果左边的值为真，则直接返回左边的值，否则返回右边的值，与if的效果相同。\n\n```\nvar HelloMessage = React.createClass({\n  render: function() {\n      return <div>Hello {this.props.name || \"World\"}</div>;\n  }\n});\nReactDOM.render(<HelloMessage name=\"xiaowang\" />, document.body);\n```\n也可以使用变量来书写：\n```\nvar HelloMessage = React.createClass({\n  getName : function() {\n      if (this.props.name)\n          return this.props.name\n      else\n          return \"world\"\n  }\n  render: function() {\n      var name = this.getName();\n      return <div>Hello {name}</div>;\n  }\n});\nReactDOM.render(<HelloMessage name=\"xiaowang\" />, document.body);\n```\n其中可以把变量去掉，直接在 { } 中调用函数：\n```\nrender: function() {\n    return <div>Hello {this.getName()}</div>;\n}\n```\n**四、注释**\nJSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 { } 包围要注释的部分。\n```\nvar content = (\n  <Nav>\n    {/* 一般注释, 用 {} 包围 */}\n    <Person\n      /* 多\n         行\n         注释 */\n      name={window.isLoggedIn ? window.name : ''} // 行尾注释\n    />\n  </Nav>\n);\n```\n\n\n**五、样式**\n尽管在大部分场景下我们应该将样式写在独立的CSS文件中，但是有时对于某个特定组件而言，其样式相当简单而且独立，那么也可以将其直接定义在JSX中。在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象，需要注意的是属性名同样需要驼峰命名法。例如：\n```\n<div style={{color: '#ff0000', fontSize: '14px'}}>Hello World.</div>\n```\n```\nvar style = {    \n    color : \"red\",\n    border : \"1px solid #000\"\n}\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <div>Hello {this.props.name}</div>;\n  }\n});\nReactDOM.render(<div style={style}><HelloMessage name=\"xiaowang\" /></div>, document.body);\n```\n## 小结\n本文主要介绍了声明组件的语法JSX。看似有点神秘的JSX背后的原理非常简单：只是一种用于创建组件的XML语法。让代码直观易懂是软件项目质量的重要保证之一，这意味着代码更加容易理解和维护，出现Bug时更容易调试和修复。因此React这种采用JSX语法，以声明式的方法来直观的定义用户界面的方式，正是其最大的价值。\n","source":"_posts/react-jsx-grammar.md","raw":"---\ntitle: React JSX语法\ntags: react\ncategories: react\nabbrlink: 56682\ndate: 2016-10-12 20:00:40\n---\nJSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。\n<!--more-->\n```\nJSX=JavaScriptXML\n```\nJSX可以理解为在JS中编写与XML类似的语言（与XML有本质上的不同），它的目的不是要在浏览器或者引擎中实现，也不是把其加入ECMAScript标准。它的目的是通过各种编译器将这些标记编译成标准的JS语言。\n\nJSX是：\n- 基于ECMAScript的一种新特性（并不是一种新语言）\n- 一种定义带属性树结构（DOM结构）的语法\n\nJSX不是：\n- XML或者HTML\n- 一种限制 （你不需要为了 React 使用 JSX，可以直接使用纯粹的 JS。但更建议使用 JSX , 因为它能定义简洁且我们熟知的包含属性的树状结构语法。）\n\nJSX的特点：\n* 类XML语法容易接受，结构清晰\n* 增强JS语义\n* 抽象程度高，屏蔽DOM操作，跨平台\n* 代码模块化\n\n\n## JSX语法\nJSX本身就和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式，例如：\n```JS\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <div>Hello {this.props.name}</div>;\n  }\n});\n\nReactDOM.render(<HelloMessage name=\"lengziyu\" />, mountNode);\n```\n**一、元素名**\n自定义出的组件标签名，React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。render渲染时，会把大写的组件名定义为自定义组件，把小写的组件名定义为HTML自带的标签名进行渲染。\n```\nvar HelloMessage =\n```\nJSX的标签与函数名都是使用的驼峰命名。\n\nhtmlFor和className\nfor和class为js的保留字，在书写for与class时需要修改为htmlFor何className，注意都是使用的驼峰命名。\n\n自闭合标签\n在 JSX 中， <MyComponent /> 是合法的，而 <MyComponent> 就不合法。 所有的标签都必须闭合，可以是自闭和的形式，也可以是常规的闭合。\n<div class=\"tip\">\n注意：所有 React component 都可以采用自闭和的形式，包括div等\n</div>\n\n**二、子节点**\n组件与组件之间就像标签与标签之间可以有嵌套关系，与HTML不同的是可以在子节点中使用求值表达式。目前， 一个 component 的 render，只能返回一个节点。如果你需要返回一堆 div ， 那你必须将你的组件用 一个div 或 span 或任何其他的组件包裹。\n<div class=\"tip\">\n切记，JSX 会被编译成常规的 JS； 因此返回两个函数也就没什么意义了，同样地，千万不要在三元操作符中放入超过一个子节点。\n</div>\n如果往原生 HTML 元素里传入 HTML 规范里不存在的属性，React 不会显示它们。如果需要使用自定义属性，要加 data- 前缀。\n\n\n**三、求值表达式**\n要使用 JavaScript 表达式作为属性值，只需把这个表达式用一对大括号 ( { } ) 包起来，不要用引号 ( \" \" )。求值表达式本身与JSX没有多大关系，是JS中的特性。它是会返回值的表达式，与语句有本质上的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。\n\n条件判断的写法\n你没法在JSX中使用 if-else 语句，因为 JSX 只是函数调用和对象创建的语法糖。在 { } 中使用，是不合法的JS代码，不过可以采用三元操作表达式。\n```\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <div>Hello {this.props.name ？ this.props.name : \"World\"}</div>;\n  }\n});\nReactDOM.render(<HelloMessage name=\"xiaowang\" />, document.body);\n```\n可以使用比较运算符“ || ”来书写，如果左边的值为真，则直接返回左边的值，否则返回右边的值，与if的效果相同。\n\n```\nvar HelloMessage = React.createClass({\n  render: function() {\n      return <div>Hello {this.props.name || \"World\"}</div>;\n  }\n});\nReactDOM.render(<HelloMessage name=\"xiaowang\" />, document.body);\n```\n也可以使用变量来书写：\n```\nvar HelloMessage = React.createClass({\n  getName : function() {\n      if (this.props.name)\n          return this.props.name\n      else\n          return \"world\"\n  }\n  render: function() {\n      var name = this.getName();\n      return <div>Hello {name}</div>;\n  }\n});\nReactDOM.render(<HelloMessage name=\"xiaowang\" />, document.body);\n```\n其中可以把变量去掉，直接在 { } 中调用函数：\n```\nrender: function() {\n    return <div>Hello {this.getName()}</div>;\n}\n```\n**四、注释**\nJSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 { } 包围要注释的部分。\n```\nvar content = (\n  <Nav>\n    {/* 一般注释, 用 {} 包围 */}\n    <Person\n      /* 多\n         行\n         注释 */\n      name={window.isLoggedIn ? window.name : ''} // 行尾注释\n    />\n  </Nav>\n);\n```\n\n\n**五、样式**\n尽管在大部分场景下我们应该将样式写在独立的CSS文件中，但是有时对于某个特定组件而言，其样式相当简单而且独立，那么也可以将其直接定义在JSX中。在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象，需要注意的是属性名同样需要驼峰命名法。例如：\n```\n<div style={{color: '#ff0000', fontSize: '14px'}}>Hello World.</div>\n```\n```\nvar style = {    \n    color : \"red\",\n    border : \"1px solid #000\"\n}\nvar HelloMessage = React.createClass({\n  render: function() {\n    return <div>Hello {this.props.name}</div>;\n  }\n});\nReactDOM.render(<div style={style}><HelloMessage name=\"xiaowang\" /></div>, document.body);\n```\n## 小结\n本文主要介绍了声明组件的语法JSX。看似有点神秘的JSX背后的原理非常简单：只是一种用于创建组件的XML语法。让代码直观易懂是软件项目质量的重要保证之一，这意味着代码更加容易理解和维护，出现Bug时更容易调试和修复。因此React这种采用JSX语法，以声明式的方法来直观的定义用户界面的方式，正是其最大的价值。\n","slug":"react-jsx-grammar","published":1,"updated":"2019-08-15T15:03:33.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjr000nxknwwy23x9gh","content":"<p>JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSX=JavaScriptXML</span><br></pre></td></tr></table></figure></p>\n<p>JSX可以理解为在JS中编写与XML类似的语言（与XML有本质上的不同），它的目的不是要在浏览器或者引擎中实现，也不是把其加入ECMAScript标准。它的目的是通过各种编译器将这些标记编译成标准的JS语言。</p>\n<p>JSX是：</p>\n<ul>\n<li>基于ECMAScript的一种新特性（并不是一种新语言）</li>\n<li>一种定义带属性树结构（DOM结构）的语法</li>\n</ul>\n<p>JSX不是：</p>\n<ul>\n<li>XML或者HTML</li>\n<li>一种限制 （你不需要为了 React 使用 JSX，可以直接使用纯粹的 JS。但更建议使用 JSX , 因为它能定义简洁且我们熟知的包含属性的树状结构语法。）</li>\n</ul>\n<p>JSX的特点：</p>\n<ul>\n<li>类XML语法容易接受，结构清晰</li>\n<li>增强JS语义</li>\n<li>抽象程度高，屏蔽DOM操作，跨平台</li>\n<li>代码模块化</li>\n</ul>\n<h2 id=\"JSX语法\"><a href=\"#JSX语法\" class=\"headerlink\" title=\"JSX语法\"></a>JSX语法</h2><p>JSX本身就和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式，例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">HelloMessage</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lengziyu\"</span> /&gt;</span>, mountNode);</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>一、元素名</strong><br>自定义出的组件标签名，React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。render渲染时，会把大写的组件名定义为自定义组件，把小写的组件名定义为HTML自带的标签名进行渲染。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage =</span><br></pre></td></tr></table></figure></p>\n<p>JSX的标签与函数名都是使用的驼峰命名。</p>\n<p>htmlFor和className<br>for和class为js的保留字，在书写for与class时需要修改为htmlFor何className，注意都是使用的驼峰命名。</p>\n<p>自闭合标签<br>在 JSX 中， <mycomponent> 是合法的，而 <mycomponent> 就不合法。 所有的标签都必须闭合，可以是自闭和的形式，也可以是常规的闭合。</mycomponent></mycomponent></p>\n<div class=\"tip\"><br>注意：所有 React component 都可以采用自闭和的形式，包括div等<br></div>\n\n<p><strong>二、子节点</strong><br>组件与组件之间就像标签与标签之间可以有嵌套关系，与HTML不同的是可以在子节点中使用求值表达式。目前， 一个 component 的 render，只能返回一个节点。如果你需要返回一堆 div ， 那你必须将你的组件用 一个div 或 span 或任何其他的组件包裹。</p>\n<p><div class=\"tip\"><br>切记，JSX 会被编译成常规的 JS； 因此返回两个函数也就没什么意义了，同样地，千万不要在三元操作符中放入超过一个子节点。<br></div><br>如果往原生 HTML 元素里传入 HTML 规范里不存在的属性，React 不会显示它们。如果需要使用自定义属性，要加 data- 前缀。</p>\n<p><strong>三、求值表达式</strong><br>要使用 JavaScript 表达式作为属性值，只需把这个表达式用一对大括号 ( { } ) 包起来，不要用引号 ( “ “ )。求值表达式本身与JSX没有多大关系，是JS中的特性。它是会返回值的表达式，与语句有本质上的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。</p>\n<p>条件判断的写法<br>你没法在JSX中使用 if-else 语句，因为 JSX 只是函数调用和对象创建的语法糖。在 { } 中使用，是不合法的JS代码，不过可以采用三元操作表达式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return &lt;div&gt;Hello &#123;this.props.name ？ this.props.name : &quot;World&quot;&#125;&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body);</span><br></pre></td></tr></table></figure></p>\n<p>可以使用比较运算符“ || ”来书写，如果左边的值为真，则直接返回左边的值，否则返回右边的值，与if的效果相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">      return &lt;div&gt;Hello &#123;this.props.name || &quot;World&quot;&#125;&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body);</span><br></pre></td></tr></table></figure>\n<p>也可以使用变量来书写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  getName : function() &#123;</span><br><span class=\"line\">      if (this.props.name)</span><br><span class=\"line\">          return this.props.name</span><br><span class=\"line\">      else</span><br><span class=\"line\">          return &quot;world&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">      var name = this.getName();</span><br><span class=\"line\">      return &lt;div&gt;Hello &#123;name&#125;&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body);</span><br></pre></td></tr></table></figure></p>\n<p>其中可以把变量去掉，直接在 { } 中调用函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">    return &lt;div&gt;Hello &#123;this.getName()&#125;&lt;/div&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>四、注释</strong><br>JSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 { } 包围要注释的部分。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var content = (</span><br><span class=\"line\">  &lt;Nav&gt;</span><br><span class=\"line\">    &#123;/* 一般注释, 用 &#123;&#125; 包围 */&#125;</span><br><span class=\"line\">    &lt;Person</span><br><span class=\"line\">      /* 多</span><br><span class=\"line\">         行</span><br><span class=\"line\">         注释 */</span><br><span class=\"line\">      name=&#123;window.isLoggedIn ? window.name : &apos;&apos;&#125; // 行尾注释</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  &lt;/Nav&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p><strong>五、样式</strong><br>尽管在大部分场景下我们应该将样式写在独立的CSS文件中，但是有时对于某个特定组件而言，其样式相当简单而且独立，那么也可以将其直接定义在JSX中。在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象，需要注意的是属性名同样需要驼峰命名法。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&#123;&#123;color: &apos;#ff0000&apos;, fontSize: &apos;14px&apos;&#125;&#125;&gt;Hello World.&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var style = &#123;    </span><br><span class=\"line\">    color : &quot;red&quot;,</span><br><span class=\"line\">    border : &quot;1px solid #000&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;div style=&#123;style&#125;&gt;&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;&lt;/div&gt;, document.body);</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文主要介绍了声明组件的语法JSX。看似有点神秘的JSX背后的原理非常简单：只是一种用于创建组件的XML语法。让代码直观易懂是软件项目质量的重要保证之一，这意味着代码更加容易理解和维护，出现Bug时更容易调试和修复。因此React这种采用JSX语法，以声明式的方法来直观的定义用户界面的方式，正是其最大的价值。</p>\n","site":{"data":{}},"excerpt":"<p>JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSX=JavaScriptXML</span><br></pre></td></tr></table></figure></p>\n<p>JSX可以理解为在JS中编写与XML类似的语言（与XML有本质上的不同），它的目的不是要在浏览器或者引擎中实现，也不是把其加入ECMAScript标准。它的目的是通过各种编译器将这些标记编译成标准的JS语言。</p>\n<p>JSX是：</p>\n<ul>\n<li>基于ECMAScript的一种新特性（并不是一种新语言）</li>\n<li>一种定义带属性树结构（DOM结构）的语法</li>\n</ul>\n<p>JSX不是：</p>\n<ul>\n<li>XML或者HTML</li>\n<li>一种限制 （你不需要为了 React 使用 JSX，可以直接使用纯粹的 JS。但更建议使用 JSX , 因为它能定义简洁且我们熟知的包含属性的树状结构语法。）</li>\n</ul>\n<p>JSX的特点：</p>\n<ul>\n<li>类XML语法容易接受，结构清晰</li>\n<li>增强JS语义</li>\n<li>抽象程度高，屏蔽DOM操作，跨平台</li>\n<li>代码模块化</li>\n</ul>\n<h2 id=\"JSX语法\"><a href=\"#JSX语法\" class=\"headerlink\" title=\"JSX语法\"></a>JSX语法</h2><p>JSX本身就和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式，例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">HelloMessage</span> <span class=\"attr\">name</span>=<span class=\"string\">\"lengziyu\"</span> /&gt;</span>, mountNode);</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>一、元素名</strong><br>自定义出的组件标签名，React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。render渲染时，会把大写的组件名定义为自定义组件，把小写的组件名定义为HTML自带的标签名进行渲染。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage =</span><br></pre></td></tr></table></figure></p>\n<p>JSX的标签与函数名都是使用的驼峰命名。</p>\n<p>htmlFor和className<br>for和class为js的保留字，在书写for与class时需要修改为htmlFor何className，注意都是使用的驼峰命名。</p>\n<p>自闭合标签<br>在 JSX 中， <mycomponent> 是合法的，而 <mycomponent> 就不合法。 所有的标签都必须闭合，可以是自闭和的形式，也可以是常规的闭合。</mycomponent></mycomponent></p>\n<div class=\"tip\"><br>注意：所有 React component 都可以采用自闭和的形式，包括div等<br></div>\n\n<p><strong>二、子节点</strong><br>组件与组件之间就像标签与标签之间可以有嵌套关系，与HTML不同的是可以在子节点中使用求值表达式。目前， 一个 component 的 render，只能返回一个节点。如果你需要返回一堆 div ， 那你必须将你的组件用 一个div 或 span 或任何其他的组件包裹。</p>\n<p><div class=\"tip\"><br>切记，JSX 会被编译成常规的 JS； 因此返回两个函数也就没什么意义了，同样地，千万不要在三元操作符中放入超过一个子节点。<br></div><br>如果往原生 HTML 元素里传入 HTML 规范里不存在的属性，React 不会显示它们。如果需要使用自定义属性，要加 data- 前缀。</p>\n<p><strong>三、求值表达式</strong><br>要使用 JavaScript 表达式作为属性值，只需把这个表达式用一对大括号 ( { } ) 包起来，不要用引号 ( “ “ )。求值表达式本身与JSX没有多大关系，是JS中的特性。它是会返回值的表达式，与语句有本质上的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。</p>\n<p>条件判断的写法<br>你没法在JSX中使用 if-else 语句，因为 JSX 只是函数调用和对象创建的语法糖。在 { } 中使用，是不合法的JS代码，不过可以采用三元操作表达式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return &lt;div&gt;Hello &#123;this.props.name ？ this.props.name : &quot;World&quot;&#125;&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body);</span><br></pre></td></tr></table></figure></p>\n<p>可以使用比较运算符“ || ”来书写，如果左边的值为真，则直接返回左边的值，否则返回右边的值，与if的效果相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">      return &lt;div&gt;Hello &#123;this.props.name || &quot;World&quot;&#125;&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body);</span><br></pre></td></tr></table></figure>\n<p>也可以使用变量来书写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  getName : function() &#123;</span><br><span class=\"line\">      if (this.props.name)</span><br><span class=\"line\">          return this.props.name</span><br><span class=\"line\">      else</span><br><span class=\"line\">          return &quot;world&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">      var name = this.getName();</span><br><span class=\"line\">      return &lt;div&gt;Hello &#123;name&#125;&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body);</span><br></pre></td></tr></table></figure></p>\n<p>其中可以把变量去掉，直接在 { } 中调用函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">    return &lt;div&gt;Hello &#123;this.getName()&#125;&lt;/div&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>四、注释</strong><br>JSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 { } 包围要注释的部分。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var content = (</span><br><span class=\"line\">  &lt;Nav&gt;</span><br><span class=\"line\">    &#123;/* 一般注释, 用 &#123;&#125; 包围 */&#125;</span><br><span class=\"line\">    &lt;Person</span><br><span class=\"line\">      /* 多</span><br><span class=\"line\">         行</span><br><span class=\"line\">         注释 */</span><br><span class=\"line\">      name=&#123;window.isLoggedIn ? window.name : &apos;&apos;&#125; // 行尾注释</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\">  &lt;/Nav&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p><strong>五、样式</strong><br>尽管在大部分场景下我们应该将样式写在独立的CSS文件中，但是有时对于某个特定组件而言，其样式相当简单而且独立，那么也可以将其直接定义在JSX中。在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象，需要注意的是属性名同样需要驼峰命名法。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=&#123;&#123;color: &apos;#ff0000&apos;, fontSize: &apos;14px&apos;&#125;&#125;&gt;Hello World.&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var style = &#123;    </span><br><span class=\"line\">    color : &quot;red&quot;,</span><br><span class=\"line\">    border : &quot;1px solid #000&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var HelloMessage = React.createClass(&#123;</span><br><span class=\"line\">  render: function() &#123;</span><br><span class=\"line\">    return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;div style=&#123;style&#125;&gt;&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;&lt;/div&gt;, document.body);</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文主要介绍了声明组件的语法JSX。看似有点神秘的JSX背后的原理非常简单：只是一种用于创建组件的XML语法。让代码直观易懂是软件项目质量的重要保证之一，这意味着代码更加容易理解和维护，出现Bug时更容易调试和修复。因此React这种采用JSX语法，以声明式的方法来直观的定义用户界面的方式，正是其最大的价值。</p>"},{"title":"React 数据流 Props 和 State [组件沟通]","abbrlink":932,"date":"2016-10-11T10:50:20.000Z","_content":"\n组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。\n\n<!-- more -->\n\n可以分为以下 3 种：\n- 【父组件】向【子组件】传值；\n- 【子组件】向【父组件】传值；\n- 没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间传值）\n\n\n\n### 【父组件】向【子组件】传值\n父组件更新子组件状态，通过传递`props`，就可以了。例子如下：\n```JS\n// 父组件\nvar MyContainer = React.createClass({\n  getInitialState: function () {\n    return {\n      checked: true\n    };\n  },\n  render: function() {\n    return (\n      <ToggleButton text=\"Toggle me\" checked={this.state.checked} />\n    );\n  }\n});\n\n// 子组件\nvar ToggleButton = React.createClass({\n  render: function () {\n    // 从【父组件】获取的值\n    var checked = this.props.checked,\n        text = this.props.text;\n\n    return (\n        <label>{text}: <input type=\"checkbox\" checked={checked} /></label>\n    );\n  }\n});\n```\n进一步讨论\n\n如果组件嵌套层次太深，那么从外到内组件的交流成本就变得很高，通过 props 传递值的优势就不那么明显了。（PS：所以我建议尽可能的减少组件的层次，就像写 HTML 一样，简单清晰的结构更惹人爱）\n\n```JS\n// 父组件\nvar MyContainer = React.createClass({\n  render: function() {\n    return (\n      <Intermediate text=\"where is my son?\" />\n    );\n  }\n});\n\n// 子组件1：中间嵌套的组件\nvar Intermediate = React.createClass({\n  render: function () {\n    return (\n      <Child text={this.props.text} />\n    );\n  }\n});\n\n// 子组件2：子组件1的子组件\nvar Child = React.createClass({\n  render: function () {\n    return (\n      <span>{this.props.text}</span>\n    );\n  }\n});\n```\n### 【子组件】向【父组件】传值\n接下来，我们介绍【子组件】控制自己的 state 然后告诉【父组件】的点击状态，然后在【父组件】中展示出来。因此，我们添加一个 change 事件来做交互。\n```JS\n// 父组件\nvar MyContainer = React.createClass({\n  getInitialState: function () {\n    return {\n      checked: false\n    };\n  },\n  onChildChanged: function (newState) {\n    this.setState({\n      checked: newState\n    });\n  },\n  render: function() {\n    var isChecked = this.state.checked ? 'yes' : 'no';\n    return (\n      <div>\n        <div>Are you checked: {isChecked}</div>\n        <ToggleButton text=\"Toggle me\"\n          initialChecked={this.state.checked}\n          callbackParent={this.onChildChanged}\n          />\n      </div>\n    );\n  }\n});\n\n// 子组件\nvar ToggleButton = React.createClass({\n  getInitialState: function () {\n    return {\n      checked: this.props.initialChecked\n    };\n  },\n  onTextChange: function () {\n    var newState = !this.state.checked;\n    this.setState({\n      checked: newState\n    });\n    // 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值\n    this.props.callbackParent(newState);\n  },\n  render: function () {\n    // 从【父组件】获取的值\n    var text = this.props.text;\n    // 组件自身的状态数据\n    var checked = this.state.checked;\n\n    return (\n        <label>{text}: <input type=\"checkbox\" checked={checked} onChange={this.onTextChange} /></label>\n    );\n  }\n});\n```\n这样做其实是依赖 props 来传递事件的引用，并通过回调的方式来实现的，这样实现不是特别好，但是在没有任何工具的情况下也是一种简单的实现方式\n\n这里会出现一个我们在之前讨论的问题，就是组件有多层嵌套的情况下，你必须要一次传入回调函数给 props 来实现子组件向父组件传值或者操作。\n\n### 兄弟组件之间传值\n当两个组件有相同的父组件时，就称为兄弟组件（堂兄也算的）。按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的`props`。\n\n**方式一**\n通过`props`传递父组件回调函数。\n```JS\nclass Brother1 extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  render(){\n    return (\n      <div>\n        <button onClick={this.props.refresh}>\n            更新兄弟组件\n        </button>\n      </div>\n    )\n  }\n}\nclass Brother2 extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  render(){\n    return (\n      <div>\n         {this.props.text || \"兄弟组件未更新\"}\n      </div>\n    )\n  }\n}\nclass Parent extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n  refresh(){\n    return (e)=>{\n      this.setState({\n        text: \"兄弟组件沟通成功\",\n      })\n    }\n  }\n  render(){\n    return (\n      <div>\n        <h2>兄弟组件沟通</h2>\n        <Brother1 refresh={this.refresh()}/>\n        <Brother2 text={this.state.text}/>\n      </div>\n    )\n  }\n}\n```\n**方式二**\n但是如果组件层次太深，上面的兄弟组件沟通方式就效率低了（不建议组件层次太深）。\nReact提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。\n```JS\nclass Brother1 extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  render(){\n\n    return (\n      <div>\n        <button onClick={this.context.refresh}>\n            更新兄弟组件\n        </button>\n      </div>\n    )\n  }\n}\nBrother1.contextTypes = {\n  refresh: React.PropTypes.any\n}\nclass Brother2 extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  render(){\n    return (\n      <div>\n         {this.context.text || \"兄弟组件未更新\"}\n      </div>\n    )\n  }\n}\nBrother2.contextTypes = {\n  text: React.PropTypes.any\n}\nclass Parent extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  getChildContext(){\n    return {\n      refresh: this.refresh(),\n          text: this.state.text,\n      }\n    }\n\n  refresh(){\n    return (e)=>{\n      this.setState({\n        text: \"兄弟组件沟通成功\",\n      })\n    }\n  }\n  render(){\n    return (\n      <div>\n        <h2>兄弟组件沟通</h2>\n        <Brother1 />\n        <Brother2 text={this.state.text}/>\n      </div>\n    )\n  }\n}\nParent.childContextTypes = {\n  refresh: React.PropTypes.any,\n  text: React.PropTypes.any,\n}\n```\n### 全局事件\n官网中提到可以使用全局事件来进行组件间的通信，官网推荐Flux（Facebook官方出的），还有Relay、Redux、trandux等第三方类库。这些框架思想都一致，都是统一管理组件state变化情况，达到数据可控目的。\n\n### 总结\n简单的组件交流我们可以使用上面非全局事件的简单方式，但是当项目复杂，组件间层次越来越深，上面的交流方式就不太合适（当然还是要用到的，简单的交流）。强烈建议使用Flux、Relay、Redux、trandux等类库其中一种，这些类库不只适合React，像Angular等都可以使用。\n\n### 参考\n- [ReactJS组件间沟通的一些方法](http://www.alloyteam.com/2016/01/some-methods-of-reactjs-communication-between-components/)\n- [React 数据流管理架构之 Redux 介绍](http://www.alloyteam.com/2015/09/react-redux/)\n","source":"_posts/react-props-and-state-plus.md","raw":"---\ntitle: 'React 数据流 Props 和 State [组件沟通]'\ntags:\n  - react\ncategories:\n  - react\nabbrlink: 932\ndate: 2016-10-11 18:50:20\n---\n\n组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。\n\n<!-- more -->\n\n可以分为以下 3 种：\n- 【父组件】向【子组件】传值；\n- 【子组件】向【父组件】传值；\n- 没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间传值）\n\n\n\n### 【父组件】向【子组件】传值\n父组件更新子组件状态，通过传递`props`，就可以了。例子如下：\n```JS\n// 父组件\nvar MyContainer = React.createClass({\n  getInitialState: function () {\n    return {\n      checked: true\n    };\n  },\n  render: function() {\n    return (\n      <ToggleButton text=\"Toggle me\" checked={this.state.checked} />\n    );\n  }\n});\n\n// 子组件\nvar ToggleButton = React.createClass({\n  render: function () {\n    // 从【父组件】获取的值\n    var checked = this.props.checked,\n        text = this.props.text;\n\n    return (\n        <label>{text}: <input type=\"checkbox\" checked={checked} /></label>\n    );\n  }\n});\n```\n进一步讨论\n\n如果组件嵌套层次太深，那么从外到内组件的交流成本就变得很高，通过 props 传递值的优势就不那么明显了。（PS：所以我建议尽可能的减少组件的层次，就像写 HTML 一样，简单清晰的结构更惹人爱）\n\n```JS\n// 父组件\nvar MyContainer = React.createClass({\n  render: function() {\n    return (\n      <Intermediate text=\"where is my son?\" />\n    );\n  }\n});\n\n// 子组件1：中间嵌套的组件\nvar Intermediate = React.createClass({\n  render: function () {\n    return (\n      <Child text={this.props.text} />\n    );\n  }\n});\n\n// 子组件2：子组件1的子组件\nvar Child = React.createClass({\n  render: function () {\n    return (\n      <span>{this.props.text}</span>\n    );\n  }\n});\n```\n### 【子组件】向【父组件】传值\n接下来，我们介绍【子组件】控制自己的 state 然后告诉【父组件】的点击状态，然后在【父组件】中展示出来。因此，我们添加一个 change 事件来做交互。\n```JS\n// 父组件\nvar MyContainer = React.createClass({\n  getInitialState: function () {\n    return {\n      checked: false\n    };\n  },\n  onChildChanged: function (newState) {\n    this.setState({\n      checked: newState\n    });\n  },\n  render: function() {\n    var isChecked = this.state.checked ? 'yes' : 'no';\n    return (\n      <div>\n        <div>Are you checked: {isChecked}</div>\n        <ToggleButton text=\"Toggle me\"\n          initialChecked={this.state.checked}\n          callbackParent={this.onChildChanged}\n          />\n      </div>\n    );\n  }\n});\n\n// 子组件\nvar ToggleButton = React.createClass({\n  getInitialState: function () {\n    return {\n      checked: this.props.initialChecked\n    };\n  },\n  onTextChange: function () {\n    var newState = !this.state.checked;\n    this.setState({\n      checked: newState\n    });\n    // 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值\n    this.props.callbackParent(newState);\n  },\n  render: function () {\n    // 从【父组件】获取的值\n    var text = this.props.text;\n    // 组件自身的状态数据\n    var checked = this.state.checked;\n\n    return (\n        <label>{text}: <input type=\"checkbox\" checked={checked} onChange={this.onTextChange} /></label>\n    );\n  }\n});\n```\n这样做其实是依赖 props 来传递事件的引用，并通过回调的方式来实现的，这样实现不是特别好，但是在没有任何工具的情况下也是一种简单的实现方式\n\n这里会出现一个我们在之前讨论的问题，就是组件有多层嵌套的情况下，你必须要一次传入回调函数给 props 来实现子组件向父组件传值或者操作。\n\n### 兄弟组件之间传值\n当两个组件有相同的父组件时，就称为兄弟组件（堂兄也算的）。按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的`props`。\n\n**方式一**\n通过`props`传递父组件回调函数。\n```JS\nclass Brother1 extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  render(){\n    return (\n      <div>\n        <button onClick={this.props.refresh}>\n            更新兄弟组件\n        </button>\n      </div>\n    )\n  }\n}\nclass Brother2 extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  render(){\n    return (\n      <div>\n         {this.props.text || \"兄弟组件未更新\"}\n      </div>\n    )\n  }\n}\nclass Parent extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n  refresh(){\n    return (e)=>{\n      this.setState({\n        text: \"兄弟组件沟通成功\",\n      })\n    }\n  }\n  render(){\n    return (\n      <div>\n        <h2>兄弟组件沟通</h2>\n        <Brother1 refresh={this.refresh()}/>\n        <Brother2 text={this.state.text}/>\n      </div>\n    )\n  }\n}\n```\n**方式二**\n但是如果组件层次太深，上面的兄弟组件沟通方式就效率低了（不建议组件层次太深）。\nReact提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。\n```JS\nclass Brother1 extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  render(){\n\n    return (\n      <div>\n        <button onClick={this.context.refresh}>\n            更新兄弟组件\n        </button>\n      </div>\n    )\n  }\n}\nBrother1.contextTypes = {\n  refresh: React.PropTypes.any\n}\nclass Brother2 extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  render(){\n    return (\n      <div>\n         {this.context.text || \"兄弟组件未更新\"}\n      </div>\n    )\n  }\n}\nBrother2.contextTypes = {\n  text: React.PropTypes.any\n}\nclass Parent extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {}\n  }\n\n  getChildContext(){\n    return {\n      refresh: this.refresh(),\n          text: this.state.text,\n      }\n    }\n\n  refresh(){\n    return (e)=>{\n      this.setState({\n        text: \"兄弟组件沟通成功\",\n      })\n    }\n  }\n  render(){\n    return (\n      <div>\n        <h2>兄弟组件沟通</h2>\n        <Brother1 />\n        <Brother2 text={this.state.text}/>\n      </div>\n    )\n  }\n}\nParent.childContextTypes = {\n  refresh: React.PropTypes.any,\n  text: React.PropTypes.any,\n}\n```\n### 全局事件\n官网中提到可以使用全局事件来进行组件间的通信，官网推荐Flux（Facebook官方出的），还有Relay、Redux、trandux等第三方类库。这些框架思想都一致，都是统一管理组件state变化情况，达到数据可控目的。\n\n### 总结\n简单的组件交流我们可以使用上面非全局事件的简单方式，但是当项目复杂，组件间层次越来越深，上面的交流方式就不太合适（当然还是要用到的，简单的交流）。强烈建议使用Flux、Relay、Redux、trandux等类库其中一种，这些类库不只适合React，像Angular等都可以使用。\n\n### 参考\n- [ReactJS组件间沟通的一些方法](http://www.alloyteam.com/2016/01/some-methods-of-reactjs-communication-between-components/)\n- [React 数据流管理架构之 Redux 介绍](http://www.alloyteam.com/2015/09/react-redux/)\n","slug":"react-props-and-state-plus","published":1,"updated":"2019-08-15T15:03:33.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjt000qxknwn9b6hioq","content":"<p>组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。</p>\n<a id=\"more\"></a>\n<p>可以分为以下 3 种：</p>\n<ul>\n<li>【父组件】向【子组件】传值；</li>\n<li>【子组件】向【父组件】传值；</li>\n<li>没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间传值）</li>\n</ul>\n<h3 id=\"【父组件】向【子组件】传值\"><a href=\"#【父组件】向【子组件】传值\" class=\"headerlink\" title=\"【父组件】向【子组件】传值\"></a>【父组件】向【子组件】传值</h3><p>父组件更新子组件状态，通过传递<code>props</code>，就可以了。例子如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyContainer = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      checked: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ToggleButton text=<span class=\"string\">\"Toggle me\"</span> checked=&#123;<span class=\"keyword\">this</span>.state.checked&#125; /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ToggleButton = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从【父组件】获取的值</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> checked = <span class=\"keyword\">this</span>.props.checked,</span><br><span class=\"line\">        text = <span class=\"keyword\">this</span>.props.text;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;label&gt;&#123;text&#125;: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">checked</span>=<span class=\"string\">&#123;checked&#125;</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>进一步讨论</p>\n<p>如果组件嵌套层次太深，那么从外到内组件的交流成本就变得很高，通过 props 传递值的优势就不那么明显了。（PS：所以我建议尽可能的减少组件的层次，就像写 HTML 一样，简单清晰的结构更惹人爱）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyContainer = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Intermediate text=<span class=\"string\">\"where is my son?\"</span> /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子组件1：中间嵌套的组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Intermediate = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Child text=&#123;<span class=\"keyword\">this</span>.props.text&#125; /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子组件2：子组件1的子组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Child = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;span&gt;&#123;<span class=\"keyword\">this</span>.props.text&#125;&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"【子组件】向【父组件】传值\"><a href=\"#【子组件】向【父组件】传值\" class=\"headerlink\" title=\"【子组件】向【父组件】传值\"></a>【子组件】向【父组件】传值</h3><p>接下来，我们介绍【子组件】控制自己的 state 然后告诉【父组件】的点击状态，然后在【父组件】中展示出来。因此，我们添加一个 change 事件来做交互。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyContainer = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      checked: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onChildChanged: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newState</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      checked: newState</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isChecked = <span class=\"keyword\">this</span>.state.checked ? <span class=\"string\">'yes'</span> : <span class=\"string\">'no'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div&gt;Are you checked: &#123;isChecked&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;ToggleButton text=\"Toggle me\"</span></span><br><span class=\"line\"><span class=\"regexp\">          initialChecked=&#123;this.state.checked&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          callbackParent=&#123;this.onChildChanged&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 子组件</span></span><br><span class=\"line\"><span class=\"regexp\">var ToggleButton = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  getInitialState: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      checked: this.props.initialChecked</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  onTextChange: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    var newState = !this.state.checked;</span></span><br><span class=\"line\"><span class=\"regexp\">    this.setState(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      checked: newState</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值</span></span><br><span class=\"line\"><span class=\"regexp\">    this.props.callbackParent(newState);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  render: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 从【父组件】获取的值</span></span><br><span class=\"line\"><span class=\"regexp\">    var text = this.props.text;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 组件自身的状态数据</span></span><br><span class=\"line\"><span class=\"regexp\">    var checked = this.state.checked;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;label&gt;&#123;text&#125;: &lt;input type=\"checkbox\" checked=&#123;checked&#125; onChange=&#123;this.onTextChange&#125; /</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这样做其实是依赖 props 来传递事件的引用，并通过回调的方式来实现的，这样实现不是特别好，但是在没有任何工具的情况下也是一种简单的实现方式</p>\n<p>这里会出现一个我们在之前讨论的问题，就是组件有多层嵌套的情况下，你必须要一次传入回调函数给 props 来实现子组件向父组件传值或者操作。</p>\n<h3 id=\"兄弟组件之间传值\"><a href=\"#兄弟组件之间传值\" class=\"headerlink\" title=\"兄弟组件之间传值\"></a>兄弟组件之间传值</h3><p>当两个组件有相同的父组件时，就称为兄弟组件（堂兄也算的）。按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的<code>props</code>。</p>\n<p><strong>方式一</strong><br>通过<code>props</code>传递父组件回调函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brother1</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.props.refresh&#125;&gt;</span><br><span class=\"line\">            更新兄弟组件</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brother2</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">         &#123;<span class=\"keyword\">this</span>.props.text || <span class=\"string\">\"兄弟组件未更新\"</span>&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">class Parent extends React.Component&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  constructor(props)&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    super(props);</span></span><br><span class=\"line\"><span class=\"regexp\">    this.state = &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  refresh()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (e)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      this.setState(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        text: \"兄弟组件沟通成功\",</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  render()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;h2&gt;兄弟组件沟通&lt;/</span>h2&gt;</span><br><span class=\"line\">        &lt;Brother1 refresh=&#123;<span class=\"keyword\">this</span>.refresh()&#125;/&gt;</span><br><span class=\"line\">        &lt;Brother2 text=&#123;<span class=\"keyword\">this</span>.state.text&#125;/&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>方式二</strong><br>但是如果组件层次太深，上面的兄弟组件沟通方式就效率低了（不建议组件层次太深）。<br>React提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brother1</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.context.refresh&#125;&gt;</span><br><span class=\"line\">            更新兄弟组件</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Brother1.contextTypes = &#123;</span><br><span class=\"line\">  refresh: React.PropTypes.any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brother2</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">         &#123;<span class=\"keyword\">this</span>.context.text || <span class=\"string\">\"兄弟组件未更新\"</span>&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">Brother2.contextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  text: React.PropTypes.any</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">class Parent extends React.Component&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  constructor(props)&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    super(props);</span></span><br><span class=\"line\"><span class=\"regexp\">    this.state = &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  getChildContext()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      refresh: this.refresh(),</span></span><br><span class=\"line\"><span class=\"regexp\">          text: this.state.text,</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  refresh()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (e)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      this.setState(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        text: \"兄弟组件沟通成功\",</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  render()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;h2&gt;兄弟组件沟通&lt;/</span>h2&gt;</span><br><span class=\"line\">        &lt;Brother1 /&gt;</span><br><span class=\"line\">        &lt;Brother2 text=&#123;<span class=\"keyword\">this</span>.state.text&#125;/&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">Parent.childContextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  refresh: React.PropTypes.any,</span></span><br><span class=\"line\"><span class=\"regexp\">  text: React.PropTypes.any,</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"全局事件\"><a href=\"#全局事件\" class=\"headerlink\" title=\"全局事件\"></a>全局事件</h3><p>官网中提到可以使用全局事件来进行组件间的通信，官网推荐Flux（Facebook官方出的），还有Relay、Redux、trandux等第三方类库。这些框架思想都一致，都是统一管理组件state变化情况，达到数据可控目的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>简单的组件交流我们可以使用上面非全局事件的简单方式，但是当项目复杂，组件间层次越来越深，上面的交流方式就不太合适（当然还是要用到的，简单的交流）。强烈建议使用Flux、Relay、Redux、trandux等类库其中一种，这些类库不只适合React，像Angular等都可以使用。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.alloyteam.com/2016/01/some-methods-of-reactjs-communication-between-components/\" target=\"_blank\" rel=\"noopener\">ReactJS组件间沟通的一些方法</a></li>\n<li><a href=\"http://www.alloyteam.com/2015/09/react-redux/\" target=\"_blank\" rel=\"noopener\">React 数据流管理架构之 Redux 介绍</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。</p>","more":"<p>可以分为以下 3 种：</p>\n<ul>\n<li>【父组件】向【子组件】传值；</li>\n<li>【子组件】向【父组件】传值；</li>\n<li>没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间传值）</li>\n</ul>\n<h3 id=\"【父组件】向【子组件】传值\"><a href=\"#【父组件】向【子组件】传值\" class=\"headerlink\" title=\"【父组件】向【子组件】传值\"></a>【父组件】向【子组件】传值</h3><p>父组件更新子组件状态，通过传递<code>props</code>，就可以了。例子如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyContainer = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      checked: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ToggleButton text=<span class=\"string\">\"Toggle me\"</span> checked=&#123;<span class=\"keyword\">this</span>.state.checked&#125; /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ToggleButton = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从【父组件】获取的值</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> checked = <span class=\"keyword\">this</span>.props.checked,</span><br><span class=\"line\">        text = <span class=\"keyword\">this</span>.props.text;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;label&gt;&#123;text&#125;: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">checked</span>=<span class=\"string\">&#123;checked&#125;</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>进一步讨论</p>\n<p>如果组件嵌套层次太深，那么从外到内组件的交流成本就变得很高，通过 props 传递值的优势就不那么明显了。（PS：所以我建议尽可能的减少组件的层次，就像写 HTML 一样，简单清晰的结构更惹人爱）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyContainer = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Intermediate text=<span class=\"string\">\"where is my son?\"</span> /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子组件1：中间嵌套的组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Intermediate = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Child text=&#123;<span class=\"keyword\">this</span>.props.text&#125; /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子组件2：子组件1的子组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Child = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;span&gt;&#123;<span class=\"keyword\">this</span>.props.text&#125;&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"【子组件】向【父组件】传值\"><a href=\"#【子组件】向【父组件】传值\" class=\"headerlink\" title=\"【子组件】向【父组件】传值\"></a>【子组件】向【父组件】传值</h3><p>接下来，我们介绍【子组件】控制自己的 state 然后告诉【父组件】的点击状态，然后在【父组件】中展示出来。因此，我们添加一个 change 事件来做交互。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyContainer = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      checked: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  onChildChanged: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newState</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      checked: newState</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isChecked = <span class=\"keyword\">this</span>.state.checked ? <span class=\"string\">'yes'</span> : <span class=\"string\">'no'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div&gt;Are you checked: &#123;isChecked&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;ToggleButton text=\"Toggle me\"</span></span><br><span class=\"line\"><span class=\"regexp\">          initialChecked=&#123;this.state.checked&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          callbackParent=&#123;this.onChildChanged&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">          /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 子组件</span></span><br><span class=\"line\"><span class=\"regexp\">var ToggleButton = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  getInitialState: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      checked: this.props.initialChecked</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  onTextChange: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    var newState = !this.state.checked;</span></span><br><span class=\"line\"><span class=\"regexp\">    this.setState(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      checked: newState</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值</span></span><br><span class=\"line\"><span class=\"regexp\">    this.props.callbackParent(newState);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  render: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 从【父组件】获取的值</span></span><br><span class=\"line\"><span class=\"regexp\">    var text = this.props.text;</span></span><br><span class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 组件自身的状态数据</span></span><br><span class=\"line\"><span class=\"regexp\">    var checked = this.state.checked;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;label&gt;&#123;text&#125;: &lt;input type=\"checkbox\" checked=&#123;checked&#125; onChange=&#123;this.onTextChange&#125; /</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这样做其实是依赖 props 来传递事件的引用，并通过回调的方式来实现的，这样实现不是特别好，但是在没有任何工具的情况下也是一种简单的实现方式</p>\n<p>这里会出现一个我们在之前讨论的问题，就是组件有多层嵌套的情况下，你必须要一次传入回调函数给 props 来实现子组件向父组件传值或者操作。</p>\n<h3 id=\"兄弟组件之间传值\"><a href=\"#兄弟组件之间传值\" class=\"headerlink\" title=\"兄弟组件之间传值\"></a>兄弟组件之间传值</h3><p>当两个组件有相同的父组件时，就称为兄弟组件（堂兄也算的）。按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的<code>props</code>。</p>\n<p><strong>方式一</strong><br>通过<code>props</code>传递父组件回调函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brother1</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.props.refresh&#125;&gt;</span><br><span class=\"line\">            更新兄弟组件</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brother2</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">         &#123;<span class=\"keyword\">this</span>.props.text || <span class=\"string\">\"兄弟组件未更新\"</span>&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">class Parent extends React.Component&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  constructor(props)&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    super(props);</span></span><br><span class=\"line\"><span class=\"regexp\">    this.state = &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  refresh()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (e)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      this.setState(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        text: \"兄弟组件沟通成功\",</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  render()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;h2&gt;兄弟组件沟通&lt;/</span>h2&gt;</span><br><span class=\"line\">        &lt;Brother1 refresh=&#123;<span class=\"keyword\">this</span>.refresh()&#125;/&gt;</span><br><span class=\"line\">        &lt;Brother2 text=&#123;<span class=\"keyword\">this</span>.state.text&#125;/&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>方式二</strong><br>但是如果组件层次太深，上面的兄弟组件沟通方式就效率低了（不建议组件层次太深）。<br>React提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brother1</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.context.refresh&#125;&gt;</span><br><span class=\"line\">            更新兄弟组件</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Brother1.contextTypes = &#123;</span><br><span class=\"line\">  refresh: React.PropTypes.any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brother2</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">         &#123;<span class=\"keyword\">this</span>.context.text || <span class=\"string\">\"兄弟组件未更新\"</span>&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">Brother2.contextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  text: React.PropTypes.any</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">class Parent extends React.Component&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  constructor(props)&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    super(props);</span></span><br><span class=\"line\"><span class=\"regexp\">    this.state = &#123;&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  getChildContext()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      refresh: this.refresh(),</span></span><br><span class=\"line\"><span class=\"regexp\">          text: this.state.text,</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  refresh()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (e)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      this.setState(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        text: \"兄弟组件沟通成功\",</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  render()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;h2&gt;兄弟组件沟通&lt;/</span>h2&gt;</span><br><span class=\"line\">        &lt;Brother1 /&gt;</span><br><span class=\"line\">        &lt;Brother2 text=&#123;<span class=\"keyword\">this</span>.state.text&#125;/&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">Parent.childContextTypes = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  refresh: React.PropTypes.any,</span></span><br><span class=\"line\"><span class=\"regexp\">  text: React.PropTypes.any,</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"全局事件\"><a href=\"#全局事件\" class=\"headerlink\" title=\"全局事件\"></a>全局事件</h3><p>官网中提到可以使用全局事件来进行组件间的通信，官网推荐Flux（Facebook官方出的），还有Relay、Redux、trandux等第三方类库。这些框架思想都一致，都是统一管理组件state变化情况，达到数据可控目的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>简单的组件交流我们可以使用上面非全局事件的简单方式，但是当项目复杂，组件间层次越来越深，上面的交流方式就不太合适（当然还是要用到的，简单的交流）。强烈建议使用Flux、Relay、Redux、trandux等类库其中一种，这些类库不只适合React，像Angular等都可以使用。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.alloyteam.com/2016/01/some-methods-of-reactjs-communication-between-components/\" target=\"_blank\" rel=\"noopener\">ReactJS组件间沟通的一些方法</a></li>\n<li><a href=\"http://www.alloyteam.com/2015/09/react-redux/\" target=\"_blank\" rel=\"noopener\">React 数据流管理架构之 Redux 介绍</a></li>\n</ul>"},{"title":"React 数据流 Props 和 State [基础介绍]","abbrlink":1975,"date":"2016-10-10T11:17:09.000Z","_content":"\n使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。\n\n<!-- more -->\n\n### 数据流\nReact是单向数据流，从父节点传递到子节点（通过`props`）。如果顶层的某个`props`改变了，React会重渲染所有的子节点（未做性能优化）。严格意义上React只提供，也强烈建议使用这种数据交流方式。\n\n### Props\n`props`是`property`的缩写，可以理解为HTML标签的`attribute`。请把`props`当做只读的（不可以使用`this.props`直接修改`props`），`props`是用于整个组件树中传递数据和配置。在当前组件访问`props`，使用`this.props`。\n```JS\nvar HelloWorld = React.createClass({\n    render: function () {\n        return (\n            <div data-title={this.props.title}>{this.props.content}</div>\n        )\n    }\n});\n\nReact.render(\n    <HelloWorld title=\"this is title\" content=\"this is content\"/>,\n    document.body\n);\n```\n\n### state\n每个组件都有属于自己的`state`，`state`和`props`的区别在于前者之只存在于组件内部，只能从当前组件调用`this.setState`修改`state`值（不可以直接修改`this.state`）。一般我们更新子组件都是通过改变`state`值，更新新子组件的`props`值从而达到更新。\n\n那如何设置默认state?\n```JS\n//React提供的crateClass创建方式\nvar Component = React.createClass({\n  getInitialState(){\n    return {\n      //这里设置初始state值\n    }\n  }\n})\n//ES6 && ES7\nclass Component {\n  constructor(){\n    this.state = {}//在ES6中的构造函数中初始化，可以之直接赋值，在其他方法中，只能使用this.setState\n  }\n  ...\n}\n```\n再看一个例子，点击按钮，切换按钮的颜色：\n```\nvar ColorButton = React.createClass({\n    getInitialState: function () {\n        return {bColor: 'green'};\n    },\n    render: function () {\n        return (\n            <button onClick={this.handleClick} style={{backgroundColor: this.state.bColor}}>click</button>\n        )\n    },\n    handleClick: function (event) {\n        this.setState({bColor: this.state.bColor === 'green' ? 'red' : 'green'});\n    }\n});\n\nReact.render(\n    <ColorButton />,\n    document.body\n);\n```\nhandleClick是用来处理我们点击事件的。\n\n### state工作原理\n通过调用setState(data, callback)方法，改变状态，就会触发React更新UI。大部分情况下，我们不需要提供callback函数。React会自动的帮我们更新UI。\n\n### 什么样的组件该有state\n大部分的组件应该从props属性中获取数据并渲染。但有的时候组件得相应用户输入，同服务器交互，这些情况下会用到state。React的官方说法是：**尽可能的保持你的组件无状态化**。为了实现这个目标，得保持你的状态同业务逻辑分离，并减少冗余信息，尽可能保持组件的单一职责。\n\nReact官方推荐的一种模式就是：构建几个无状态的组件用来渲染数据，在这些之上构建一个有状态的组件同用户和服务交互，数据通过props传递给无状态的组件。我的理解大概就是这样：\n```JS\nvar RenderComponent = React.createClass({\n    render: function () {\n        return (\n            <ul>\n                {\n                    this.props['data-list'].map(function (item) {\n                        return (<li>{item}</li>)\n                    })\n                }\n            </ul>\n        )\n    }\n});\n\n\nvar StateComponent = React.createClass({\n    getInitialState: function () {\n        return {list: ['xxx', 'yyy']};\n    },\n    render: function () {\n        return (\n            <div>\n                <button onClick={this.handleClick}>click</button>\n                <RenderComponent data-list={this.state.list}/>\n            </div>\n\n        )\n    },\n    handleClick: function () {\n        this.setState({list: [1, 2, 3]});\n    }\n});\n\nReact.render(\n    <StateComponent />,\n    document.body\n);\n```\nUI交互会导致改变的数据。\nstate不应包含什么样的数据：1.计算过的数据；2.组件；3.从props复制的数据。\nstate应保含最原始的数据，比如说时间，格式化应该交给展现层去做。组件应在render方法里控制。\n\n### props和state使用方式\n<div class=\"tip\">\n尽可能使用props当做数据源，state用来存放状态值（简单的数据），如复选框、下拉菜单等。\n</div>\n","source":"_posts/react-props-and-state.md","raw":"---\ntitle: 'React 数据流 Props 和 State [基础介绍]'\ntags:\n  - react\ncategories:\n  - react\nabbrlink: 1975\ndate: 2016-10-10 19:17:09\n---\n\n使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。\n\n<!-- more -->\n\n### 数据流\nReact是单向数据流，从父节点传递到子节点（通过`props`）。如果顶层的某个`props`改变了，React会重渲染所有的子节点（未做性能优化）。严格意义上React只提供，也强烈建议使用这种数据交流方式。\n\n### Props\n`props`是`property`的缩写，可以理解为HTML标签的`attribute`。请把`props`当做只读的（不可以使用`this.props`直接修改`props`），`props`是用于整个组件树中传递数据和配置。在当前组件访问`props`，使用`this.props`。\n```JS\nvar HelloWorld = React.createClass({\n    render: function () {\n        return (\n            <div data-title={this.props.title}>{this.props.content}</div>\n        )\n    }\n});\n\nReact.render(\n    <HelloWorld title=\"this is title\" content=\"this is content\"/>,\n    document.body\n);\n```\n\n### state\n每个组件都有属于自己的`state`，`state`和`props`的区别在于前者之只存在于组件内部，只能从当前组件调用`this.setState`修改`state`值（不可以直接修改`this.state`）。一般我们更新子组件都是通过改变`state`值，更新新子组件的`props`值从而达到更新。\n\n那如何设置默认state?\n```JS\n//React提供的crateClass创建方式\nvar Component = React.createClass({\n  getInitialState(){\n    return {\n      //这里设置初始state值\n    }\n  }\n})\n//ES6 && ES7\nclass Component {\n  constructor(){\n    this.state = {}//在ES6中的构造函数中初始化，可以之直接赋值，在其他方法中，只能使用this.setState\n  }\n  ...\n}\n```\n再看一个例子，点击按钮，切换按钮的颜色：\n```\nvar ColorButton = React.createClass({\n    getInitialState: function () {\n        return {bColor: 'green'};\n    },\n    render: function () {\n        return (\n            <button onClick={this.handleClick} style={{backgroundColor: this.state.bColor}}>click</button>\n        )\n    },\n    handleClick: function (event) {\n        this.setState({bColor: this.state.bColor === 'green' ? 'red' : 'green'});\n    }\n});\n\nReact.render(\n    <ColorButton />,\n    document.body\n);\n```\nhandleClick是用来处理我们点击事件的。\n\n### state工作原理\n通过调用setState(data, callback)方法，改变状态，就会触发React更新UI。大部分情况下，我们不需要提供callback函数。React会自动的帮我们更新UI。\n\n### 什么样的组件该有state\n大部分的组件应该从props属性中获取数据并渲染。但有的时候组件得相应用户输入，同服务器交互，这些情况下会用到state。React的官方说法是：**尽可能的保持你的组件无状态化**。为了实现这个目标，得保持你的状态同业务逻辑分离，并减少冗余信息，尽可能保持组件的单一职责。\n\nReact官方推荐的一种模式就是：构建几个无状态的组件用来渲染数据，在这些之上构建一个有状态的组件同用户和服务交互，数据通过props传递给无状态的组件。我的理解大概就是这样：\n```JS\nvar RenderComponent = React.createClass({\n    render: function () {\n        return (\n            <ul>\n                {\n                    this.props['data-list'].map(function (item) {\n                        return (<li>{item}</li>)\n                    })\n                }\n            </ul>\n        )\n    }\n});\n\n\nvar StateComponent = React.createClass({\n    getInitialState: function () {\n        return {list: ['xxx', 'yyy']};\n    },\n    render: function () {\n        return (\n            <div>\n                <button onClick={this.handleClick}>click</button>\n                <RenderComponent data-list={this.state.list}/>\n            </div>\n\n        )\n    },\n    handleClick: function () {\n        this.setState({list: [1, 2, 3]});\n    }\n});\n\nReact.render(\n    <StateComponent />,\n    document.body\n);\n```\nUI交互会导致改变的数据。\nstate不应包含什么样的数据：1.计算过的数据；2.组件；3.从props复制的数据。\nstate应保含最原始的数据，比如说时间，格式化应该交给展现层去做。组件应在render方法里控制。\n\n### props和state使用方式\n<div class=\"tip\">\n尽可能使用props当做数据源，state用来存放状态值（简单的数据），如复选框、下拉菜单等。\n</div>\n","slug":"react-props-and-state","published":1,"updated":"2019-08-15T15:03:33.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjv000txknwqadbg0qz","content":"<p>使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。</p>\n<a id=\"more\"></a>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>React是单向数据流，从父节点传递到子节点（通过<code>props</code>）。如果顶层的某个<code>props</code>改变了，React会重渲染所有的子节点（未做性能优化）。严格意义上React只提供，也强烈建议使用这种数据交流方式。</p>\n<h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><p><code>props</code>是<code>property</code>的缩写，可以理解为HTML标签的<code>attribute</code>。请把<code>props</code>当做只读的（不可以使用<code>this.props</code>直接修改<code>props</code>），<code>props</code>是用于整个组件树中传递数据和配置。在当前组件访问<code>props</code>，使用<code>this.props</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloWorld = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div data-title=&#123;<span class=\"keyword\">this</span>.props.title&#125;&gt;&#123;<span class=\"keyword\">this</span>.props.content&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">React.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;HelloWorld title=\"this is title\" content=\"this is content\"/</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p>每个组件都有属于自己的<code>state</code>，<code>state</code>和<code>props</code>的区别在于前者之只存在于组件内部，只能从当前组件调用<code>this.setState</code>修改<code>state</code>值（不可以直接修改<code>this.state</code>）。一般我们更新子组件都是通过改变<code>state</code>值，更新新子组件的<code>props</code>值从而达到更新。</p>\n<p>那如何设置默认state?<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//React提供的crateClass创建方式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Component = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//这里设置初始state值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//ES6 &amp;&amp; ES7</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;<span class=\"comment\">//在ES6中的构造函数中初始化，可以之直接赋值，在其他方法中，只能使用this.setState</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再看一个例子，点击按钮，切换按钮的颜色：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ColorButton = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState: function () &#123;</span><br><span class=\"line\">        return &#123;bColor: &apos;green&apos;&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: function () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;button onClick=&#123;this.handleClick&#125; style=&#123;&#123;backgroundColor: this.state.bColor&#125;&#125;&gt;click&lt;/button&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleClick: function (event) &#123;</span><br><span class=\"line\">        this.setState(&#123;bColor: this.state.bColor === &apos;green&apos; ? &apos;red&apos; : &apos;green&apos;&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">React.render(</span><br><span class=\"line\">    &lt;ColorButton /&gt;,</span><br><span class=\"line\">    document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>handleClick是用来处理我们点击事件的。</p>\n<h3 id=\"state工作原理\"><a href=\"#state工作原理\" class=\"headerlink\" title=\"state工作原理\"></a>state工作原理</h3><p>通过调用setState(data, callback)方法，改变状态，就会触发React更新UI。大部分情况下，我们不需要提供callback函数。React会自动的帮我们更新UI。</p>\n<h3 id=\"什么样的组件该有state\"><a href=\"#什么样的组件该有state\" class=\"headerlink\" title=\"什么样的组件该有state\"></a>什么样的组件该有state</h3><p>大部分的组件应该从props属性中获取数据并渲染。但有的时候组件得相应用户输入，同服务器交互，这些情况下会用到state。React的官方说法是：<strong>尽可能的保持你的组件无状态化</strong>。为了实现这个目标，得保持你的状态同业务逻辑分离，并减少冗余信息，尽可能保持组件的单一职责。</p>\n<p>React官方推荐的一种模式就是：构建几个无状态的组件用来渲染数据，在这些之上构建一个有状态的组件同用户和服务交互，数据通过props传递给无状态的组件。我的理解大概就是这样：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> RenderComponent = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;ul&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.props[<span class=\"string\">'data-list'</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;item&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span>)</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var StateComponent = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    getInitialState: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        return &#123;list: ['xxx', 'yyy']&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">    render: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        return (</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/</span>button&gt;</span><br><span class=\"line\">                &lt;RenderComponent data-list=&#123;<span class=\"keyword\">this</span>.state.list&#125;/&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">    handleClick: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        this.setState(&#123;list: [1, 2, 3]&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">React.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;StateComponent /</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>UI交互会导致改变的数据。<br>state不应包含什么样的数据：1.计算过的数据；2.组件；3.从props复制的数据。<br>state应保含最原始的数据，比如说时间，格式化应该交给展现层去做。组件应在render方法里控制。</p>\n<h3 id=\"props和state使用方式\"><a href=\"#props和state使用方式\" class=\"headerlink\" title=\"props和state使用方式\"></a>props和state使用方式</h3><div class=\"tip\"><br>尽可能使用props当做数据源，state用来存放状态值（简单的数据），如复选框、下拉菜单等。<br></div>\n","site":{"data":{}},"excerpt":"<p>使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。</p>","more":"<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>React是单向数据流，从父节点传递到子节点（通过<code>props</code>）。如果顶层的某个<code>props</code>改变了，React会重渲染所有的子节点（未做性能优化）。严格意义上React只提供，也强烈建议使用这种数据交流方式。</p>\n<h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><p><code>props</code>是<code>property</code>的缩写，可以理解为HTML标签的<code>attribute</code>。请把<code>props</code>当做只读的（不可以使用<code>this.props</code>直接修改<code>props</code>），<code>props</code>是用于整个组件树中传递数据和配置。在当前组件访问<code>props</code>，使用<code>this.props</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloWorld = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div data-title=&#123;<span class=\"keyword\">this</span>.props.title&#125;&gt;&#123;<span class=\"keyword\">this</span>.props.content&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">React.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;HelloWorld title=\"this is title\" content=\"this is content\"/</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p>每个组件都有属于自己的<code>state</code>，<code>state</code>和<code>props</code>的区别在于前者之只存在于组件内部，只能从当前组件调用<code>this.setState</code>修改<code>state</code>值（不可以直接修改<code>this.state</code>）。一般我们更新子组件都是通过改变<code>state</code>值，更新新子组件的<code>props</code>值从而达到更新。</p>\n<p>那如何设置默认state?<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//React提供的crateClass创建方式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Component = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//这里设置初始state值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//ES6 &amp;&amp; ES7</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;<span class=\"comment\">//在ES6中的构造函数中初始化，可以之直接赋值，在其他方法中，只能使用this.setState</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再看一个例子，点击按钮，切换按钮的颜色：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ColorButton = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState: function () &#123;</span><br><span class=\"line\">        return &#123;bColor: &apos;green&apos;&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: function () &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;button onClick=&#123;this.handleClick&#125; style=&#123;&#123;backgroundColor: this.state.bColor&#125;&#125;&gt;click&lt;/button&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleClick: function (event) &#123;</span><br><span class=\"line\">        this.setState(&#123;bColor: this.state.bColor === &apos;green&apos; ? &apos;red&apos; : &apos;green&apos;&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">React.render(</span><br><span class=\"line\">    &lt;ColorButton /&gt;,</span><br><span class=\"line\">    document.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>handleClick是用来处理我们点击事件的。</p>\n<h3 id=\"state工作原理\"><a href=\"#state工作原理\" class=\"headerlink\" title=\"state工作原理\"></a>state工作原理</h3><p>通过调用setState(data, callback)方法，改变状态，就会触发React更新UI。大部分情况下，我们不需要提供callback函数。React会自动的帮我们更新UI。</p>\n<h3 id=\"什么样的组件该有state\"><a href=\"#什么样的组件该有state\" class=\"headerlink\" title=\"什么样的组件该有state\"></a>什么样的组件该有state</h3><p>大部分的组件应该从props属性中获取数据并渲染。但有的时候组件得相应用户输入，同服务器交互，这些情况下会用到state。React的官方说法是：<strong>尽可能的保持你的组件无状态化</strong>。为了实现这个目标，得保持你的状态同业务逻辑分离，并减少冗余信息，尽可能保持组件的单一职责。</p>\n<p>React官方推荐的一种模式就是：构建几个无状态的组件用来渲染数据，在这些之上构建一个有状态的组件同用户和服务交互，数据通过props传递给无状态的组件。我的理解大概就是这样：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> RenderComponent = React.createClass(&#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;ul&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.props[<span class=\"string\">'data-list'</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&#123;item&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span>)</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">var StateComponent = React.createClass(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    getInitialState: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        return &#123;list: ['xxx', 'yyy']&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">    render: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        return (</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/</span>button&gt;</span><br><span class=\"line\">                &lt;RenderComponent data-list=&#123;<span class=\"keyword\">this</span>.state.list&#125;/&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">    handleClick: function () &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        this.setState(&#123;list: [1, 2, 3]&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">React.render(</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;StateComponent /</span>&gt;,</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>UI交互会导致改变的数据。<br>state不应包含什么样的数据：1.计算过的数据；2.组件；3.从props复制的数据。<br>state应保含最原始的数据，比如说时间，格式化应该交给展现层去做。组件应在render方法里控制。</p>\n<h3 id=\"props和state使用方式\"><a href=\"#props和state使用方式\" class=\"headerlink\" title=\"props和state使用方式\"></a>props和state使用方式</h3><div class=\"tip\"><br>尽可能使用props当做数据源，state用来存放状态值（简单的数据），如复选框、下拉菜单等。<br></div>"},{"title":"React 操作真实 DOM","abbrlink":31953,"date":"2016-10-20T12:18:07.000Z","_content":"React中的每一个组件都是一个状态机，通常情况下，我们通过设置组件的状态就可以完成UI的更新，但是在某些情况下确实需要直接操作DOM。\n<!--more-->\nReact 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。\n\n- ref : 绑定属性\n- refs : 调用的时候使用\n\n## 获取DOM实例\n通过ref属性，你可获取实例中的属性方法，甚至可以通过他获取到DOM实例节点 `this.refs.xx.getDOMNode()`\n\n**ref 属性绑定**\n```\n<input type=\"text\" ref=\"myInput\" />\n```\n**refs 获取DOM实例**\n获取支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。\n```\n// 输入框获取焦点\nthis.refs.myInput.focus()\n```\n**示例**\n```\nimport React, { Component } from 'react';\nclass MyComponent extends Component {\n  handleClick(){\n    this.refs.myInput.focus();\n  }\n  render(){\n    return(\n      <div>\n        <input\n          type=\"text\"\n          ref=\"myInput\"\n        />\n        <input\n          type=\"button\"\n          value=\"点我输入框获取焦点\"\n          onClick={this.handleClick.bind(this)}\n        />\n      </div>\n    )\n  }\n}\n\nReactDOM.render(\n  <MyComponent/>,\n  document.querySelector('#app')\n);\n```\n获取`myInput`真实DOM的值：\n```\nvar myInput = this.refs.myInput.props.value;\n```\n","source":"_posts/react-use-dmo-refs.md","raw":"---\ntitle: React 操作真实 DOM\ntags: react\ncategories: react\nabbrlink: 31953\ndate: 2016-10-20 20:18:07\n---\nReact中的每一个组件都是一个状态机，通常情况下，我们通过设置组件的状态就可以完成UI的更新，但是在某些情况下确实需要直接操作DOM。\n<!--more-->\nReact 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。\n\n- ref : 绑定属性\n- refs : 调用的时候使用\n\n## 获取DOM实例\n通过ref属性，你可获取实例中的属性方法，甚至可以通过他获取到DOM实例节点 `this.refs.xx.getDOMNode()`\n\n**ref 属性绑定**\n```\n<input type=\"text\" ref=\"myInput\" />\n```\n**refs 获取DOM实例**\n获取支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。\n```\n// 输入框获取焦点\nthis.refs.myInput.focus()\n```\n**示例**\n```\nimport React, { Component } from 'react';\nclass MyComponent extends Component {\n  handleClick(){\n    this.refs.myInput.focus();\n  }\n  render(){\n    return(\n      <div>\n        <input\n          type=\"text\"\n          ref=\"myInput\"\n        />\n        <input\n          type=\"button\"\n          value=\"点我输入框获取焦点\"\n          onClick={this.handleClick.bind(this)}\n        />\n      </div>\n    )\n  }\n}\n\nReactDOM.render(\n  <MyComponent/>,\n  document.querySelector('#app')\n);\n```\n获取`myInput`真实DOM的值：\n```\nvar myInput = this.refs.myInput.props.value;\n```\n","slug":"react-use-dmo-refs","published":1,"updated":"2019-08-15T15:03:33.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjx000wxknw04v21qt1","content":"<p>React中的每一个组件都是一个状态机，通常情况下，我们通过设置组件的状态就可以完成UI的更新，但是在某些情况下确实需要直接操作DOM。<br><a id=\"more\"></a><br>React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。</p>\n<ul>\n<li>ref : 绑定属性</li>\n<li>refs : 调用的时候使用</li>\n</ul>\n<h2 id=\"获取DOM实例\"><a href=\"#获取DOM实例\" class=\"headerlink\" title=\"获取DOM实例\"></a>获取DOM实例</h2><p>通过ref属性，你可获取实例中的属性方法，甚至可以通过他获取到DOM实例节点 <code>this.refs.xx.getDOMNode()</code></p>\n<p><strong>ref 属性绑定</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>refs 获取DOM实例</strong><br>获取支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输入框获取焦点</span><br><span class=\"line\">this.refs.myInput.focus()</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">class MyComponent extends Component &#123;</span><br><span class=\"line\">  handleClick()&#123;</span><br><span class=\"line\">    this.refs.myInput.focus();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          type=&quot;text&quot;</span><br><span class=\"line\">          ref=&quot;myInput&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          type=&quot;button&quot;</span><br><span class=\"line\">          value=&quot;点我输入框获取焦点&quot;</span><br><span class=\"line\">          onClick=&#123;this.handleClick.bind(this)&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;MyComponent/&gt;,</span><br><span class=\"line\">  document.querySelector(&apos;#app&apos;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>获取<code>myInput</code>真实DOM的值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myInput = this.refs.myInput.props.value;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>React中的每一个组件都是一个状态机，通常情况下，我们通过设置组件的状态就可以完成UI的更新，但是在某些情况下确实需要直接操作DOM。<br>","more":"<br>React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。</p>\n<ul>\n<li>ref : 绑定属性</li>\n<li>refs : 调用的时候使用</li>\n</ul>\n<h2 id=\"获取DOM实例\"><a href=\"#获取DOM实例\" class=\"headerlink\" title=\"获取DOM实例\"></a>获取DOM实例</h2><p>通过ref属性，你可获取实例中的属性方法，甚至可以通过他获取到DOM实例节点 <code>this.refs.xx.getDOMNode()</code></p>\n<p><strong>ref 属性绑定</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>refs 获取DOM实例</strong><br>获取支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输入框获取焦点</span><br><span class=\"line\">this.refs.myInput.focus()</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">class MyComponent extends Component &#123;</span><br><span class=\"line\">  handleClick()&#123;</span><br><span class=\"line\">    this.refs.myInput.focus();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          type=&quot;text&quot;</span><br><span class=\"line\">          ref=&quot;myInput&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">        &lt;input</span><br><span class=\"line\">          type=&quot;button&quot;</span><br><span class=\"line\">          value=&quot;点我输入框获取焦点&quot;</span><br><span class=\"line\">          onClick=&#123;this.handleClick.bind(this)&#125;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;MyComponent/&gt;,</span><br><span class=\"line\">  document.querySelector(&apos;#app&apos;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>获取<code>myInput</code>真实DOM的值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myInput = this.refs.myInput.props.value;</span><br></pre></td></tr></table></figure></p>"},{"title":"redux 基础","abbrlink":64007,"date":"2016-12-08T14:01:25.000Z","_content":"### Store\nStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。\nRedux 提供createStore这个函数，用来生成 Store。\n<!--more-->\n```\nimport { createStore } from 'redux';\nconst store = createStore(fn);\n```\n上面createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。\n\n\n### State\nStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。\n当前时刻的 State，可以通过store.getState()拿到。\n```\nconst state = store.getState();\n```\nRedux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。\n\n\n### Action\n```\nAction 是一个对象。其中的type属性是必须的，表示 Action 的名称\nconst action = {\n  type: 'ADD_TODO',\n  payload: 'Learn Redux'\n};\n```\nAction 的名称是ADD_TODO，它携带的信息是字符串Learn Redux\n可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。\n\n\n### Action Creator\n可以定义一个函数来生成Action，这个函数叫Action Creator\n```\nconst ADD_TODO = '添加 TODO';\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\nconst action = addTodo('Learn Redux');\n```\n上面代码中，add Todo就是一个Action Creator\n\n\n### store.dispatch()\nstore.dispatch()是view发出Action的唯一方法\n```\nimport { createStore } from 'redux';\nconst store = createStore(fn)\n\n store.dispatch({\n     type: 'ADD_TODO',\n     payload: 'Learn Redux'\n })\n```\n 结合\n```\nstore.dispatch(addTodo('Learn Redux'))\n```\n\n\n### Reducer\nStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会有变化。这种 State 的计算过程叫做 Reducer\n是一个函数，它能接受 Action 和 当前 State 作为参数，返回新的 State。\n```\nconst reducer = function(action, state) {\n  return newState;\n}\n```\nstore.dispatch 会触发reducer自动执行，做法就是在生成store的时候，将reducer传入createStore方法。\n```\nconst store = createStore(reducer);\n```\n\n\n### store.subscribe()\nStore 允许使用 store.subcribe() 设置为监听函数，一旦 State 发生变化，就自动执行这个函数。\n```\nimport { createStore } from 'redux';\nconst store = createStore(reducer);\nstore.subscribe(listener);\n```\n只要把view的更新函数放入listener，就会实现view的自动渲染。\n\nstore.subscribe 方法返回一个函数，调用这个函数就可以解除\n```\nlet unsubscribe = store.subscribe(() =>\n  console.log(store.getState())\n )\nunsubscribe()\n```\n\n### Store 的实现\n提供了三个方法\n- store.getState()\n- store.dispatch()\n- store.subscrobe()\n```\nimport { createStore } from 'redux';\nlet { getState, dispatch, subscribe } = createStore(reducer);\n```\n\n### Reducer 拆分\nRedux 提供了 combineReducers 方法拆分 Reducer\n```\nimport { combineReducers } from 'redux';\nconst reduer = combineReducers({\n  a: doSomethingsWidthA,\n  b: processB,\n  c: c\n})\n```\n把子reducer放在一个文件里，然后统一引入\n```\nimport { createStore } from 'redux'\nimport * as reducers from './reducers'\nconst reducer = combineReducers(reducers)\n```\n","source":"_posts/redux-basics.md","raw":"---\ntitle: redux 基础\ntags: redux\nabbrlink: 64007\ndate: 2016-12-08 22:01:25\ncategories:\n---\n### Store\nStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。\nRedux 提供createStore这个函数，用来生成 Store。\n<!--more-->\n```\nimport { createStore } from 'redux';\nconst store = createStore(fn);\n```\n上面createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。\n\n\n### State\nStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。\n当前时刻的 State，可以通过store.getState()拿到。\n```\nconst state = store.getState();\n```\nRedux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。\n\n\n### Action\n```\nAction 是一个对象。其中的type属性是必须的，表示 Action 的名称\nconst action = {\n  type: 'ADD_TODO',\n  payload: 'Learn Redux'\n};\n```\nAction 的名称是ADD_TODO，它携带的信息是字符串Learn Redux\n可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。\n\n\n### Action Creator\n可以定义一个函数来生成Action，这个函数叫Action Creator\n```\nconst ADD_TODO = '添加 TODO';\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\nconst action = addTodo('Learn Redux');\n```\n上面代码中，add Todo就是一个Action Creator\n\n\n### store.dispatch()\nstore.dispatch()是view发出Action的唯一方法\n```\nimport { createStore } from 'redux';\nconst store = createStore(fn)\n\n store.dispatch({\n     type: 'ADD_TODO',\n     payload: 'Learn Redux'\n })\n```\n 结合\n```\nstore.dispatch(addTodo('Learn Redux'))\n```\n\n\n### Reducer\nStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会有变化。这种 State 的计算过程叫做 Reducer\n是一个函数，它能接受 Action 和 当前 State 作为参数，返回新的 State。\n```\nconst reducer = function(action, state) {\n  return newState;\n}\n```\nstore.dispatch 会触发reducer自动执行，做法就是在生成store的时候，将reducer传入createStore方法。\n```\nconst store = createStore(reducer);\n```\n\n\n### store.subscribe()\nStore 允许使用 store.subcribe() 设置为监听函数，一旦 State 发生变化，就自动执行这个函数。\n```\nimport { createStore } from 'redux';\nconst store = createStore(reducer);\nstore.subscribe(listener);\n```\n只要把view的更新函数放入listener，就会实现view的自动渲染。\n\nstore.subscribe 方法返回一个函数，调用这个函数就可以解除\n```\nlet unsubscribe = store.subscribe(() =>\n  console.log(store.getState())\n )\nunsubscribe()\n```\n\n### Store 的实现\n提供了三个方法\n- store.getState()\n- store.dispatch()\n- store.subscrobe()\n```\nimport { createStore } from 'redux';\nlet { getState, dispatch, subscribe } = createStore(reducer);\n```\n\n### Reducer 拆分\nRedux 提供了 combineReducers 方法拆分 Reducer\n```\nimport { combineReducers } from 'redux';\nconst reduer = combineReducers({\n  a: doSomethingsWidthA,\n  b: processB,\n  c: c\n})\n```\n把子reducer放在一个文件里，然后统一引入\n```\nimport { createStore } from 'redux'\nimport * as reducers from './reducers'\nconst reducer = combineReducers(reducers)\n```\n","slug":"redux-basics","published":1,"updated":"2019-08-15T15:03:33.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhjy000yxknws7l7mxu5","content":"<h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。<br>Redux 提供createStore这个函数，用来生成 Store。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\">const store = createStore(fn);</span><br></pre></td></tr></table></figure></p>\n<p>上面createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。<br>当前时刻的 State，可以通过store.getState()拿到。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const state = store.getState();</span><br></pre></td></tr></table></figure></p>\n<p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Action 是一个对象。其中的type属性是必须的，表示 Action 的名称</span><br><span class=\"line\">const action = &#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  payload: &apos;Learn Redux&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux<br>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>\n<h3 id=\"Action-Creator\"><a href=\"#Action-Creator\" class=\"headerlink\" title=\"Action Creator\"></a>Action Creator</h3><p>可以定义一个函数来生成Action，这个函数叫Action Creator<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ADD_TODO = &apos;添加 TODO&apos;;</span><br><span class=\"line\">function addTodo(text) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const action = addTodo(&apos;Learn Redux&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，add Todo就是一个Action Creator</p>\n<h3 id=\"store-dispatch\"><a href=\"#store-dispatch\" class=\"headerlink\" title=\"store.dispatch()\"></a>store.dispatch()</h3><p>store.dispatch()是view发出Action的唯一方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\">const store = createStore(fn)</span><br><span class=\"line\"></span><br><span class=\"line\"> store.dispatch(&#123;</span><br><span class=\"line\">     type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">     payload: &apos;Learn Redux&apos;</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure></p>\n<p> 结合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(addTodo(&apos;Learn Redux&apos;))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h3><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会有变化。这种 State 的计算过程叫做 Reducer<br>是一个函数，它能接受 Action 和 当前 State 作为参数，返回新的 State。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reducer = function(action, state) &#123;</span><br><span class=\"line\">  return newState;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>store.dispatch 会触发reducer自动执行，做法就是在生成store的时候，将reducer传入createStore方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = createStore(reducer);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"store-subscribe\"><a href=\"#store-subscribe\" class=\"headerlink\" title=\"store.subscribe()\"></a>store.subscribe()</h3><p>Store 允许使用 store.subcribe() 设置为监听函数，一旦 State 发生变化，就自动执行这个函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\">const store = createStore(reducer);</span><br><span class=\"line\">store.subscribe(listener);</span><br></pre></td></tr></table></figure></p>\n<p>只要把view的更新函数放入listener，就会实现view的自动渲染。</p>\n<p>store.subscribe 方法返回一个函数，调用这个函数就可以解除<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let unsubscribe = store.subscribe(() =&gt;</span><br><span class=\"line\">  console.log(store.getState())</span><br><span class=\"line\"> )</span><br><span class=\"line\">unsubscribe()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Store-的实现\"><a href=\"#Store-的实现\" class=\"headerlink\" title=\"Store 的实现\"></a>Store 的实现</h3><p>提供了三个方法</p>\n<ul>\n<li>store.getState()</li>\n<li>store.dispatch()</li>\n<li>store.subscrobe()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\">let &#123; getState, dispatch, subscribe &#125; = createStore(reducer);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Reducer-拆分\"><a href=\"#Reducer-拆分\" class=\"headerlink\" title=\"Reducer 拆分\"></a>Reducer 拆分</h3><p>Redux 提供了 combineReducers 方法拆分 Reducer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class=\"line\">const reduer = combineReducers(&#123;</span><br><span class=\"line\">  a: doSomethingsWidthA,</span><br><span class=\"line\">  b: processB,</span><br><span class=\"line\">  c: c</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>把子reducer放在一个文件里，然后统一引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class=\"line\">import * as reducers from &apos;./reducers&apos;</span><br><span class=\"line\">const reducer = combineReducers(reducers)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。<br>Redux 提供createStore这个函数，用来生成 Store。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\">const store = createStore(fn);</span><br></pre></td></tr></table></figure></p>\n<p>上面createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。<br>当前时刻的 State，可以通过store.getState()拿到。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const state = store.getState();</span><br></pre></td></tr></table></figure></p>\n<p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Action 是一个对象。其中的type属性是必须的，表示 Action 的名称</span><br><span class=\"line\">const action = &#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  payload: &apos;Learn Redux&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux<br>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>\n<h3 id=\"Action-Creator\"><a href=\"#Action-Creator\" class=\"headerlink\" title=\"Action Creator\"></a>Action Creator</h3><p>可以定义一个函数来生成Action，这个函数叫Action Creator<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ADD_TODO = &apos;添加 TODO&apos;;</span><br><span class=\"line\">function addTodo(text) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const action = addTodo(&apos;Learn Redux&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，add Todo就是一个Action Creator</p>\n<h3 id=\"store-dispatch\"><a href=\"#store-dispatch\" class=\"headerlink\" title=\"store.dispatch()\"></a>store.dispatch()</h3><p>store.dispatch()是view发出Action的唯一方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\">const store = createStore(fn)</span><br><span class=\"line\"></span><br><span class=\"line\"> store.dispatch(&#123;</span><br><span class=\"line\">     type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">     payload: &apos;Learn Redux&apos;</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure></p>\n<p> 结合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(addTodo(&apos;Learn Redux&apos;))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h3><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会有变化。这种 State 的计算过程叫做 Reducer<br>是一个函数，它能接受 Action 和 当前 State 作为参数，返回新的 State。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reducer = function(action, state) &#123;</span><br><span class=\"line\">  return newState;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>store.dispatch 会触发reducer自动执行，做法就是在生成store的时候，将reducer传入createStore方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = createStore(reducer);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"store-subscribe\"><a href=\"#store-subscribe\" class=\"headerlink\" title=\"store.subscribe()\"></a>store.subscribe()</h3><p>Store 允许使用 store.subcribe() 设置为监听函数，一旦 State 发生变化，就自动执行这个函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\">const store = createStore(reducer);</span><br><span class=\"line\">store.subscribe(listener);</span><br></pre></td></tr></table></figure></p>\n<p>只要把view的更新函数放入listener，就会实现view的自动渲染。</p>\n<p>store.subscribe 方法返回一个函数，调用这个函数就可以解除<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let unsubscribe = store.subscribe(() =&gt;</span><br><span class=\"line\">  console.log(store.getState())</span><br><span class=\"line\"> )</span><br><span class=\"line\">unsubscribe()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Store-的实现\"><a href=\"#Store-的实现\" class=\"headerlink\" title=\"Store 的实现\"></a>Store 的实现</h3><p>提供了三个方法</p>\n<ul>\n<li>store.getState()</li>\n<li>store.dispatch()</li>\n<li>store.subscrobe()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class=\"line\">let &#123; getState, dispatch, subscribe &#125; = createStore(reducer);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Reducer-拆分\"><a href=\"#Reducer-拆分\" class=\"headerlink\" title=\"Reducer 拆分\"></a>Reducer 拆分</h3><p>Redux 提供了 combineReducers 方法拆分 Reducer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class=\"line\">const reduer = combineReducers(&#123;</span><br><span class=\"line\">  a: doSomethingsWidthA,</span><br><span class=\"line\">  b: processB,</span><br><span class=\"line\">  c: c</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>把子reducer放在一个文件里，然后统一引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class=\"line\">import * as reducers from &apos;./reducers&apos;</span><br><span class=\"line\">const reducer = combineReducers(reducers)</span><br></pre></td></tr></table></figure></p>"},{"title":"在 Linux 服务器上安装 node [搭建内部npm]","abbrlink":24595,"date":"2016-11-03T12:37:40.000Z","_content":"这周的工作任务是在 Linux 上搭建私人内部 npm，虽然网上很多教程，但是很多我缺踩了很多未知的坑，以此记录一下。\n<!--more-->\n**搭建私人npm大概有一下方法：**\n\n- 用 [sinopia](https://github.com/rlidwka/sinopia) 安装；\n- 淘宝  [cnpm](https://github.com/cnpm/cnpmjs.org) 安装。\n\n`cnpm` 涉及到数据库mysql，弃之。\n\n## 安装 node\n因为我的linux服务器无法连接外网，所以只能先连接外网下载好[node](https://nodejs.org/dist/latest-v4.x/)源码，然后再用sftp上传到服务器上，这里我下载的是：node-v4.6.1-linux-x64.tar.gz。\n上传成功后，cd到该目录下，进行解压，并且cd进去：\n```Shell\n$ tar xvf node-v4.6.1-linux-x64.tar.gz\n$ cd node-v4.6.1-linux-x64\n```\n安装：\n```Shell\n./configure\n```\n测试是否安装成功：\n```\n./bin/node -v\n```\n此时成功的话会出现4.6.1。\n接下来设置为全局：\n```\nln -s /home/node-v4.6.1-linux-x64/bin/node /usr/local/bin/node\nln -s /home/node-v4.6.1-linux-x64/bin/npm /usr/local/bin/npm\n```\n这里/home/这个路径是你自己放的，你将node文件解压到哪里就是哪里。\n```\n$ node -v\n```\n出现4.6.1，OK。此时设置全局完成。\n","source":"_posts/linux-nodejs.md","raw":"---\ntitle: '在 Linux 服务器上安装 node [搭建内部npm]'\ntags:\n  - linux\n  - node\nabbrlink: 24595\ndate: 2016-11-03 20:37:40\ncategories:\n---\n这周的工作任务是在 Linux 上搭建私人内部 npm，虽然网上很多教程，但是很多我缺踩了很多未知的坑，以此记录一下。\n<!--more-->\n**搭建私人npm大概有一下方法：**\n\n- 用 [sinopia](https://github.com/rlidwka/sinopia) 安装；\n- 淘宝  [cnpm](https://github.com/cnpm/cnpmjs.org) 安装。\n\n`cnpm` 涉及到数据库mysql，弃之。\n\n## 安装 node\n因为我的linux服务器无法连接外网，所以只能先连接外网下载好[node](https://nodejs.org/dist/latest-v4.x/)源码，然后再用sftp上传到服务器上，这里我下载的是：node-v4.6.1-linux-x64.tar.gz。\n上传成功后，cd到该目录下，进行解压，并且cd进去：\n```Shell\n$ tar xvf node-v4.6.1-linux-x64.tar.gz\n$ cd node-v4.6.1-linux-x64\n```\n安装：\n```Shell\n./configure\n```\n测试是否安装成功：\n```\n./bin/node -v\n```\n此时成功的话会出现4.6.1。\n接下来设置为全局：\n```\nln -s /home/node-v4.6.1-linux-x64/bin/node /usr/local/bin/node\nln -s /home/node-v4.6.1-linux-x64/bin/npm /usr/local/bin/npm\n```\n这里/home/这个路径是你自己放的，你将node文件解压到哪里就是哪里。\n```\n$ node -v\n```\n出现4.6.1，OK。此时设置全局完成。\n","slug":"linux-nodejs","published":1,"updated":"2019-08-15T15:03:33.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhk00012xknwfglyyrsy","content":"<p>这周的工作任务是在 Linux 上搭建私人内部 npm，虽然网上很多教程，但是很多我缺踩了很多未知的坑，以此记录一下。<br><a id=\"more\"></a><br><strong>搭建私人npm大概有一下方法：</strong></p>\n<ul>\n<li>用 <a href=\"https://github.com/rlidwka/sinopia\" target=\"_blank\" rel=\"noopener\">sinopia</a> 安装；</li>\n<li>淘宝  <a href=\"https://github.com/cnpm/cnpmjs.org\" target=\"_blank\" rel=\"noopener\">cnpm</a> 安装。</li>\n</ul>\n<p><code>cnpm</code> 涉及到数据库mysql，弃之。</p>\n<h2 id=\"安装-node\"><a href=\"#安装-node\" class=\"headerlink\" title=\"安装 node\"></a>安装 node</h2><p>因为我的linux服务器无法连接外网，所以只能先连接外网下载好<a href=\"https://nodejs.org/dist/latest-v4.x/\" target=\"_blank\" rel=\"noopener\">node</a>源码，然后再用sftp上传到服务器上，这里我下载的是：node-v4.6.1-linux-x64.tar.gz。<br>上传成功后，cd到该目录下，进行解压，并且cd进去：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar xvf node-v4.6.1-linux-x64.tar.gz</span><br><span class=\"line\"><span class=\"meta\">$</span> cd node-v4.6.1-linux-x64</span><br></pre></td></tr></table></figure></p>\n<p>安装：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure></p>\n<p>测试是否安装成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/node -v</span><br></pre></td></tr></table></figure></p>\n<p>此时成功的话会出现4.6.1。<br>接下来设置为全局：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /home/node-v4.6.1-linux-x64/bin/node /usr/local/bin/node</span><br><span class=\"line\">ln -s /home/node-v4.6.1-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></p>\n<p>这里/home/这个路径是你自己放的，你将node文件解压到哪里就是哪里。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure></p>\n<p>出现4.6.1，OK。此时设置全局完成。</p>\n","site":{"data":{}},"excerpt":"<p>这周的工作任务是在 Linux 上搭建私人内部 npm，虽然网上很多教程，但是很多我缺踩了很多未知的坑，以此记录一下。<br>","more":"<br><strong>搭建私人npm大概有一下方法：</strong></p>\n<ul>\n<li>用 <a href=\"https://github.com/rlidwka/sinopia\" target=\"_blank\" rel=\"noopener\">sinopia</a> 安装；</li>\n<li>淘宝  <a href=\"https://github.com/cnpm/cnpmjs.org\" target=\"_blank\" rel=\"noopener\">cnpm</a> 安装。</li>\n</ul>\n<p><code>cnpm</code> 涉及到数据库mysql，弃之。</p>\n<h2 id=\"安装-node\"><a href=\"#安装-node\" class=\"headerlink\" title=\"安装 node\"></a>安装 node</h2><p>因为我的linux服务器无法连接外网，所以只能先连接外网下载好<a href=\"https://nodejs.org/dist/latest-v4.x/\" target=\"_blank\" rel=\"noopener\">node</a>源码，然后再用sftp上传到服务器上，这里我下载的是：node-v4.6.1-linux-x64.tar.gz。<br>上传成功后，cd到该目录下，进行解压，并且cd进去：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> tar xvf node-v4.6.1-linux-x64.tar.gz</span><br><span class=\"line\"><span class=\"meta\">$</span> cd node-v4.6.1-linux-x64</span><br></pre></td></tr></table></figure></p>\n<p>安装：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure></p>\n<p>测试是否安装成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./bin/node -v</span><br></pre></td></tr></table></figure></p>\n<p>此时成功的话会出现4.6.1。<br>接下来设置为全局：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /home/node-v4.6.1-linux-x64/bin/node /usr/local/bin/node</span><br><span class=\"line\">ln -s /home/node-v4.6.1-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></p>\n<p>这里/home/这个路径是你自己放的，你将node文件解压到哪里就是哪里。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure></p>\n<p>出现4.6.1，OK。此时设置全局完成。</p>"},{"title":"webpack基本使用配置[基础篇]","abbrlink":33486,"date":"2016-10-08T12:28:47.000Z","_content":"\n<div class=\"foreword\">webpack是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。还可以结合gulp使用，不冲突。\n</div>\n\n<!-- more -->\n\n### webpack优势\n- 模块来源广泛，支持包括npm/bower等等的各种主流模块安装／依赖解决方案；\n- 模块化规范支持全面，AMD/CommonJS一应具全；\n- 插件机制完善，实现本身实现同样模块化，容易扩展；\n- Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。\n\n### 安装\n首先要安装 [Node.js](http://nodejs.org)， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。\n用 npm 全局安装 Webpack：\n``` javascript\n$ npm install webpack -g\n```\n初始化配置文件 package.json ：\n```\n$ npm init\n```\n到项目目录安装，将 webpack 添加到 package.json ：\n```\n$ npm install webpack --save-dev\n```\n### webpack常用命令\n- webpack 最基本的启动webpack命令\n- webpack -w 提供watch方法，实时进行打包更新\n- webpack -p 对打包后的文件进行压缩\n- webpack -d 提供SourceMaps，方便调试\n- webpack --colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤\n- webpack --profile 输出性能数据，可以看到每一步的耗时\n- webpack --display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块\n\n前面的四个命令比较基础，使用频率会比较大，后面的命令主要是用来定位打包时间较长的原因，方便改进配置文件，提高打包效率。\n\n### 例子\n首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：\n```\n<!-- index.html -->\n<html>\n<body>\n  <script src=\"bundle.js\"></script>\n</body>\n</html>\n```\n```\n// entry.js\ndocument.write('It works.')\n```\n然后编译 entry.js 并打包到 bundle.js：\n```\n$ webpack entry.js bundle.js\n```\n打包过程会显示日志：\n```\nHash: e964f90ec65eb2c29bb9\nVersion: webpack 1.12.2\nTime: 54ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  1.42 kB       0  [emitted]  main\n   [0] ./entry.js 27 bytes {0} [built]\n```\n用浏览器打开 index.html 将会看到 It works.\n","source":"_posts/webpack-use-expo.md","raw":"---\ntitle: 'webpack基本使用配置[基础篇]'\ntags:\n  - webpack\nabbrlink: 33486\ndate: 2016-10-08 20:28:47\n---\n\n<div class=\"foreword\">webpack是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。还可以结合gulp使用，不冲突。\n</div>\n\n<!-- more -->\n\n### webpack优势\n- 模块来源广泛，支持包括npm/bower等等的各种主流模块安装／依赖解决方案；\n- 模块化规范支持全面，AMD/CommonJS一应具全；\n- 插件机制完善，实现本身实现同样模块化，容易扩展；\n- Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。\n\n### 安装\n首先要安装 [Node.js](http://nodejs.org)， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。\n用 npm 全局安装 Webpack：\n``` javascript\n$ npm install webpack -g\n```\n初始化配置文件 package.json ：\n```\n$ npm init\n```\n到项目目录安装，将 webpack 添加到 package.json ：\n```\n$ npm install webpack --save-dev\n```\n### webpack常用命令\n- webpack 最基本的启动webpack命令\n- webpack -w 提供watch方法，实时进行打包更新\n- webpack -p 对打包后的文件进行压缩\n- webpack -d 提供SourceMaps，方便调试\n- webpack --colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤\n- webpack --profile 输出性能数据，可以看到每一步的耗时\n- webpack --display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块\n\n前面的四个命令比较基础，使用频率会比较大，后面的命令主要是用来定位打包时间较长的原因，方便改进配置文件，提高打包效率。\n\n### 例子\n首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：\n```\n<!-- index.html -->\n<html>\n<body>\n  <script src=\"bundle.js\"></script>\n</body>\n</html>\n```\n```\n// entry.js\ndocument.write('It works.')\n```\n然后编译 entry.js 并打包到 bundle.js：\n```\n$ webpack entry.js bundle.js\n```\n打包过程会显示日志：\n```\nHash: e964f90ec65eb2c29bb9\nVersion: webpack 1.12.2\nTime: 54ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  1.42 kB       0  [emitted]  main\n   [0] ./entry.js 27 bytes {0} [built]\n```\n用浏览器打开 index.html 将会看到 It works.\n","slug":"webpack-use-expo","published":1,"updated":"2019-08-15T15:03:33.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhkm001nxknw7w3k850u","content":"<div class=\"foreword\">webpack是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。还可以结合gulp使用，不冲突。<br></div>\n\n<a id=\"more\"></a>\n<h3 id=\"webpack优势\"><a href=\"#webpack优势\" class=\"headerlink\" title=\"webpack优势\"></a>webpack优势</h3><ul>\n<li>模块来源广泛，支持包括npm/bower等等的各种主流模块安装／依赖解决方案；</li>\n<li>模块化规范支持全面，AMD/CommonJS一应具全；</li>\n<li>插件机制完善，实现本身实现同样模块化，容易扩展；</li>\n<li>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</li>\n</ul>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先要安装 <a href=\"http://nodejs.org\" target=\"_blank\" rel=\"noopener\">Node.js</a>， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。<br>用 npm 全局安装 Webpack：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install webpack -g</span><br></pre></td></tr></table></figure></p>\n<p>初始化配置文件 package.json ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init</span><br></pre></td></tr></table></figure></p>\n<p>到项目目录安装，将 webpack 添加到 package.json ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"webpack常用命令\"><a href=\"#webpack常用命令\" class=\"headerlink\" title=\"webpack常用命令\"></a>webpack常用命令</h3><ul>\n<li>webpack 最基本的启动webpack命令</li>\n<li>webpack -w 提供watch方法，实时进行打包更新</li>\n<li>webpack -p 对打包后的文件进行压缩</li>\n<li>webpack -d 提供SourceMaps，方便调试</li>\n<li>webpack –colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤</li>\n<li>webpack –profile 输出性能数据，可以看到每一步的耗时</li>\n<li>webpack –display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块</li>\n</ul>\n<p>前面的四个命令比较基础，使用频率会比较大，后面的命令主要是用来定位打包时间较长的原因，方便改进配置文件，提高打包效率。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- index.html --&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry.js</span><br><span class=\"line\">document.write(&apos;It works.&apos;)</span><br></pre></td></tr></table></figure>\n<p>然后编译 entry.js 并打包到 bundle.js：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack entry.js bundle.js</span><br></pre></td></tr></table></figure></p>\n<p>打包过程会显示日志：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hash: e964f90ec65eb2c29bb9</span><br><span class=\"line\">Version: webpack 1.12.2</span><br><span class=\"line\">Time: 54ms</span><br><span class=\"line\">    Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">bundle.js  1.42 kB       0  [emitted]  main</span><br><span class=\"line\">   [0] ./entry.js 27 bytes &#123;0&#125; [built]</span><br></pre></td></tr></table></figure></p>\n<p>用浏览器打开 index.html 将会看到 It works.</p>\n","site":{"data":{}},"excerpt":"<div class=\"foreword\">webpack是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。还可以结合gulp使用，不冲突。<br></div>","more":"<h3 id=\"webpack优势\"><a href=\"#webpack优势\" class=\"headerlink\" title=\"webpack优势\"></a>webpack优势</h3><ul>\n<li>模块来源广泛，支持包括npm/bower等等的各种主流模块安装／依赖解决方案；</li>\n<li>模块化规范支持全面，AMD/CommonJS一应具全；</li>\n<li>插件机制完善，实现本身实现同样模块化，容易扩展；</li>\n<li>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</li>\n</ul>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先要安装 <a href=\"http://nodejs.org\" target=\"_blank\" rel=\"noopener\">Node.js</a>， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。<br>用 npm 全局安装 Webpack：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install webpack -g</span><br></pre></td></tr></table></figure></p>\n<p>初始化配置文件 package.json ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init</span><br></pre></td></tr></table></figure></p>\n<p>到项目目录安装，将 webpack 添加到 package.json ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"webpack常用命令\"><a href=\"#webpack常用命令\" class=\"headerlink\" title=\"webpack常用命令\"></a>webpack常用命令</h3><ul>\n<li>webpack 最基本的启动webpack命令</li>\n<li>webpack -w 提供watch方法，实时进行打包更新</li>\n<li>webpack -p 对打包后的文件进行压缩</li>\n<li>webpack -d 提供SourceMaps，方便调试</li>\n<li>webpack –colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤</li>\n<li>webpack –profile 输出性能数据，可以看到每一步的耗时</li>\n<li>webpack –display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块</li>\n</ul>\n<p>前面的四个命令比较基础，使用频率会比较大，后面的命令主要是用来定位打包时间较长的原因，方便改进配置文件，提高打包效率。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- index.html --&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// entry.js</span><br><span class=\"line\">document.write(&apos;It works.&apos;)</span><br></pre></td></tr></table></figure>\n<p>然后编译 entry.js 并打包到 bundle.js：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack entry.js bundle.js</span><br></pre></td></tr></table></figure></p>\n<p>打包过程会显示日志：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hash: e964f90ec65eb2c29bb9</span><br><span class=\"line\">Version: webpack 1.12.2</span><br><span class=\"line\">Time: 54ms</span><br><span class=\"line\">    Asset     Size  Chunks             Chunk Names</span><br><span class=\"line\">bundle.js  1.42 kB       0  [emitted]  main</span><br><span class=\"line\">   [0] ./entry.js 27 bytes &#123;0&#125; [built]</span><br></pre></td></tr></table></figure></p>\n<p>用浏览器打开 index.html 将会看到 It works.</p>"},{"title":"React 笔记之 表单","abbrlink":13509,"date":"2016-10-18T13:48:08.000Z","_content":"\n诸如： `<input>`、`<textarea>`、`<option>` 这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。\n<!--more-->\n## 交互属性\n在 HTML 中`<textarea>`的值通过子节点设置；在 React 中则应该使用 value 代替。\n表单组件可以通过onChange回调函数来监听组件变化。当用户做出以下交互时,onChange执行并通过浏览器做出响应：\n- `<input>`或 `<textarea>` 的 `value` 发生变化时。\n- `<input>`的 `checked` 状态改变时。\n- `<option>` 的 `selected` 状态改变时。\n和所有 DOM 事件一样，所有的 HTML 原生组件都支持 onChange 属性，而且可以用来监听冒泡的 change 事件.\n\n<div class=\"tip\">\n对于`<input>`和`<textarea>`，onChange应当被用于取代DOM内置的onInput事件处理\n</div>\n\n## 不可控组件和可控组件\n**可控组件**\n设置了 `value` 的 `<input>` 是一个受限组件。 对于受限的 `<input>`，渲染出来的 HTML 元素始终保持 `value` 属性的值。\n```\nrender: function() {\n    return <input type=\"text\" value=\"Hello!\"/>;\n }\n```\n上面的代码将渲染出一个值为 Hello! 的 input 元素。用户在渲染出来的元素里输入任何值都不起作用，因为 React 已经赋值为 Hello!。如果想响应更新用户输入的值，就得使用 onChange 事件\n```\ngetInitialState: function() {\n    return {value: 'Hello!'};\n },\n handleChange: function(event) {\n    this.setState({value: event.target.value});\n },\n render: function() {\n    var value = this.state.value;\n    return <input type=\"text\" value={value} onChange={this.handleChange} />;\n }\n```\n**Default Value**\n初始值是状态中的value。如果要取数据，可直接使用 `var inputValue = this.state.value`。\n```\nrender: function() {\n   return <input type=\"text\" defaultValue={this.state.value}/>;\n}\n```\n<div class=\"tip\">\n一个可控组件并不保持自己的原始状态；组件的呈现完全基于属性。\n</div>\n**实例**\n```\nvar Kekong = React.creatClass({\n    getInitialState:function(){\n        return {\n            dada:'shuaige'\n        }\n    },\n    handleChange:function(e){\n        this.setState({\n            dada:e.target.value\n        });\n    },\n    submitHandler:function(e){\n        e.preventDefault();\n        alert(this.state.dada);\n    },\n    render:function(){\n        return <form onSubmit={this.submitHandler}>\n            <input type=\"text\" value={this.state.dada} onChange={this.handleChange} />\n            <button type=\"submit\">speak</button>\n        </form>;\n    }\n});\nReactDOM.render(<Kekong />,document.body);\n```\n**不可控组件**\n没有设置value(或者设为null) 的`<input>`组件是一个不可控组件。这样的话，组件中的数据和state中的数据并不对应，可以说，组件的数据不可控。\n```\nrender: function() {\n    return <input type=\"text\" />;\n }\n```\n上面的代码将渲染出一个空值的输入框，用户输入将立即反应到元素上。和受限元素一样，使用 onChange 事件可以监听值的变化。\n**Default Value**\n如果想给组件设置一个非空的初始值，可以使用 defaultValue 属性。 数据在这里并没有存贮在状态中，而是写在input中。\n```\nrender: function() {\n   return <input type=\"text\" defaultValue=\"Hello!\" />;\n}\n```\n如果要拿到input中的value，需先拿到其DOM节点，然后获取其value值\n```\nvar inputValue = React.findDOMNode(this.refs.input).value\n```\n上面的代码渲染出来的元素和受限组件一样有一个初始值，但这个值用户可以改变并会反应到界面上。\n同样，`<input type=\"checkbox\">`和`<input type=\"radio\">`支持defaultChecked属性，`<select>`支持设置defaultValue。\n`defaultValue`和`defaultChecked`属性只能在初始的render函数中使用，如果你要在随后的render函数中更新value值，你需要使用可控组件。\n\n**实例**\n```\nvar UnKekong = React.creatClass({\n    submitHandler:function(e){\n        e.preventDefault();\n        var helloUnke = React.findDOMNode(this.refs.helloUnke).value;\n        alert(helloUnke);\n    },\n    render:function(){\n        return <form onsubmit={this.submitHandler}>\n            <input ref=\"helloUnke\" type=\"text\" defaultValue=\"Dada shuaige\" />\n            <button type=\"submit\">speak</button>\n        </form>;\n    }\n})\nReact.render(<Unkekong />,document.body);\n```\n**Checkbox和Radio的潜在问题**\n<div class=\"tip\">\n注意，在试图改变正常处理Checkbox和Radio input时，React用一个click事件来代替change事件。大多数情况下，这种行为与预期相同，除了调用preventDefault时。preventDefault从视觉上阻止浏览器更新input，即使checked被触发。它可以在移除调用preventDefault与用setTimeout来切换checked中起作用。\n</div>\n**Why use Controlled Components**\n组件可控的优点：\n- 符合React的数据流，单向数据流，从state流向render输出的结果。\n- 数据存贮在state中，便于使用。\n- 便于对数据进行处理\n\n\n## 表单元素\n\n- `<label htmlFor=\"name\">Name</label>`\n- 要注意for是js关键字，要写成htmlFor。具体JSX语法在之间笔记中有介绍，传送门：React.js学习笔记之JSX解读。现在多数提示用input的placeholder属性替代。\n- `<input type=\"\" onChange={this.handleChange}/>`\n- `<textarea onChange={this.handleChange}/>`\n- `<select onChange={this.handleChange}><option></option></select>`\n\n**实例**\n[这是一个demo传送门](https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3)\n```\nvar MyForm = React.createClass({\ngetInitialState:function(){\n    return {\n        username:'',\n        gender:'man',\n        checked:true\n    };\n},\nhandleUsernameChange:function(e){\n    this.setState({\n        username:e.target.value\n    });\n},\nhandlerGenderChange:function(e){\n    this.setState({\n        gender:e.target.value\n    });\n},\nhandleCheckedChange:function(e){\n    this.setState({\n        checked:e.target.checked\n    });\n},\nsubmitHandler:function (e) {\n    e.preventDefault();\n    console.log(this.state);\n},\nrender:function () {\n    return <form onSubmit={this.submitHandler}>\n        <label htmlFor=\"username\">请输入用户名</label>\n        <input type=\"text\" onChange={this.handleUsernameChange} value={this.state.username} id=\"username\"/>\n        <br/>\n        <select onChange={this.handlerGenderChange} value={this.state.gender}>\n            <option value=\"man\">男</option>\n            <option value=\"woman\">女</option>\n        </select>\n        <br/>\n        <label htmlFor=\"checkbox\">大大是帅哥吗</label>\n        <input type=\"checkbox\" value=\"大大是帅哥\" checked={this.state.checked} onChange={this.handleCheckedChange} id=\"checkbox\"/>\n        <button type=\"submit\">提交</button>\n    </form>\n}\n});\nReactDOM.render(<MyForm />,document.getElementById('reactDemo'));\n```\n\n## 事件处理函数\n\n```\nonChange={this.handleChange}\n```\n若有多个元素要运用事件处理函数，常规的方法是编写多个onChange事件。这么写的话会导致代码维护比较困难并且也非常冗余。更好的做法是把事件处理函数编写为一个。可以采用bind复用和name复用这两种方法。\n\n**bind复用**\n```\nhandleChange:function(name,event){\n    ......\n}\nonChagne={this.handleChange.bind(this,'input')}\n```\n书写简单，但需要对bind()机制熟悉，性能相对要好。\n\n**实例**\n[这是一个demo传送门](https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3)\n```\nvar MyForm = React.createClass({\n    getInitialState:function(){\n        return {\n            username:'',\n            gender:'man',\n            checked:true\n        };\n    },\n    handleChange:function(name,event){\n        var newState={};\n        newState[name]=name==\"checked\"?event.target.checked:event.target.value;\n        this.setState(newState);\n    },\n    submitHandler:function (e) {\n        e.preventDefault();\n        console.log(this.state);\n    },\n    render:function () {\n        return <form onSubmit={this.submitHandler}>\n            <label htmlFor=\"username\">请输入用户名</label>\n            <input type=\"text\" onChange={this.handleChange.bind(this,\"username\")} value={this.state.username} id=\"username\"/>\n            <br/>\n            <select onChange={this.handleChange.bind(this,\"gender\")} value={this.state.gender}>\n                <option value=\"man\">男</option>\n                <option value=\"woman\">女</option>\n            </select>\n            <br/>\n            <label htmlFor=\"checkbox\">大大是帅哥吗</label>\n            <input type=\"checkbox\" value=\"大大是帅哥\" checked={this.state.checked} onChange={this.handleChange.bind(this,\"checked\")} id=\"checkbox\"/>\n            <button type=\"submit\">提交</button>\n        </form>\n    }\n});\nReactDOM.render(<MyForm />,document.getElementById('reactDemo'));\n```\n**name复用**\n```\nhandleChange:function(event){\n    var name = event.target.name\n}\nonChange={this.handleChange}\n```\n相比Bind写法会少一些参数，在函数中需要读取表单的name值，需要添加name属性。\n\n**实例**\n```\nvar MyForm = React.createClass({\n    getInitialState:function(){\n        return {\n            username:'',\n            gender:'man',\n            checked:true\n        };\n    },\n    handleChange:function(event){\n        var newState={};\n        newState[event.target.name]=event.target.name==\"checked\"?event.target.checked:event.target.value;\n        this.setState(newState);\n    },\n    submitHandler:function (e) {\n        e.preventDefault();\n        console.log(this.state);\n    },\n    render:function () {\n        return <form onSubmit={this.submitHandler}>\n            <label htmlFor=\"username\">请输入用户名</label>\n            <input type=\"text\" name=\"username\" onChange={this.handleChange} value={this.state.username} id=\"username\"/>\n            <br/>\n            <select name=\"gender\" onChange={this.handleChange} value={this.state.gender}>\n                <option value=\"man\">男</option>\n                <option value=\"woman\">女</option>\n            </select>\n            <br/>\n            <label htmlFor=\"checkbox\">大大是帅哥吗</label>\n            <input type=\"checkbox\" value=\"大大是帅哥\" checked={this.state.checked} onChange={this.handleChange} name=\"checked\" id=\"checkbox\"/>\n            <button type=\"submit\">提交</button>\n        </form>\n    }\n});\nReactDOM.render(<MyForm />,document.getElementById('reactDemo'));\n```\n\n## 自定义表单组件\n自定义表单组件能让我们更好的使用组件，让我们更好的开发网页。\n\n**why 自定义表单组件？**\n自定义表单组件的原因：\n- 内因：表单本身具备特殊性：样式统一、信息内聚、行为固定\n- 外因：本质上是组件的嵌套，组织和管理组件的一种方式\n","source":"_posts/react-to-biaodan.md","raw":"---\ntitle: React 笔记之 表单\ntags: react\ncategories: react\nabbrlink: 13509\ndate: 2016-10-18 21:48:08\n---\n\n诸如： `<input>`、`<textarea>`、`<option>` 这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。\n<!--more-->\n## 交互属性\n在 HTML 中`<textarea>`的值通过子节点设置；在 React 中则应该使用 value 代替。\n表单组件可以通过onChange回调函数来监听组件变化。当用户做出以下交互时,onChange执行并通过浏览器做出响应：\n- `<input>`或 `<textarea>` 的 `value` 发生变化时。\n- `<input>`的 `checked` 状态改变时。\n- `<option>` 的 `selected` 状态改变时。\n和所有 DOM 事件一样，所有的 HTML 原生组件都支持 onChange 属性，而且可以用来监听冒泡的 change 事件.\n\n<div class=\"tip\">\n对于`<input>`和`<textarea>`，onChange应当被用于取代DOM内置的onInput事件处理\n</div>\n\n## 不可控组件和可控组件\n**可控组件**\n设置了 `value` 的 `<input>` 是一个受限组件。 对于受限的 `<input>`，渲染出来的 HTML 元素始终保持 `value` 属性的值。\n```\nrender: function() {\n    return <input type=\"text\" value=\"Hello!\"/>;\n }\n```\n上面的代码将渲染出一个值为 Hello! 的 input 元素。用户在渲染出来的元素里输入任何值都不起作用，因为 React 已经赋值为 Hello!。如果想响应更新用户输入的值，就得使用 onChange 事件\n```\ngetInitialState: function() {\n    return {value: 'Hello!'};\n },\n handleChange: function(event) {\n    this.setState({value: event.target.value});\n },\n render: function() {\n    var value = this.state.value;\n    return <input type=\"text\" value={value} onChange={this.handleChange} />;\n }\n```\n**Default Value**\n初始值是状态中的value。如果要取数据，可直接使用 `var inputValue = this.state.value`。\n```\nrender: function() {\n   return <input type=\"text\" defaultValue={this.state.value}/>;\n}\n```\n<div class=\"tip\">\n一个可控组件并不保持自己的原始状态；组件的呈现完全基于属性。\n</div>\n**实例**\n```\nvar Kekong = React.creatClass({\n    getInitialState:function(){\n        return {\n            dada:'shuaige'\n        }\n    },\n    handleChange:function(e){\n        this.setState({\n            dada:e.target.value\n        });\n    },\n    submitHandler:function(e){\n        e.preventDefault();\n        alert(this.state.dada);\n    },\n    render:function(){\n        return <form onSubmit={this.submitHandler}>\n            <input type=\"text\" value={this.state.dada} onChange={this.handleChange} />\n            <button type=\"submit\">speak</button>\n        </form>;\n    }\n});\nReactDOM.render(<Kekong />,document.body);\n```\n**不可控组件**\n没有设置value(或者设为null) 的`<input>`组件是一个不可控组件。这样的话，组件中的数据和state中的数据并不对应，可以说，组件的数据不可控。\n```\nrender: function() {\n    return <input type=\"text\" />;\n }\n```\n上面的代码将渲染出一个空值的输入框，用户输入将立即反应到元素上。和受限元素一样，使用 onChange 事件可以监听值的变化。\n**Default Value**\n如果想给组件设置一个非空的初始值，可以使用 defaultValue 属性。 数据在这里并没有存贮在状态中，而是写在input中。\n```\nrender: function() {\n   return <input type=\"text\" defaultValue=\"Hello!\" />;\n}\n```\n如果要拿到input中的value，需先拿到其DOM节点，然后获取其value值\n```\nvar inputValue = React.findDOMNode(this.refs.input).value\n```\n上面的代码渲染出来的元素和受限组件一样有一个初始值，但这个值用户可以改变并会反应到界面上。\n同样，`<input type=\"checkbox\">`和`<input type=\"radio\">`支持defaultChecked属性，`<select>`支持设置defaultValue。\n`defaultValue`和`defaultChecked`属性只能在初始的render函数中使用，如果你要在随后的render函数中更新value值，你需要使用可控组件。\n\n**实例**\n```\nvar UnKekong = React.creatClass({\n    submitHandler:function(e){\n        e.preventDefault();\n        var helloUnke = React.findDOMNode(this.refs.helloUnke).value;\n        alert(helloUnke);\n    },\n    render:function(){\n        return <form onsubmit={this.submitHandler}>\n            <input ref=\"helloUnke\" type=\"text\" defaultValue=\"Dada shuaige\" />\n            <button type=\"submit\">speak</button>\n        </form>;\n    }\n})\nReact.render(<Unkekong />,document.body);\n```\n**Checkbox和Radio的潜在问题**\n<div class=\"tip\">\n注意，在试图改变正常处理Checkbox和Radio input时，React用一个click事件来代替change事件。大多数情况下，这种行为与预期相同，除了调用preventDefault时。preventDefault从视觉上阻止浏览器更新input，即使checked被触发。它可以在移除调用preventDefault与用setTimeout来切换checked中起作用。\n</div>\n**Why use Controlled Components**\n组件可控的优点：\n- 符合React的数据流，单向数据流，从state流向render输出的结果。\n- 数据存贮在state中，便于使用。\n- 便于对数据进行处理\n\n\n## 表单元素\n\n- `<label htmlFor=\"name\">Name</label>`\n- 要注意for是js关键字，要写成htmlFor。具体JSX语法在之间笔记中有介绍，传送门：React.js学习笔记之JSX解读。现在多数提示用input的placeholder属性替代。\n- `<input type=\"\" onChange={this.handleChange}/>`\n- `<textarea onChange={this.handleChange}/>`\n- `<select onChange={this.handleChange}><option></option></select>`\n\n**实例**\n[这是一个demo传送门](https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3)\n```\nvar MyForm = React.createClass({\ngetInitialState:function(){\n    return {\n        username:'',\n        gender:'man',\n        checked:true\n    };\n},\nhandleUsernameChange:function(e){\n    this.setState({\n        username:e.target.value\n    });\n},\nhandlerGenderChange:function(e){\n    this.setState({\n        gender:e.target.value\n    });\n},\nhandleCheckedChange:function(e){\n    this.setState({\n        checked:e.target.checked\n    });\n},\nsubmitHandler:function (e) {\n    e.preventDefault();\n    console.log(this.state);\n},\nrender:function () {\n    return <form onSubmit={this.submitHandler}>\n        <label htmlFor=\"username\">请输入用户名</label>\n        <input type=\"text\" onChange={this.handleUsernameChange} value={this.state.username} id=\"username\"/>\n        <br/>\n        <select onChange={this.handlerGenderChange} value={this.state.gender}>\n            <option value=\"man\">男</option>\n            <option value=\"woman\">女</option>\n        </select>\n        <br/>\n        <label htmlFor=\"checkbox\">大大是帅哥吗</label>\n        <input type=\"checkbox\" value=\"大大是帅哥\" checked={this.state.checked} onChange={this.handleCheckedChange} id=\"checkbox\"/>\n        <button type=\"submit\">提交</button>\n    </form>\n}\n});\nReactDOM.render(<MyForm />,document.getElementById('reactDemo'));\n```\n\n## 事件处理函数\n\n```\nonChange={this.handleChange}\n```\n若有多个元素要运用事件处理函数，常规的方法是编写多个onChange事件。这么写的话会导致代码维护比较困难并且也非常冗余。更好的做法是把事件处理函数编写为一个。可以采用bind复用和name复用这两种方法。\n\n**bind复用**\n```\nhandleChange:function(name,event){\n    ......\n}\nonChagne={this.handleChange.bind(this,'input')}\n```\n书写简单，但需要对bind()机制熟悉，性能相对要好。\n\n**实例**\n[这是一个demo传送门](https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3)\n```\nvar MyForm = React.createClass({\n    getInitialState:function(){\n        return {\n            username:'',\n            gender:'man',\n            checked:true\n        };\n    },\n    handleChange:function(name,event){\n        var newState={};\n        newState[name]=name==\"checked\"?event.target.checked:event.target.value;\n        this.setState(newState);\n    },\n    submitHandler:function (e) {\n        e.preventDefault();\n        console.log(this.state);\n    },\n    render:function () {\n        return <form onSubmit={this.submitHandler}>\n            <label htmlFor=\"username\">请输入用户名</label>\n            <input type=\"text\" onChange={this.handleChange.bind(this,\"username\")} value={this.state.username} id=\"username\"/>\n            <br/>\n            <select onChange={this.handleChange.bind(this,\"gender\")} value={this.state.gender}>\n                <option value=\"man\">男</option>\n                <option value=\"woman\">女</option>\n            </select>\n            <br/>\n            <label htmlFor=\"checkbox\">大大是帅哥吗</label>\n            <input type=\"checkbox\" value=\"大大是帅哥\" checked={this.state.checked} onChange={this.handleChange.bind(this,\"checked\")} id=\"checkbox\"/>\n            <button type=\"submit\">提交</button>\n        </form>\n    }\n});\nReactDOM.render(<MyForm />,document.getElementById('reactDemo'));\n```\n**name复用**\n```\nhandleChange:function(event){\n    var name = event.target.name\n}\nonChange={this.handleChange}\n```\n相比Bind写法会少一些参数，在函数中需要读取表单的name值，需要添加name属性。\n\n**实例**\n```\nvar MyForm = React.createClass({\n    getInitialState:function(){\n        return {\n            username:'',\n            gender:'man',\n            checked:true\n        };\n    },\n    handleChange:function(event){\n        var newState={};\n        newState[event.target.name]=event.target.name==\"checked\"?event.target.checked:event.target.value;\n        this.setState(newState);\n    },\n    submitHandler:function (e) {\n        e.preventDefault();\n        console.log(this.state);\n    },\n    render:function () {\n        return <form onSubmit={this.submitHandler}>\n            <label htmlFor=\"username\">请输入用户名</label>\n            <input type=\"text\" name=\"username\" onChange={this.handleChange} value={this.state.username} id=\"username\"/>\n            <br/>\n            <select name=\"gender\" onChange={this.handleChange} value={this.state.gender}>\n                <option value=\"man\">男</option>\n                <option value=\"woman\">女</option>\n            </select>\n            <br/>\n            <label htmlFor=\"checkbox\">大大是帅哥吗</label>\n            <input type=\"checkbox\" value=\"大大是帅哥\" checked={this.state.checked} onChange={this.handleChange} name=\"checked\" id=\"checkbox\"/>\n            <button type=\"submit\">提交</button>\n        </form>\n    }\n});\nReactDOM.render(<MyForm />,document.getElementById('reactDemo'));\n```\n\n## 自定义表单组件\n自定义表单组件能让我们更好的使用组件，让我们更好的开发网页。\n\n**why 自定义表单组件？**\n自定义表单组件的原因：\n- 内因：表单本身具备特殊性：样式统一、信息内聚、行为固定\n- 外因：本质上是组件的嵌套，组织和管理组件的一种方式\n","slug":"react-to-biaodan","published":1,"updated":"2019-08-15T15:03:33.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhkn001oxknwf114d3an","content":"<p>诸如： <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;option&gt;</code> 这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。<br><a id=\"more\"></a></p>\n<h2 id=\"交互属性\"><a href=\"#交互属性\" class=\"headerlink\" title=\"交互属性\"></a>交互属性</h2><p>在 HTML 中<code>&lt;textarea&gt;</code>的值通过子节点设置；在 React 中则应该使用 value 代替。<br>表单组件可以通过onChange回调函数来监听组件变化。当用户做出以下交互时,onChange执行并通过浏览器做出响应：</p>\n<ul>\n<li><code>&lt;input&gt;</code>或 <code>&lt;textarea&gt;</code> 的 <code>value</code> 发生变化时。</li>\n<li><code>&lt;input&gt;</code>的 <code>checked</code> 状态改变时。</li>\n<li><code>&lt;option&gt;</code> 的 <code>selected</code> 状态改变时。<br>和所有 DOM 事件一样，所有的 HTML 原生组件都支持 onChange 属性，而且可以用来监听冒泡的 change 事件.</li>\n</ul>\n<div class=\"tip\"><br>对于<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>，onChange应当被用于取代DOM内置的onInput事件处理<br></div>\n\n<h2 id=\"不可控组件和可控组件\"><a href=\"#不可控组件和可控组件\" class=\"headerlink\" title=\"不可控组件和可控组件\"></a>不可控组件和可控组件</h2><p><strong>可控组件</strong><br>设置了 <code>value</code> 的 <code>&lt;input&gt;</code> 是一个受限组件。 对于受限的 <code>&lt;input&gt;</code>，渲染出来的 HTML 元素始终保持 <code>value</code> 属性的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">    return &lt;input type=&quot;text&quot; value=&quot;Hello!&quot;/&gt;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码将渲染出一个值为 Hello! 的 input 元素。用户在渲染出来的元素里输入任何值都不起作用，因为 React 已经赋值为 Hello!。如果想响应更新用户输入的值，就得使用 onChange 事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getInitialState: function() &#123;</span><br><span class=\"line\">    return &#123;value: &apos;Hello!&apos;&#125;;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> handleChange: function(event) &#123;</span><br><span class=\"line\">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> render: function() &#123;</span><br><span class=\"line\">    var value = this.state.value;</span><br><span class=\"line\">    return &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Default Value</strong><br>初始值是状态中的value。如果要取数据，可直接使用 <code>var inputValue = this.state.value</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">   return &lt;input type=&quot;text&quot; defaultValue=&#123;this.state.value&#125;/&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><div class=\"tip\"><br>一个可控组件并不保持自己的原始状态；组件的呈现完全基于属性。<br></div><br><strong>实例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Kekong = React.creatClass(&#123;</span><br><span class=\"line\">    getInitialState:function()&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            dada:&apos;shuaige&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange:function(e)&#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            dada:e.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    submitHandler:function(e)&#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        alert(this.state.dada);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render:function()&#123;</span><br><span class=\"line\">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; value=&#123;this.state.dada&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"line\">            &lt;button type=&quot;submit&quot;&gt;speak&lt;/button&gt;</span><br><span class=\"line\">        &lt;/form&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;Kekong /&gt;,document.body);</span><br></pre></td></tr></table></figure></p>\n<p><strong>不可控组件</strong><br>没有设置value(或者设为null) 的<code>&lt;input&gt;</code>组件是一个不可控组件。这样的话，组件中的数据和state中的数据并不对应，可以说，组件的数据不可控。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">    return &lt;input type=&quot;text&quot; /&gt;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码将渲染出一个空值的输入框，用户输入将立即反应到元素上。和受限元素一样，使用 onChange 事件可以监听值的变化。<br><strong>Default Value</strong><br>如果想给组件设置一个非空的初始值，可以使用 defaultValue 属性。 数据在这里并没有存贮在状态中，而是写在input中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">   return &lt;input type=&quot;text&quot; defaultValue=&quot;Hello!&quot; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果要拿到input中的value，需先拿到其DOM节点，然后获取其value值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var inputValue = React.findDOMNode(this.refs.input).value</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码渲染出来的元素和受限组件一样有一个初始值，但这个值用户可以改变并会反应到界面上。<br>同样，<code>&lt;input type=&quot;checkbox&quot;&gt;</code>和<code>&lt;input type=&quot;radio&quot;&gt;</code>支持defaultChecked属性，<code>&lt;select&gt;</code>支持设置defaultValue。<br><code>defaultValue</code>和<code>defaultChecked</code>属性只能在初始的render函数中使用，如果你要在随后的render函数中更新value值，你需要使用可控组件。</p>\n<p><strong>实例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var UnKekong = React.creatClass(&#123;</span><br><span class=\"line\">    submitHandler:function(e)&#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        var helloUnke = React.findDOMNode(this.refs.helloUnke).value;</span><br><span class=\"line\">        alert(helloUnke);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render:function()&#123;</span><br><span class=\"line\">        return &lt;form onsubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">            &lt;input ref=&quot;helloUnke&quot; type=&quot;text&quot; defaultValue=&quot;Dada shuaige&quot; /&gt;</span><br><span class=\"line\">            &lt;button type=&quot;submit&quot;&gt;speak&lt;/button&gt;</span><br><span class=\"line\">        &lt;/form&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">React.render(&lt;Unkekong /&gt;,document.body);</span><br></pre></td></tr></table></figure></p>\n<p><strong>Checkbox和Radio的潜在问题</strong></p>\n<p><div class=\"tip\"><br>注意，在试图改变正常处理Checkbox和Radio input时，React用一个click事件来代替change事件。大多数情况下，这种行为与预期相同，除了调用preventDefault时。preventDefault从视觉上阻止浏览器更新input，即使checked被触发。它可以在移除调用preventDefault与用setTimeout来切换checked中起作用。<br></div><br><strong>Why use Controlled Components</strong><br>组件可控的优点：</p>\n<ul>\n<li>符合React的数据流，单向数据流，从state流向render输出的结果。</li>\n<li>数据存贮在state中，便于使用。</li>\n<li>便于对数据进行处理</li>\n</ul>\n<h2 id=\"表单元素\"><a href=\"#表单元素\" class=\"headerlink\" title=\"表单元素\"></a>表单元素</h2><ul>\n<li><code>&lt;label htmlFor=&quot;name&quot;&gt;Name&lt;/label&gt;</code></li>\n<li>要注意for是js关键字，要写成htmlFor。具体JSX语法在之间笔记中有介绍，传送门：React.js学习笔记之JSX解读。现在多数提示用input的placeholder属性替代。</li>\n<li><code>&lt;input type=&quot;&quot; onChange={this.handleChange}/&gt;</code></li>\n<li><code>&lt;textarea onChange={this.handleChange}/&gt;</code></li>\n<li><code>&lt;select onChange={this.handleChange}&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt;</code></li>\n</ul>\n<p><strong>实例</strong><br><a href=\"https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3\" target=\"_blank\" rel=\"noopener\">这是一个demo传送门</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyForm = React.createClass(&#123;</span><br><span class=\"line\">getInitialState:function()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        username:&apos;&apos;,</span><br><span class=\"line\">        gender:&apos;man&apos;,</span><br><span class=\"line\">        checked:true</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">handleUsernameChange:function(e)&#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        username:e.target.value</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">handlerGenderChange:function(e)&#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        gender:e.target.value</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">handleCheckedChange:function(e)&#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        checked:e.target.checked</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">submitHandler:function (e) &#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    console.log(this.state);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">render:function () &#123;</span><br><span class=\"line\">    return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">        &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; onChange=&#123;this.handleUsernameChange&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">        &lt;select onChange=&#123;this.handlerGenderChange&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class=\"line\">            &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class=\"line\">            &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class=\"line\">        &lt;/select&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">        &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class=\"line\">        &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleCheckedChange&#125; id=&quot;checkbox&quot;/&gt;</span><br><span class=\"line\">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">    &lt;/form&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onChange=&#123;this.handleChange&#125;</span><br></pre></td></tr></table></figure>\n<p>若有多个元素要运用事件处理函数，常规的方法是编写多个onChange事件。这么写的话会导致代码维护比较困难并且也非常冗余。更好的做法是把事件处理函数编写为一个。可以采用bind复用和name复用这两种方法。</p>\n<p><strong>bind复用</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleChange:function(name,event)&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">onChagne=&#123;this.handleChange.bind(this,&apos;input&apos;)&#125;</span><br></pre></td></tr></table></figure></p>\n<p>书写简单，但需要对bind()机制熟悉，性能相对要好。</p>\n<p><strong>实例</strong><br><a href=\"https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3\" target=\"_blank\" rel=\"noopener\">这是一个demo传送门</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyForm = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState:function()&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            username:&apos;&apos;,</span><br><span class=\"line\">            gender:&apos;man&apos;,</span><br><span class=\"line\">            checked:true</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange:function(name,event)&#123;</span><br><span class=\"line\">        var newState=&#123;&#125;;</span><br><span class=\"line\">        newState[name]=name==&quot;checked&quot;?event.target.checked:event.target.value;</span><br><span class=\"line\">        this.setState(newState);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    submitHandler:function (e) &#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        console.log(this.state);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render:function () &#123;</span><br><span class=\"line\">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">            &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; onChange=&#123;this.handleChange.bind(this,&quot;username&quot;)&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;select onChange=&#123;this.handleChange.bind(this,&quot;gender&quot;)&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class=\"line\">                &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class=\"line\">                &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange.bind(this,&quot;checked&quot;)&#125; id=&quot;checkbox&quot;/&gt;</span><br><span class=\"line\">            &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">        &lt;/form&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p>\n<p><strong>name复用</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleChange:function(event)&#123;</span><br><span class=\"line\">    var name = event.target.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">onChange=&#123;this.handleChange&#125;</span><br></pre></td></tr></table></figure></p>\n<p>相比Bind写法会少一些参数，在函数中需要读取表单的name值，需要添加name属性。</p>\n<p><strong>实例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyForm = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState:function()&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            username:&apos;&apos;,</span><br><span class=\"line\">            gender:&apos;man&apos;,</span><br><span class=\"line\">            checked:true</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange:function(event)&#123;</span><br><span class=\"line\">        var newState=&#123;&#125;;</span><br><span class=\"line\">        newState[event.target.name]=event.target.name==&quot;checked&quot;?event.target.checked:event.target.value;</span><br><span class=\"line\">        this.setState(newState);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    submitHandler:function (e) &#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        console.log(this.state);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render:function () &#123;</span><br><span class=\"line\">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">            &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; name=&quot;username&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;select name=&quot;gender&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class=\"line\">                &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class=\"line\">                &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange&#125; name=&quot;checked&quot; id=&quot;checkbox&quot;/&gt;</span><br><span class=\"line\">            &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">        &lt;/form&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"自定义表单组件\"><a href=\"#自定义表单组件\" class=\"headerlink\" title=\"自定义表单组件\"></a>自定义表单组件</h2><p>自定义表单组件能让我们更好的使用组件，让我们更好的开发网页。</p>\n<p><strong>why 自定义表单组件？</strong><br>自定义表单组件的原因：</p>\n<ul>\n<li>内因：表单本身具备特殊性：样式统一、信息内聚、行为固定</li>\n<li>外因：本质上是组件的嵌套，组织和管理组件的一种方式</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>诸如： <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;option&gt;</code> 这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。<br>","more":"</p>\n<h2 id=\"交互属性\"><a href=\"#交互属性\" class=\"headerlink\" title=\"交互属性\"></a>交互属性</h2><p>在 HTML 中<code>&lt;textarea&gt;</code>的值通过子节点设置；在 React 中则应该使用 value 代替。<br>表单组件可以通过onChange回调函数来监听组件变化。当用户做出以下交互时,onChange执行并通过浏览器做出响应：</p>\n<ul>\n<li><code>&lt;input&gt;</code>或 <code>&lt;textarea&gt;</code> 的 <code>value</code> 发生变化时。</li>\n<li><code>&lt;input&gt;</code>的 <code>checked</code> 状态改变时。</li>\n<li><code>&lt;option&gt;</code> 的 <code>selected</code> 状态改变时。<br>和所有 DOM 事件一样，所有的 HTML 原生组件都支持 onChange 属性，而且可以用来监听冒泡的 change 事件.</li>\n</ul>\n<div class=\"tip\"><br>对于<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>，onChange应当被用于取代DOM内置的onInput事件处理<br></div>\n\n<h2 id=\"不可控组件和可控组件\"><a href=\"#不可控组件和可控组件\" class=\"headerlink\" title=\"不可控组件和可控组件\"></a>不可控组件和可控组件</h2><p><strong>可控组件</strong><br>设置了 <code>value</code> 的 <code>&lt;input&gt;</code> 是一个受限组件。 对于受限的 <code>&lt;input&gt;</code>，渲染出来的 HTML 元素始终保持 <code>value</code> 属性的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">    return &lt;input type=&quot;text&quot; value=&quot;Hello!&quot;/&gt;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码将渲染出一个值为 Hello! 的 input 元素。用户在渲染出来的元素里输入任何值都不起作用，因为 React 已经赋值为 Hello!。如果想响应更新用户输入的值，就得使用 onChange 事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getInitialState: function() &#123;</span><br><span class=\"line\">    return &#123;value: &apos;Hello!&apos;&#125;;</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> handleChange: function(event) &#123;</span><br><span class=\"line\">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> render: function() &#123;</span><br><span class=\"line\">    var value = this.state.value;</span><br><span class=\"line\">    return &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Default Value</strong><br>初始值是状态中的value。如果要取数据，可直接使用 <code>var inputValue = this.state.value</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">   return &lt;input type=&quot;text&quot; defaultValue=&#123;this.state.value&#125;/&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><div class=\"tip\"><br>一个可控组件并不保持自己的原始状态；组件的呈现完全基于属性。<br></div><br><strong>实例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Kekong = React.creatClass(&#123;</span><br><span class=\"line\">    getInitialState:function()&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            dada:&apos;shuaige&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange:function(e)&#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            dada:e.target.value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    submitHandler:function(e)&#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        alert(this.state.dada);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render:function()&#123;</span><br><span class=\"line\">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; value=&#123;this.state.dada&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class=\"line\">            &lt;button type=&quot;submit&quot;&gt;speak&lt;/button&gt;</span><br><span class=\"line\">        &lt;/form&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;Kekong /&gt;,document.body);</span><br></pre></td></tr></table></figure></p>\n<p><strong>不可控组件</strong><br>没有设置value(或者设为null) 的<code>&lt;input&gt;</code>组件是一个不可控组件。这样的话，组件中的数据和state中的数据并不对应，可以说，组件的数据不可控。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">    return &lt;input type=&quot;text&quot; /&gt;;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码将渲染出一个空值的输入框，用户输入将立即反应到元素上。和受限元素一样，使用 onChange 事件可以监听值的变化。<br><strong>Default Value</strong><br>如果想给组件设置一个非空的初始值，可以使用 defaultValue 属性。 数据在这里并没有存贮在状态中，而是写在input中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render: function() &#123;</span><br><span class=\"line\">   return &lt;input type=&quot;text&quot; defaultValue=&quot;Hello!&quot; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果要拿到input中的value，需先拿到其DOM节点，然后获取其value值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var inputValue = React.findDOMNode(this.refs.input).value</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码渲染出来的元素和受限组件一样有一个初始值，但这个值用户可以改变并会反应到界面上。<br>同样，<code>&lt;input type=&quot;checkbox&quot;&gt;</code>和<code>&lt;input type=&quot;radio&quot;&gt;</code>支持defaultChecked属性，<code>&lt;select&gt;</code>支持设置defaultValue。<br><code>defaultValue</code>和<code>defaultChecked</code>属性只能在初始的render函数中使用，如果你要在随后的render函数中更新value值，你需要使用可控组件。</p>\n<p><strong>实例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var UnKekong = React.creatClass(&#123;</span><br><span class=\"line\">    submitHandler:function(e)&#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        var helloUnke = React.findDOMNode(this.refs.helloUnke).value;</span><br><span class=\"line\">        alert(helloUnke);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render:function()&#123;</span><br><span class=\"line\">        return &lt;form onsubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">            &lt;input ref=&quot;helloUnke&quot; type=&quot;text&quot; defaultValue=&quot;Dada shuaige&quot; /&gt;</span><br><span class=\"line\">            &lt;button type=&quot;submit&quot;&gt;speak&lt;/button&gt;</span><br><span class=\"line\">        &lt;/form&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">React.render(&lt;Unkekong /&gt;,document.body);</span><br></pre></td></tr></table></figure></p>\n<p><strong>Checkbox和Radio的潜在问题</strong></p>\n<p><div class=\"tip\"><br>注意，在试图改变正常处理Checkbox和Radio input时，React用一个click事件来代替change事件。大多数情况下，这种行为与预期相同，除了调用preventDefault时。preventDefault从视觉上阻止浏览器更新input，即使checked被触发。它可以在移除调用preventDefault与用setTimeout来切换checked中起作用。<br></div><br><strong>Why use Controlled Components</strong><br>组件可控的优点：</p>\n<ul>\n<li>符合React的数据流，单向数据流，从state流向render输出的结果。</li>\n<li>数据存贮在state中，便于使用。</li>\n<li>便于对数据进行处理</li>\n</ul>\n<h2 id=\"表单元素\"><a href=\"#表单元素\" class=\"headerlink\" title=\"表单元素\"></a>表单元素</h2><ul>\n<li><code>&lt;label htmlFor=&quot;name&quot;&gt;Name&lt;/label&gt;</code></li>\n<li>要注意for是js关键字，要写成htmlFor。具体JSX语法在之间笔记中有介绍，传送门：React.js学习笔记之JSX解读。现在多数提示用input的placeholder属性替代。</li>\n<li><code>&lt;input type=&quot;&quot; onChange={this.handleChange}/&gt;</code></li>\n<li><code>&lt;textarea onChange={this.handleChange}/&gt;</code></li>\n<li><code>&lt;select onChange={this.handleChange}&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt;</code></li>\n</ul>\n<p><strong>实例</strong><br><a href=\"https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3\" target=\"_blank\" rel=\"noopener\">这是一个demo传送门</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyForm = React.createClass(&#123;</span><br><span class=\"line\">getInitialState:function()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        username:&apos;&apos;,</span><br><span class=\"line\">        gender:&apos;man&apos;,</span><br><span class=\"line\">        checked:true</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">handleUsernameChange:function(e)&#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        username:e.target.value</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">handlerGenderChange:function(e)&#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        gender:e.target.value</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">handleCheckedChange:function(e)&#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        checked:e.target.checked</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">submitHandler:function (e) &#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    console.log(this.state);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">render:function () &#123;</span><br><span class=\"line\">    return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">        &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; onChange=&#123;this.handleUsernameChange&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">        &lt;select onChange=&#123;this.handlerGenderChange&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class=\"line\">            &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class=\"line\">            &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class=\"line\">        &lt;/select&gt;</span><br><span class=\"line\">        &lt;br/&gt;</span><br><span class=\"line\">        &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class=\"line\">        &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleCheckedChange&#125; id=&quot;checkbox&quot;/&gt;</span><br><span class=\"line\">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">    &lt;/form&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onChange=&#123;this.handleChange&#125;</span><br></pre></td></tr></table></figure>\n<p>若有多个元素要运用事件处理函数，常规的方法是编写多个onChange事件。这么写的话会导致代码维护比较困难并且也非常冗余。更好的做法是把事件处理函数编写为一个。可以采用bind复用和name复用这两种方法。</p>\n<p><strong>bind复用</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleChange:function(name,event)&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">onChagne=&#123;this.handleChange.bind(this,&apos;input&apos;)&#125;</span><br></pre></td></tr></table></figure></p>\n<p>书写简单，但需要对bind()机制熟悉，性能相对要好。</p>\n<p><strong>实例</strong><br><a href=\"https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3\" target=\"_blank\" rel=\"noopener\">这是一个demo传送门</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyForm = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState:function()&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            username:&apos;&apos;,</span><br><span class=\"line\">            gender:&apos;man&apos;,</span><br><span class=\"line\">            checked:true</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange:function(name,event)&#123;</span><br><span class=\"line\">        var newState=&#123;&#125;;</span><br><span class=\"line\">        newState[name]=name==&quot;checked&quot;?event.target.checked:event.target.value;</span><br><span class=\"line\">        this.setState(newState);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    submitHandler:function (e) &#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        console.log(this.state);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render:function () &#123;</span><br><span class=\"line\">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">            &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; onChange=&#123;this.handleChange.bind(this,&quot;username&quot;)&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;select onChange=&#123;this.handleChange.bind(this,&quot;gender&quot;)&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class=\"line\">                &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class=\"line\">                &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange.bind(this,&quot;checked&quot;)&#125; id=&quot;checkbox&quot;/&gt;</span><br><span class=\"line\">            &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">        &lt;/form&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p>\n<p><strong>name复用</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleChange:function(event)&#123;</span><br><span class=\"line\">    var name = event.target.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">onChange=&#123;this.handleChange&#125;</span><br></pre></td></tr></table></figure></p>\n<p>相比Bind写法会少一些参数，在函数中需要读取表单的name值，需要添加name属性。</p>\n<p><strong>实例</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyForm = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState:function()&#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            username:&apos;&apos;,</span><br><span class=\"line\">            gender:&apos;man&apos;,</span><br><span class=\"line\">            checked:true</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange:function(event)&#123;</span><br><span class=\"line\">        var newState=&#123;&#125;;</span><br><span class=\"line\">        newState[event.target.name]=event.target.name==&quot;checked&quot;?event.target.checked:event.target.value;</span><br><span class=\"line\">        this.setState(newState);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    submitHandler:function (e) &#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        console.log(this.state);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render:function () &#123;</span><br><span class=\"line\">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class=\"line\">            &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; name=&quot;username&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;select name=&quot;gender&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class=\"line\">                &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class=\"line\">                &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">            &lt;br/&gt;</span><br><span class=\"line\">            &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange&#125; name=&quot;checked&quot; id=&quot;checkbox&quot;/&gt;</span><br><span class=\"line\">            &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">        &lt;/form&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"自定义表单组件\"><a href=\"#自定义表单组件\" class=\"headerlink\" title=\"自定义表单组件\"></a>自定义表单组件</h2><p>自定义表单组件能让我们更好的使用组件，让我们更好的开发网页。</p>\n<p><strong>why 自定义表单组件？</strong><br>自定义表单组件的原因：</p>\n<ul>\n<li>内因：表单本身具备特殊性：样式统一、信息内聚、行为固定</li>\n<li>外因：本质上是组件的嵌套，组织和管理组件的一种方式</li>\n</ul>"},{"title":"基于Vue SEO的四种方案","abbrlink":53312,"date":"2019-06-30T11:29:45.000Z","_content":"前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。\n\n- 1.SSR服务器渲染；\n- 2.静态化；\n- 3.预渲染prerender-spa-plugin；\n- 4.使用Phantomjs针对爬虫做处理。\n\n## 1.SSR服务器渲染\n关于服务器渲染：[Vue官网介绍](https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F)，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。\n\n**使用SSR权衡之处：**\n- 开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行；\n- 环境和部署要求更高，需要Node.js server 运行环境；\n- 高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。\n\n**优势：**\n- 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；\n- 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。\n\n\n\n**不足：（开发中遇到的坑）**\n1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：\n```\nif(process.browser){\n console.log(window);\n}\n```\n引用npm包，带有dom操作的，例如：`wowjs`，不能用`import`的方式，改用：\n```\nif (process.browser) {\n     var { WOW } = require('wowjs');\n     require('wowjs/css/libs/animate.css');\n }\n```\n2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于**页面组件**调用：\n\n```\n// 并发加载多个接口：\n  async asyncData ({ app, query }) {\n    let [resA, resB, resC] = await Promise.all([\n      app.$axios.get('/api/a'),\n      app.$axios.get('/api/b'),\n      app.$axios.get('/api/c'),\n     ])\n\n     return {\n       dataA: resA.data,\n       dataB: resB.data,\n       dataC: resC.data,\n     }\n  }\n```\n在asyncData中获取参数：\n```\n1.获取动态路由参数，如：\n\n/list/:id' ==>  '/list/123\n\n接收：\n\nasync asyncData ({ app, query }) {\n  console.log(app.context.params.id) //123\n}\n2.获取url?获取参数，如：\n\n/list?id=123\n\n接收：\n\nasync asyncData ({ app, query }) {\n  console.log(query.id) //123\n}\n```\n\n3.如果你使用`v-if`语法，部署到线上大概也会遇到这个错误：\n```\nError while initializing app DOMException: Failed to execute 'appendChild' on 'Node': This node type does not support this method.\n    at Object.We [as appendChild]\n```\n根据github nuxt上的[issue第1552条](https://github.com/nuxt/nuxt.js/issues/1552)提示，要将`v-if`改为`v-show`语法。\n\n4.坑太多，留坑，晚点更。\n\n## 2.静态化\n\n静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。\n在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。\n```\n-| pages/\n---| index.vue\n---| users/\n-----| _id.vue\n```\n需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。\n```\n// nuxt.config.js\nmodule.exports = {\n  generate: {\n    routes: [\n      '/users/1',\n      '/users/2',\n      '/users/3'\n    ]\n  }\n}\n```\n运行打包，即可看见打包出来的页面。\n但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？\n- 使用一个返回 Promise 对象类型 的 函数；\n- 使用一个回调是 callback(err, params) 的 函数。\n```\n// nuxt.config.js\nimport axios from 'axios'\n\nexport default {\n  generate: {\n    routes: function () {\n      return axios.get('https://my-api/users')\n      .then((res) => {\n        return res.data.map((user) => {\n          return {\n            route: '/users/' + user.id,\n            payload: user\n          }\n        })\n      })\n    }\n  }\n}\n```\n现在我们可以从`/users/_id.vue`访问的`payload`，如下所示：\n```\nasync asyncData ({ params, error, payload }) {\n  if (payload) return { user: payload }\n  else return { user: await backend.fetchUser(params.id) }\n}\n```\n如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。\n**优势：**\n- 纯静态文件，访问速度超快；\n- 对比SSR，不涉及到服务器负载方面问题；\n- 静态网页不宜遭到黑客攻击，安全性更高。\n\n**不足：**\n- 如果动态路由参数多的话不适用。\n\n## 3.预渲染prerender-spa-plugin\n如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。\n```\n$ cnpm install prerender-spa-plugin --save\n```\nvue cli 3 `vue.config.js`配置：\n```\nconst PrerenderSPAPlugin = require('prerender-spa-plugin');\nconst Renderer = PrerenderSPAPlugin.PuppeteerRenderer;\nconst path = require('path');\nmodule.exports = {\n    configureWebpack: config => {\n        if (process.env.NODE_ENV !== 'production') return;\n        return {\n            plugins: [\n                new PrerenderSPAPlugin({\n                    // 生成文件的路径，也可以与webpakc打包的一致。\n                    // 下面这句话非常重要！！！\n                    // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。\n                    staticDir: path.join(__dirname,'dist'),\n                    // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。\n                    routes: ['/', '/product','/about'],\n                    // 这个很重要，如果没有配置这段，也不会进行预编译\n                    renderer: new Renderer({\n                        inject: {\n                            foo: 'bar'\n                        },\n                        headless: false,\n                        // 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。\n                        renderAfterDocumentEvent: 'render-event'\n                    })\n                }),\n            ],\n        };\n    }\n}\n```\n在main.js中添加：\n```\nnew Vue({\n  router,\n  render: h => h(App),\n  mounted () {\n    document.dispatchEvent(new Event('render-event'))\n  }\n}).$mount('#app')\n```\n注意：router中必须设置 `mode: “history”`。\n\n打包出来可以看见文件，打包出文件夹`/index.html`，例如：`about` => `about/index.html`，里面有html内容。\n\n**优势：**\n- 改动小，引入个插件就完事；\n\n**不足：**\n- 无法使用动态路由；\n- 只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢；\n\n\n\n## 4.使用Phantomjs针对爬虫做处理\nPhantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。\n虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。\n这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，**判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。**\n\n![图片描述][1]\n\n\n  [1]: https://image-static.segmentfault.com/320/346/3203467011-5d18823332fe1_articlex\n\n具体代码戳这里：[vue-seo-phantomjs](https://github.com/lengziyu/vue-seo-phantomjs)。\n要安装全局`phantomjs`，局部`express`，测试：\n```\n$ phantomjs spider.js 'https://www.baidu.com'\n```\n如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。\n启动之后或者用postman在请求头增加`User-Agent`值为`Baiduspider`，效果一样的。\n\n\n**部署上线**\n线上要安装`node`、`pm2`、`phantomjs`，nginx相关配置：\n\n```\nupstream spider_server {\n  server localhost:3000;\n}\n\nserver {\n    listen       80;\n    server_name  example.com;\n\n    location / {\n      proxy_set_header  Host            $host:$proxy_port;\n      proxy_set_header  X-Real-IP       $remote_addr;\n      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n\n      if ($http_user_agent ~* \"Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider\") {\n        proxy_pass  http://spider_server;\n      }\n    }\n}\n```\n**优势：**\n- 完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多；\n- 对已用SPA开发完成的项目，这是不二之选。\n\n**不足：**\n- 部署需要node服务器支持；\n- 爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；\n- 如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。\n\n\n### 总结\n如果构建大型网站，如商城类，别犹豫，直接上SSR服务器渲染，当然也有相应的坑等你，社区较成熟，英文好点，一切问题都迎刃而解。\n如果只是个人博客、公司官网这类，其余三种都可以。\n如果对已用SPA开发完成的项目进行SEO优化，而且支持node服务器，请使用`Phantomjs`。\n\n很少写文章，这是我这个月对Vue SEO方案的探索，写的不对的地方请指出，谢谢理解~\n","source":"_posts/vue-seo.md","raw":"---\ntitle: 基于Vue SEO的四种方案\ntags:\n  - Vue\n  - SEO\n  - Phantomjs\ncategories: Vue\nabbrlink: 53312\ndate: 2019-06-30 19:29:45\n---\n前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。\n\n- 1.SSR服务器渲染；\n- 2.静态化；\n- 3.预渲染prerender-spa-plugin；\n- 4.使用Phantomjs针对爬虫做处理。\n\n## 1.SSR服务器渲染\n关于服务器渲染：[Vue官网介绍](https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F)，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。\n\n**使用SSR权衡之处：**\n- 开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行；\n- 环境和部署要求更高，需要Node.js server 运行环境；\n- 高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。\n\n**优势：**\n- 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；\n- 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。\n\n\n\n**不足：（开发中遇到的坑）**\n1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：\n```\nif(process.browser){\n console.log(window);\n}\n```\n引用npm包，带有dom操作的，例如：`wowjs`，不能用`import`的方式，改用：\n```\nif (process.browser) {\n     var { WOW } = require('wowjs');\n     require('wowjs/css/libs/animate.css');\n }\n```\n2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于**页面组件**调用：\n\n```\n// 并发加载多个接口：\n  async asyncData ({ app, query }) {\n    let [resA, resB, resC] = await Promise.all([\n      app.$axios.get('/api/a'),\n      app.$axios.get('/api/b'),\n      app.$axios.get('/api/c'),\n     ])\n\n     return {\n       dataA: resA.data,\n       dataB: resB.data,\n       dataC: resC.data,\n     }\n  }\n```\n在asyncData中获取参数：\n```\n1.获取动态路由参数，如：\n\n/list/:id' ==>  '/list/123\n\n接收：\n\nasync asyncData ({ app, query }) {\n  console.log(app.context.params.id) //123\n}\n2.获取url?获取参数，如：\n\n/list?id=123\n\n接收：\n\nasync asyncData ({ app, query }) {\n  console.log(query.id) //123\n}\n```\n\n3.如果你使用`v-if`语法，部署到线上大概也会遇到这个错误：\n```\nError while initializing app DOMException: Failed to execute 'appendChild' on 'Node': This node type does not support this method.\n    at Object.We [as appendChild]\n```\n根据github nuxt上的[issue第1552条](https://github.com/nuxt/nuxt.js/issues/1552)提示，要将`v-if`改为`v-show`语法。\n\n4.坑太多，留坑，晚点更。\n\n## 2.静态化\n\n静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。\n在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。\n```\n-| pages/\n---| index.vue\n---| users/\n-----| _id.vue\n```\n需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。\n```\n// nuxt.config.js\nmodule.exports = {\n  generate: {\n    routes: [\n      '/users/1',\n      '/users/2',\n      '/users/3'\n    ]\n  }\n}\n```\n运行打包，即可看见打包出来的页面。\n但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？\n- 使用一个返回 Promise 对象类型 的 函数；\n- 使用一个回调是 callback(err, params) 的 函数。\n```\n// nuxt.config.js\nimport axios from 'axios'\n\nexport default {\n  generate: {\n    routes: function () {\n      return axios.get('https://my-api/users')\n      .then((res) => {\n        return res.data.map((user) => {\n          return {\n            route: '/users/' + user.id,\n            payload: user\n          }\n        })\n      })\n    }\n  }\n}\n```\n现在我们可以从`/users/_id.vue`访问的`payload`，如下所示：\n```\nasync asyncData ({ params, error, payload }) {\n  if (payload) return { user: payload }\n  else return { user: await backend.fetchUser(params.id) }\n}\n```\n如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。\n**优势：**\n- 纯静态文件，访问速度超快；\n- 对比SSR，不涉及到服务器负载方面问题；\n- 静态网页不宜遭到黑客攻击，安全性更高。\n\n**不足：**\n- 如果动态路由参数多的话不适用。\n\n## 3.预渲染prerender-spa-plugin\n如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。\n```\n$ cnpm install prerender-spa-plugin --save\n```\nvue cli 3 `vue.config.js`配置：\n```\nconst PrerenderSPAPlugin = require('prerender-spa-plugin');\nconst Renderer = PrerenderSPAPlugin.PuppeteerRenderer;\nconst path = require('path');\nmodule.exports = {\n    configureWebpack: config => {\n        if (process.env.NODE_ENV !== 'production') return;\n        return {\n            plugins: [\n                new PrerenderSPAPlugin({\n                    // 生成文件的路径，也可以与webpakc打包的一致。\n                    // 下面这句话非常重要！！！\n                    // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。\n                    staticDir: path.join(__dirname,'dist'),\n                    // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。\n                    routes: ['/', '/product','/about'],\n                    // 这个很重要，如果没有配置这段，也不会进行预编译\n                    renderer: new Renderer({\n                        inject: {\n                            foo: 'bar'\n                        },\n                        headless: false,\n                        // 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。\n                        renderAfterDocumentEvent: 'render-event'\n                    })\n                }),\n            ],\n        };\n    }\n}\n```\n在main.js中添加：\n```\nnew Vue({\n  router,\n  render: h => h(App),\n  mounted () {\n    document.dispatchEvent(new Event('render-event'))\n  }\n}).$mount('#app')\n```\n注意：router中必须设置 `mode: “history”`。\n\n打包出来可以看见文件，打包出文件夹`/index.html`，例如：`about` => `about/index.html`，里面有html内容。\n\n**优势：**\n- 改动小，引入个插件就完事；\n\n**不足：**\n- 无法使用动态路由；\n- 只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢；\n\n\n\n## 4.使用Phantomjs针对爬虫做处理\nPhantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。\n虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。\n这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，**判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。**\n\n![图片描述][1]\n\n\n  [1]: https://image-static.segmentfault.com/320/346/3203467011-5d18823332fe1_articlex\n\n具体代码戳这里：[vue-seo-phantomjs](https://github.com/lengziyu/vue-seo-phantomjs)。\n要安装全局`phantomjs`，局部`express`，测试：\n```\n$ phantomjs spider.js 'https://www.baidu.com'\n```\n如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。\n启动之后或者用postman在请求头增加`User-Agent`值为`Baiduspider`，效果一样的。\n\n\n**部署上线**\n线上要安装`node`、`pm2`、`phantomjs`，nginx相关配置：\n\n```\nupstream spider_server {\n  server localhost:3000;\n}\n\nserver {\n    listen       80;\n    server_name  example.com;\n\n    location / {\n      proxy_set_header  Host            $host:$proxy_port;\n      proxy_set_header  X-Real-IP       $remote_addr;\n      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n\n      if ($http_user_agent ~* \"Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider\") {\n        proxy_pass  http://spider_server;\n      }\n    }\n}\n```\n**优势：**\n- 完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多；\n- 对已用SPA开发完成的项目，这是不二之选。\n\n**不足：**\n- 部署需要node服务器支持；\n- 爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；\n- 如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。\n\n\n### 总结\n如果构建大型网站，如商城类，别犹豫，直接上SSR服务器渲染，当然也有相应的坑等你，社区较成熟，英文好点，一切问题都迎刃而解。\n如果只是个人博客、公司官网这类，其余三种都可以。\n如果对已用SPA开发完成的项目进行SEO优化，而且支持node服务器，请使用`Phantomjs`。\n\n很少写文章，这是我这个月对Vue SEO方案的探索，写的不对的地方请指出，谢谢理解~\n","slug":"vue-seo","published":1,"updated":"2019-08-15T15:18:08.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhkp001qxknwcrhlosia","content":"<p>前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。</p>\n<ul>\n<li>1.SSR服务器渲染；</li>\n<li>2.静态化；</li>\n<li>3.预渲染prerender-spa-plugin；</li>\n<li>4.使用Phantomjs针对爬虫做处理。</li>\n</ul>\n<h2 id=\"1-SSR服务器渲染\"><a href=\"#1-SSR服务器渲染\" class=\"headerlink\" title=\"1.SSR服务器渲染\"></a>1.SSR服务器渲染</h2><p>关于服务器渲染：<a href=\"https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F\" target=\"_blank\" rel=\"noopener\">Vue官网介绍</a>，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。</p>\n<p><strong>使用SSR权衡之处：</strong></p>\n<ul>\n<li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行；</li>\n<li>环境和部署要求更高，需要Node.js server 运行环境；</li>\n<li>高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。</li>\n</ul>\n<p><strong>优势：</strong></p>\n<ul>\n<li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；</li>\n<li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</li>\n</ul>\n<p><strong>不足：（开发中遇到的坑）</strong><br>1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(process.browser)&#123;</span><br><span class=\"line\"> console.log(window);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>引用npm包，带有dom操作的，例如：<code>wowjs</code>，不能用<code>import</code>的方式，改用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (process.browser) &#123;</span><br><span class=\"line\">     var &#123; WOW &#125; = require(&apos;wowjs&apos;);</span><br><span class=\"line\">     require(&apos;wowjs/css/libs/animate.css&apos;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于<strong>页面组件</strong>调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 并发加载多个接口：</span><br><span class=\"line\">  async asyncData (&#123; app, query &#125;) &#123;</span><br><span class=\"line\">    let [resA, resB, resC] = await Promise.all([</span><br><span class=\"line\">      app.$axios.get(&apos;/api/a&apos;),</span><br><span class=\"line\">      app.$axios.get(&apos;/api/b&apos;),</span><br><span class=\"line\">      app.$axios.get(&apos;/api/c&apos;),</span><br><span class=\"line\">     ])</span><br><span class=\"line\"></span><br><span class=\"line\">     return &#123;</span><br><span class=\"line\">       dataA: resA.data,</span><br><span class=\"line\">       dataB: resB.data,</span><br><span class=\"line\">       dataC: resC.data,</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>在asyncData中获取参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.获取动态路由参数，如：</span><br><span class=\"line\"></span><br><span class=\"line\">/list/:id&apos; ==&gt;  &apos;/list/123</span><br><span class=\"line\"></span><br><span class=\"line\">接收：</span><br><span class=\"line\"></span><br><span class=\"line\">async asyncData (&#123; app, query &#125;) &#123;</span><br><span class=\"line\">  console.log(app.context.params.id) //123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2.获取url?获取参数，如：</span><br><span class=\"line\"></span><br><span class=\"line\">/list?id=123</span><br><span class=\"line\"></span><br><span class=\"line\">接收：</span><br><span class=\"line\"></span><br><span class=\"line\">async asyncData (&#123; app, query &#125;) &#123;</span><br><span class=\"line\">  console.log(query.id) //123</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.如果你使用<code>v-if</code>语法，部署到线上大概也会遇到这个错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error while initializing app DOMException: Failed to execute &apos;appendChild&apos; on &apos;Node&apos;: This node type does not support this method.</span><br><span class=\"line\">    at Object.We [as appendChild]</span><br></pre></td></tr></table></figure></p>\n<p>根据github nuxt上的<a href=\"https://github.com/nuxt/nuxt.js/issues/1552\" target=\"_blank\" rel=\"noopener\">issue第1552条</a>提示，要将<code>v-if</code>改为<code>v-show</code>语法。</p>\n<p>4.坑太多，留坑，晚点更。</p>\n<h2 id=\"2-静态化\"><a href=\"#2-静态化\" class=\"headerlink\" title=\"2.静态化\"></a>2.静态化</h2><p>静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。<br>在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-| pages/</span><br><span class=\"line\">---| index.vue</span><br><span class=\"line\">---| users/</span><br><span class=\"line\">-----| _id.vue</span><br></pre></td></tr></table></figure></p>\n<p>需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nuxt.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  generate: &#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      &apos;/users/1&apos;,</span><br><span class=\"line\">      &apos;/users/2&apos;,</span><br><span class=\"line\">      &apos;/users/3&apos;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行打包，即可看见打包出来的页面。<br>但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？</p>\n<ul>\n<li>使用一个返回 Promise 对象类型 的 函数；</li>\n<li>使用一个回调是 callback(err, params) 的 函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nuxt.config.js</span><br><span class=\"line\">import axios from &apos;axios&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  generate: &#123;</span><br><span class=\"line\">    routes: function () &#123;</span><br><span class=\"line\">      return axios.get(&apos;https://my-api/users&apos;)</span><br><span class=\"line\">      .then((res) =&gt; &#123;</span><br><span class=\"line\">        return res.data.map((user) =&gt; &#123;</span><br><span class=\"line\">          return &#123;</span><br><span class=\"line\">            route: &apos;/users/&apos; + user.id,</span><br><span class=\"line\">            payload: user</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在我们可以从<code>/users/_id.vue</code>访问的<code>payload</code>，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async asyncData (&#123; params, error, payload &#125;) &#123;</span><br><span class=\"line\">  if (payload) return &#123; user: payload &#125;</span><br><span class=\"line\">  else return &#123; user: await backend.fetchUser(params.id) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。<br><strong>优势：</strong></p>\n<ul>\n<li>纯静态文件，访问速度超快；</li>\n<li>对比SSR，不涉及到服务器负载方面问题；</li>\n<li>静态网页不宜遭到黑客攻击，安全性更高。</li>\n</ul>\n<p><strong>不足：</strong></p>\n<ul>\n<li>如果动态路由参数多的话不适用。</li>\n</ul>\n<h2 id=\"3-预渲染prerender-spa-plugin\"><a href=\"#3-预渲染prerender-spa-plugin\" class=\"headerlink\" title=\"3.预渲染prerender-spa-plugin\"></a>3.预渲染prerender-spa-plugin</h2><p>如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install prerender-spa-plugin --save</span><br></pre></td></tr></table></figure></p>\n<p>vue cli 3 <code>vue.config.js</code>配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PrerenderSPAPlugin = require(&apos;prerender-spa-plugin&apos;);</span><br><span class=\"line\">const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    configureWebpack: config =&gt; &#123;</span><br><span class=\"line\">        if (process.env.NODE_ENV !== &apos;production&apos;) return;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            plugins: [</span><br><span class=\"line\">                new PrerenderSPAPlugin(&#123;</span><br><span class=\"line\">                    // 生成文件的路径，也可以与webpakc打包的一致。</span><br><span class=\"line\">                    // 下面这句话非常重要！！！</span><br><span class=\"line\">                    // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。</span><br><span class=\"line\">                    staticDir: path.join(__dirname,&apos;dist&apos;),</span><br><span class=\"line\">                    // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。</span><br><span class=\"line\">                    routes: [&apos;/&apos;, &apos;/product&apos;,&apos;/about&apos;],</span><br><span class=\"line\">                    // 这个很重要，如果没有配置这段，也不会进行预编译</span><br><span class=\"line\">                    renderer: new Renderer(&#123;</span><br><span class=\"line\">                        inject: &#123;</span><br><span class=\"line\">                            foo: &apos;bar&apos;</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        headless: false,</span><br><span class=\"line\">                        // 在 main.js 中 document.dispatchEvent(new Event(&apos;render-event&apos;))，两者的事件名称要对应上。</span><br><span class=\"line\">                        renderAfterDocumentEvent: &apos;render-event&apos;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">            ],</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在main.js中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  render: h =&gt; h(App),</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    document.dispatchEvent(new Event(&apos;render-event&apos;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>\n<p>注意：router中必须设置 <code>mode: “history”</code>。</p>\n<p>打包出来可以看见文件，打包出文件夹<code>/index.html</code>，例如：<code>about</code> =&gt; <code>about/index.html</code>，里面有html内容。</p>\n<p><strong>优势：</strong></p>\n<ul>\n<li>改动小，引入个插件就完事；</li>\n</ul>\n<p><strong>不足：</strong></p>\n<ul>\n<li>无法使用动态路由；</li>\n<li>只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢；</li>\n</ul>\n<h2 id=\"4-使用Phantomjs针对爬虫做处理\"><a href=\"#4-使用Phantomjs针对爬虫做处理\" class=\"headerlink\" title=\"4.使用Phantomjs针对爬虫做处理\"></a>4.使用Phantomjs针对爬虫做处理</h2><p>Phantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。<br>虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。<br>这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，<strong>判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。</strong></p>\n<p><img src=\"https://image-static.segmentfault.com/320/346/3203467011-5d18823332fe1_articlex\" alt=\"图片描述\"></p>\n<p>具体代码戳这里：<a href=\"https://github.com/lengziyu/vue-seo-phantomjs\" target=\"_blank\" rel=\"noopener\">vue-seo-phantomjs</a>。<br>要安装全局<code>phantomjs</code>，局部<code>express</code>，测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ phantomjs spider.js &apos;https://www.baidu.com&apos;</span><br></pre></td></tr></table></figure></p>\n<p>如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。<br>启动之后或者用postman在请求头增加<code>User-Agent</code>值为<code>Baiduspider</code>，效果一样的。</p>\n<p><strong>部署上线</strong><br>线上要安装<code>node</code>、<code>pm2</code>、<code>phantomjs</code>，nginx相关配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream spider_server &#123;</span><br><span class=\"line\">  server localhost:3000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">      proxy_set_header  Host            $host:$proxy_port;</span><br><span class=\"line\">      proxy_set_header  X-Real-IP       $remote_addr;</span><br><span class=\"line\">      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\"></span><br><span class=\"line\">      if ($http_user_agent ~* &quot;Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider&quot;) &#123;</span><br><span class=\"line\">        proxy_pass  http://spider_server;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优势：</strong></p>\n<ul>\n<li>完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多；</li>\n<li>对已用SPA开发完成的项目，这是不二之选。</li>\n</ul>\n<p><strong>不足：</strong></p>\n<ul>\n<li>部署需要node服务器支持；</li>\n<li>爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；</li>\n<li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果构建大型网站，如商城类，别犹豫，直接上SSR服务器渲染，当然也有相应的坑等你，社区较成熟，英文好点，一切问题都迎刃而解。<br>如果只是个人博客、公司官网这类，其余三种都可以。<br>如果对已用SPA开发完成的项目进行SEO优化，而且支持node服务器，请使用<code>Phantomjs</code>。</p>\n<p>很少写文章，这是我这个月对Vue SEO方案的探索，写的不对的地方请指出，谢谢理解~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。</p>\n<ul>\n<li>1.SSR服务器渲染；</li>\n<li>2.静态化；</li>\n<li>3.预渲染prerender-spa-plugin；</li>\n<li>4.使用Phantomjs针对爬虫做处理。</li>\n</ul>\n<h2 id=\"1-SSR服务器渲染\"><a href=\"#1-SSR服务器渲染\" class=\"headerlink\" title=\"1.SSR服务器渲染\"></a>1.SSR服务器渲染</h2><p>关于服务器渲染：<a href=\"https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F\" target=\"_blank\" rel=\"noopener\">Vue官网介绍</a>，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。</p>\n<p><strong>使用SSR权衡之处：</strong></p>\n<ul>\n<li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行；</li>\n<li>环境和部署要求更高，需要Node.js server 运行环境；</li>\n<li>高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。</li>\n</ul>\n<p><strong>优势：</strong></p>\n<ul>\n<li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；</li>\n<li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</li>\n</ul>\n<p><strong>不足：（开发中遇到的坑）</strong><br>1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(process.browser)&#123;</span><br><span class=\"line\"> console.log(window);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>引用npm包，带有dom操作的，例如：<code>wowjs</code>，不能用<code>import</code>的方式，改用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (process.browser) &#123;</span><br><span class=\"line\">     var &#123; WOW &#125; = require(&apos;wowjs&apos;);</span><br><span class=\"line\">     require(&apos;wowjs/css/libs/animate.css&apos;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于<strong>页面组件</strong>调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 并发加载多个接口：</span><br><span class=\"line\">  async asyncData (&#123; app, query &#125;) &#123;</span><br><span class=\"line\">    let [resA, resB, resC] = await Promise.all([</span><br><span class=\"line\">      app.$axios.get(&apos;/api/a&apos;),</span><br><span class=\"line\">      app.$axios.get(&apos;/api/b&apos;),</span><br><span class=\"line\">      app.$axios.get(&apos;/api/c&apos;),</span><br><span class=\"line\">     ])</span><br><span class=\"line\"></span><br><span class=\"line\">     return &#123;</span><br><span class=\"line\">       dataA: resA.data,</span><br><span class=\"line\">       dataB: resB.data,</span><br><span class=\"line\">       dataC: resC.data,</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>在asyncData中获取参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.获取动态路由参数，如：</span><br><span class=\"line\"></span><br><span class=\"line\">/list/:id&apos; ==&gt;  &apos;/list/123</span><br><span class=\"line\"></span><br><span class=\"line\">接收：</span><br><span class=\"line\"></span><br><span class=\"line\">async asyncData (&#123; app, query &#125;) &#123;</span><br><span class=\"line\">  console.log(app.context.params.id) //123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2.获取url?获取参数，如：</span><br><span class=\"line\"></span><br><span class=\"line\">/list?id=123</span><br><span class=\"line\"></span><br><span class=\"line\">接收：</span><br><span class=\"line\"></span><br><span class=\"line\">async asyncData (&#123; app, query &#125;) &#123;</span><br><span class=\"line\">  console.log(query.id) //123</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.如果你使用<code>v-if</code>语法，部署到线上大概也会遇到这个错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error while initializing app DOMException: Failed to execute &apos;appendChild&apos; on &apos;Node&apos;: This node type does not support this method.</span><br><span class=\"line\">    at Object.We [as appendChild]</span><br></pre></td></tr></table></figure></p>\n<p>根据github nuxt上的<a href=\"https://github.com/nuxt/nuxt.js/issues/1552\" target=\"_blank\" rel=\"noopener\">issue第1552条</a>提示，要将<code>v-if</code>改为<code>v-show</code>语法。</p>\n<p>4.坑太多，留坑，晚点更。</p>\n<h2 id=\"2-静态化\"><a href=\"#2-静态化\" class=\"headerlink\" title=\"2.静态化\"></a>2.静态化</h2><p>静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。<br>在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-| pages/</span><br><span class=\"line\">---| index.vue</span><br><span class=\"line\">---| users/</span><br><span class=\"line\">-----| _id.vue</span><br></pre></td></tr></table></figure></p>\n<p>需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nuxt.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  generate: &#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      &apos;/users/1&apos;,</span><br><span class=\"line\">      &apos;/users/2&apos;,</span><br><span class=\"line\">      &apos;/users/3&apos;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行打包，即可看见打包出来的页面。<br>但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？</p>\n<ul>\n<li>使用一个返回 Promise 对象类型 的 函数；</li>\n<li>使用一个回调是 callback(err, params) 的 函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nuxt.config.js</span><br><span class=\"line\">import axios from &apos;axios&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  generate: &#123;</span><br><span class=\"line\">    routes: function () &#123;</span><br><span class=\"line\">      return axios.get(&apos;https://my-api/users&apos;)</span><br><span class=\"line\">      .then((res) =&gt; &#123;</span><br><span class=\"line\">        return res.data.map((user) =&gt; &#123;</span><br><span class=\"line\">          return &#123;</span><br><span class=\"line\">            route: &apos;/users/&apos; + user.id,</span><br><span class=\"line\">            payload: user</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>现在我们可以从<code>/users/_id.vue</code>访问的<code>payload</code>，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async asyncData (&#123; params, error, payload &#125;) &#123;</span><br><span class=\"line\">  if (payload) return &#123; user: payload &#125;</span><br><span class=\"line\">  else return &#123; user: await backend.fetchUser(params.id) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。<br><strong>优势：</strong></p>\n<ul>\n<li>纯静态文件，访问速度超快；</li>\n<li>对比SSR，不涉及到服务器负载方面问题；</li>\n<li>静态网页不宜遭到黑客攻击，安全性更高。</li>\n</ul>\n<p><strong>不足：</strong></p>\n<ul>\n<li>如果动态路由参数多的话不适用。</li>\n</ul>\n<h2 id=\"3-预渲染prerender-spa-plugin\"><a href=\"#3-预渲染prerender-spa-plugin\" class=\"headerlink\" title=\"3.预渲染prerender-spa-plugin\"></a>3.预渲染prerender-spa-plugin</h2><p>如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install prerender-spa-plugin --save</span><br></pre></td></tr></table></figure></p>\n<p>vue cli 3 <code>vue.config.js</code>配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PrerenderSPAPlugin = require(&apos;prerender-spa-plugin&apos;);</span><br><span class=\"line\">const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    configureWebpack: config =&gt; &#123;</span><br><span class=\"line\">        if (process.env.NODE_ENV !== &apos;production&apos;) return;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            plugins: [</span><br><span class=\"line\">                new PrerenderSPAPlugin(&#123;</span><br><span class=\"line\">                    // 生成文件的路径，也可以与webpakc打包的一致。</span><br><span class=\"line\">                    // 下面这句话非常重要！！！</span><br><span class=\"line\">                    // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。</span><br><span class=\"line\">                    staticDir: path.join(__dirname,&apos;dist&apos;),</span><br><span class=\"line\">                    // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。</span><br><span class=\"line\">                    routes: [&apos;/&apos;, &apos;/product&apos;,&apos;/about&apos;],</span><br><span class=\"line\">                    // 这个很重要，如果没有配置这段，也不会进行预编译</span><br><span class=\"line\">                    renderer: new Renderer(&#123;</span><br><span class=\"line\">                        inject: &#123;</span><br><span class=\"line\">                            foo: &apos;bar&apos;</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        headless: false,</span><br><span class=\"line\">                        // 在 main.js 中 document.dispatchEvent(new Event(&apos;render-event&apos;))，两者的事件名称要对应上。</span><br><span class=\"line\">                        renderAfterDocumentEvent: &apos;render-event&apos;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">            ],</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在main.js中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  render: h =&gt; h(App),</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    document.dispatchEvent(new Event(&apos;render-event&apos;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>\n<p>注意：router中必须设置 <code>mode: “history”</code>。</p>\n<p>打包出来可以看见文件，打包出文件夹<code>/index.html</code>，例如：<code>about</code> =&gt; <code>about/index.html</code>，里面有html内容。</p>\n<p><strong>优势：</strong></p>\n<ul>\n<li>改动小，引入个插件就完事；</li>\n</ul>\n<p><strong>不足：</strong></p>\n<ul>\n<li>无法使用动态路由；</li>\n<li>只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢；</li>\n</ul>\n<h2 id=\"4-使用Phantomjs针对爬虫做处理\"><a href=\"#4-使用Phantomjs针对爬虫做处理\" class=\"headerlink\" title=\"4.使用Phantomjs针对爬虫做处理\"></a>4.使用Phantomjs针对爬虫做处理</h2><p>Phantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。<br>虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。<br>这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，<strong>判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。</strong></p>\n<p><img src=\"https://image-static.segmentfault.com/320/346/3203467011-5d18823332fe1_articlex\" alt=\"图片描述\"></p>\n<p>具体代码戳这里：<a href=\"https://github.com/lengziyu/vue-seo-phantomjs\" target=\"_blank\" rel=\"noopener\">vue-seo-phantomjs</a>。<br>要安装全局<code>phantomjs</code>，局部<code>express</code>，测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ phantomjs spider.js &apos;https://www.baidu.com&apos;</span><br></pre></td></tr></table></figure></p>\n<p>如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。<br>启动之后或者用postman在请求头增加<code>User-Agent</code>值为<code>Baiduspider</code>，效果一样的。</p>\n<p><strong>部署上线</strong><br>线上要安装<code>node</code>、<code>pm2</code>、<code>phantomjs</code>，nginx相关配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream spider_server &#123;</span><br><span class=\"line\">  server localhost:3000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">      proxy_set_header  Host            $host:$proxy_port;</span><br><span class=\"line\">      proxy_set_header  X-Real-IP       $remote_addr;</span><br><span class=\"line\">      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\"></span><br><span class=\"line\">      if ($http_user_agent ~* &quot;Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider&quot;) &#123;</span><br><span class=\"line\">        proxy_pass  http://spider_server;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优势：</strong></p>\n<ul>\n<li>完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多；</li>\n<li>对已用SPA开发完成的项目，这是不二之选。</li>\n</ul>\n<p><strong>不足：</strong></p>\n<ul>\n<li>部署需要node服务器支持；</li>\n<li>爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；</li>\n<li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果构建大型网站，如商城类，别犹豫，直接上SSR服务器渲染，当然也有相应的坑等你，社区较成熟，英文好点，一切问题都迎刃而解。<br>如果只是个人博客、公司官网这类，其余三种都可以。<br>如果对已用SPA开发完成的项目进行SEO优化，而且支持node服务器，请使用<code>Phantomjs</code>。</p>\n<p>很少写文章，这是我这个月对Vue SEO方案的探索，写的不对的地方请指出，谢谢理解~</p>\n"},{"title":"Windows Flutter安装和运行","abbrlink":53312,"date":"2019-08-01T08:34:21.000Z","_content":"## Flutter介绍\nFlutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。\n\n## Windows环境要求\n- Java环境（配置环境变量）；\n- [Android Studio](https://developer.android.google.cn/studio)（主要安装模拟器和自带环境）；\n- [Vscode](https://code.visualstudio.com/)（“宇宙之强”编辑器）；\n- Git。\n\n## Flutter安装\n官网安装：https://flutter.dev/docs/get-started/install\nor\nGithub（有点大，可能要多试几次）：`$ git clone -b beta https://github.com/flutter/flutter.git`\n\n## 测试\n是否安装完成：\n```\n$ flutter --help\n```\n查看是否需要安装任何依赖项来完成设置：\n```\n$ flutter doctor\n```\n提示：有报红的一个一个的解决（打×的要解决，!号的可以不用）。\n\n## Vscode插件安装\n- flutter\n- dart\n安装完重启vscode，\n在编辑器的左下角的设置点击进入 “命令面板”，在命令面板中点击flutter：new project [项目名称]\n\n## 启动\n\n在终端命令行里面输入 ： `$ flutter run`  等待程序的执行，完成`hello world`\n\n```\nR 键重新启动\nr 键热重载\nq 退出\np 显示网格\nP 显示帧率\no 切换Android与iOS的预览模式\n```\n","source":"_posts/windows-flutter-install.md","raw":"---\ntitle: Windows Flutter安装和运行\ncategories: Flutter\nabbrlink: 53312\ndate: 2019-08-01 16:34:21\n---\n## Flutter介绍\nFlutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。\n\n## Windows环境要求\n- Java环境（配置环境变量）；\n- [Android Studio](https://developer.android.google.cn/studio)（主要安装模拟器和自带环境）；\n- [Vscode](https://code.visualstudio.com/)（“宇宙之强”编辑器）；\n- Git。\n\n## Flutter安装\n官网安装：https://flutter.dev/docs/get-started/install\nor\nGithub（有点大，可能要多试几次）：`$ git clone -b beta https://github.com/flutter/flutter.git`\n\n## 测试\n是否安装完成：\n```\n$ flutter --help\n```\n查看是否需要安装任何依赖项来完成设置：\n```\n$ flutter doctor\n```\n提示：有报红的一个一个的解决（打×的要解决，!号的可以不用）。\n\n## Vscode插件安装\n- flutter\n- dart\n安装完重启vscode，\n在编辑器的左下角的设置点击进入 “命令面板”，在命令面板中点击flutter：new project [项目名称]\n\n## 启动\n\n在终端命令行里面输入 ： `$ flutter run`  等待程序的执行，完成`hello world`\n\n```\nR 键重新启动\nr 键热重载\nq 退出\np 显示网格\nP 显示帧率\no 切换Android与iOS的预览模式\n```\n","slug":"windows-flutter-install","published":1,"updated":"2019-08-15T15:18:29.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhkr001sxknwcb0bt7fm","content":"<h2 id=\"Flutter介绍\"><a href=\"#Flutter介绍\" class=\"headerlink\" title=\"Flutter介绍\"></a>Flutter介绍</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p>\n<h2 id=\"Windows环境要求\"><a href=\"#Windows环境要求\" class=\"headerlink\" title=\"Windows环境要求\"></a>Windows环境要求</h2><ul>\n<li>Java环境（配置环境变量）；</li>\n<li><a href=\"https://developer.android.google.cn/studio\" target=\"_blank\" rel=\"noopener\">Android Studio</a>（主要安装模拟器和自带环境）；</li>\n<li><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">Vscode</a>（“宇宙之强”编辑器）；</li>\n<li>Git。</li>\n</ul>\n<h2 id=\"Flutter安装\"><a href=\"#Flutter安装\" class=\"headerlink\" title=\"Flutter安装\"></a>Flutter安装</h2><p>官网安装：<a href=\"https://flutter.dev/docs/get-started/install\" target=\"_blank\" rel=\"noopener\">https://flutter.dev/docs/get-started/install</a><br>or<br>Github（有点大，可能要多试几次）：<code>$ git clone -b beta https://github.com/flutter/flutter.git</code></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>是否安装完成：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ flutter --help</span><br></pre></td></tr></table></figure></p>\n<p>查看是否需要安装任何依赖项来完成设置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ flutter doctor</span><br></pre></td></tr></table></figure></p>\n<p>提示：有报红的一个一个的解决（打×的要解决，!号的可以不用）。</p>\n<h2 id=\"Vscode插件安装\"><a href=\"#Vscode插件安装\" class=\"headerlink\" title=\"Vscode插件安装\"></a>Vscode插件安装</h2><ul>\n<li>flutter</li>\n<li>dart<br>安装完重启vscode，<br>在编辑器的左下角的设置点击进入 “命令面板”，在命令面板中点击flutter：new project [项目名称]</li>\n</ul>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><p>在终端命令行里面输入 ： <code>$ flutter run</code>  等待程序的执行，完成<code>hello world</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R 键重新启动</span><br><span class=\"line\">r 键热重载</span><br><span class=\"line\">q 退出</span><br><span class=\"line\">p 显示网格</span><br><span class=\"line\">P 显示帧率</span><br><span class=\"line\">o 切换Android与iOS的预览模式</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Flutter介绍\"><a href=\"#Flutter介绍\" class=\"headerlink\" title=\"Flutter介绍\"></a>Flutter介绍</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p>\n<h2 id=\"Windows环境要求\"><a href=\"#Windows环境要求\" class=\"headerlink\" title=\"Windows环境要求\"></a>Windows环境要求</h2><ul>\n<li>Java环境（配置环境变量）；</li>\n<li><a href=\"https://developer.android.google.cn/studio\" target=\"_blank\" rel=\"noopener\">Android Studio</a>（主要安装模拟器和自带环境）；</li>\n<li><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">Vscode</a>（“宇宙之强”编辑器）；</li>\n<li>Git。</li>\n</ul>\n<h2 id=\"Flutter安装\"><a href=\"#Flutter安装\" class=\"headerlink\" title=\"Flutter安装\"></a>Flutter安装</h2><p>官网安装：<a href=\"https://flutter.dev/docs/get-started/install\" target=\"_blank\" rel=\"noopener\">https://flutter.dev/docs/get-started/install</a><br>or<br>Github（有点大，可能要多试几次）：<code>$ git clone -b beta https://github.com/flutter/flutter.git</code></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>是否安装完成：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ flutter --help</span><br></pre></td></tr></table></figure></p>\n<p>查看是否需要安装任何依赖项来完成设置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ flutter doctor</span><br></pre></td></tr></table></figure></p>\n<p>提示：有报红的一个一个的解决（打×的要解决，!号的可以不用）。</p>\n<h2 id=\"Vscode插件安装\"><a href=\"#Vscode插件安装\" class=\"headerlink\" title=\"Vscode插件安装\"></a>Vscode插件安装</h2><ul>\n<li>flutter</li>\n<li>dart<br>安装完重启vscode，<br>在编辑器的左下角的设置点击进入 “命令面板”，在命令面板中点击flutter：new project [项目名称]</li>\n</ul>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><p>在终端命令行里面输入 ： <code>$ flutter run</code>  等待程序的执行，完成<code>hello world</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R 键重新启动</span><br><span class=\"line\">r 键热重载</span><br><span class=\"line\">q 退出</span><br><span class=\"line\">p 显示网格</span><br><span class=\"line\">P 显示帧率</span><br><span class=\"line\">o 切换Android与iOS的预览模式</span><br></pre></td></tr></table></figure>\n"},{"title":"Yarn - Javascript 新一代套件管理","abbrlink":61460,"date":"2016-10-14T15:25:51.000Z","_content":"日前，Facebook 发布了全新的 JS 套件管理工具 [Yarn](https://github.com/yarnpkg/yarn)，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。\n在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。\n<!--more-->\n\n## Yarn 提供一个更快更稳定的套件管理方案\n1. 透过 yarn.lock ，锁住套件版本，因此可以确保安装之套件在每台机器上都能保持一致。\n2. 安装过的套件，都会加入到 global cache 中，下次有砍掉要重装，或是不同资料夹要装，都可以在无网络情況底下安裝。\n3. 非常快，平行化处理每个 operation，全新的 resolving 演算法。\n\n## 特性功能\n除了让安装过程更快更可靠，Yarn 还有额外的特性来更好地简化依赖管理的工作流。\n\n- 兼容 npm 和 bower 工作流，并且支持混合注册。\n- 能够限制已安装模块的证书以及输出证书信息。\n- 暴露一个稳定公开的JS API，通过构建工具提供抽象的日志记录。\n- 可读、最小化、良好的命令行输出。\n\n## 使用\n```\n// 以前装过 npm 再安装 yarn\nnpm install -g yarn\n\n// 直接安装 (mac为例，其余官网有介绍)\ncurl -o- -L https://yarnpkg.com/install.sh | bash\n\n// 一般安装 (等同 npm install)\nyarn\n\n// 安装特定套件 (等同 npm install --save)\nyarn add react         \nyarn add react@15.3.2\n\n// 更新特定套件 (等同 npm upgrade)\nyarn upgrade react\n\n// 移除特定套件 (等同 npm uninstall)\nyarn remove react\n\n// 新增 package.json\nyarn init\n\n// 新增全域套件\nyarn global add\n\n// 跑 script\nyarn run\n\n// 其他常用选项\n--offline   (离线模式，只拉 cache)\n--flat      (将套件扁平化，一個资料夹只会有一個套件)\n--dev       (加入到 devDependencies)\n--peer      (加入到 peerDependencies)\n--optional  (加入到 optionalDependencies)\n```\n\n## Cheat\n<table><thead><tr><th>NPM</th><th>YARN</th><th>说明</th></tr></thead><tbody><tr><td>npm init</td><td>yarn init</td><td>初始化某个项目</td></tr><tr><td>npm install/link</td><td>yarn install/link</td><td>默认的安装依赖操作</td></tr><tr><td>npm install taco —save</td><td>yarn add taco</td><td>安装某个依赖，并且默认保存到package.</td></tr><tr><td>npm uninstall taco —save</td><td>yarn remove taco</td><td>移除某个依赖项目</td></tr><tr><td>npm install taco —save-dev</td><td>yarn add taco —dev</td><td>安装某个开发时依赖项目</td></tr><tr><td>npm update taco —save</td><td>yarn upgrade taco</td><td>更新某个依赖项目</td></tr><tr><td>npm install taco --global</td><td>yarn global add taco</td><td>安装某个全局依赖项目</td></tr><tr><td>npm publish/login/logout</td><td>yarn publish/login/logout</td><td>发布/登录/登出，一系列NPM Registry操作</td></tr><tr><td>npm run/test</td><td>yarn run/test</td><td>运行某个命令</td></tr></tbody></table>\n\n## 参考\n- [Yarn: A new package manager for JavaScript](https://code.facebook.com/posts/1840075619545360/yarn-a-new-package-manager-for-javascript/)\n- [Yarn: a new program for installing JavaScript dependencies](https://blog.getexponent.com/yarn-a-new-program-for-installing-javascript-dependencies-44961956e728#.qf8fmeg4g)\n- [npm-vs-yarn-cheat-sheet](https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc#.dcd5qeolm)\n","source":"_posts/yarn-a-new-javascript-pkg.md","raw":"---\ntitle: Yarn - Javascript 新一代套件管理\ntags: yarn\ncategories: yarn\nabbrlink: 61460\ndate: 2016-10-14 23:25:51\n---\n日前，Facebook 发布了全新的 JS 套件管理工具 [Yarn](https://github.com/yarnpkg/yarn)，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。\n在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。\n<!--more-->\n\n## Yarn 提供一个更快更稳定的套件管理方案\n1. 透过 yarn.lock ，锁住套件版本，因此可以确保安装之套件在每台机器上都能保持一致。\n2. 安装过的套件，都会加入到 global cache 中，下次有砍掉要重装，或是不同资料夹要装，都可以在无网络情況底下安裝。\n3. 非常快，平行化处理每个 operation，全新的 resolving 演算法。\n\n## 特性功能\n除了让安装过程更快更可靠，Yarn 还有额外的特性来更好地简化依赖管理的工作流。\n\n- 兼容 npm 和 bower 工作流，并且支持混合注册。\n- 能够限制已安装模块的证书以及输出证书信息。\n- 暴露一个稳定公开的JS API，通过构建工具提供抽象的日志记录。\n- 可读、最小化、良好的命令行输出。\n\n## 使用\n```\n// 以前装过 npm 再安装 yarn\nnpm install -g yarn\n\n// 直接安装 (mac为例，其余官网有介绍)\ncurl -o- -L https://yarnpkg.com/install.sh | bash\n\n// 一般安装 (等同 npm install)\nyarn\n\n// 安装特定套件 (等同 npm install --save)\nyarn add react         \nyarn add react@15.3.2\n\n// 更新特定套件 (等同 npm upgrade)\nyarn upgrade react\n\n// 移除特定套件 (等同 npm uninstall)\nyarn remove react\n\n// 新增 package.json\nyarn init\n\n// 新增全域套件\nyarn global add\n\n// 跑 script\nyarn run\n\n// 其他常用选项\n--offline   (离线模式，只拉 cache)\n--flat      (将套件扁平化，一個资料夹只会有一個套件)\n--dev       (加入到 devDependencies)\n--peer      (加入到 peerDependencies)\n--optional  (加入到 optionalDependencies)\n```\n\n## Cheat\n<table><thead><tr><th>NPM</th><th>YARN</th><th>说明</th></tr></thead><tbody><tr><td>npm init</td><td>yarn init</td><td>初始化某个项目</td></tr><tr><td>npm install/link</td><td>yarn install/link</td><td>默认的安装依赖操作</td></tr><tr><td>npm install taco —save</td><td>yarn add taco</td><td>安装某个依赖，并且默认保存到package.</td></tr><tr><td>npm uninstall taco —save</td><td>yarn remove taco</td><td>移除某个依赖项目</td></tr><tr><td>npm install taco —save-dev</td><td>yarn add taco —dev</td><td>安装某个开发时依赖项目</td></tr><tr><td>npm update taco —save</td><td>yarn upgrade taco</td><td>更新某个依赖项目</td></tr><tr><td>npm install taco --global</td><td>yarn global add taco</td><td>安装某个全局依赖项目</td></tr><tr><td>npm publish/login/logout</td><td>yarn publish/login/logout</td><td>发布/登录/登出，一系列NPM Registry操作</td></tr><tr><td>npm run/test</td><td>yarn run/test</td><td>运行某个命令</td></tr></tbody></table>\n\n## 参考\n- [Yarn: A new package manager for JavaScript](https://code.facebook.com/posts/1840075619545360/yarn-a-new-package-manager-for-javascript/)\n- [Yarn: a new program for installing JavaScript dependencies](https://blog.getexponent.com/yarn-a-new-program-for-installing-javascript-dependencies-44961956e728#.qf8fmeg4g)\n- [npm-vs-yarn-cheat-sheet](https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc#.dcd5qeolm)\n","slug":"yarn-a-new-javascript-pkg","published":1,"updated":"2019-08-15T15:03:33.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0dyqhks001uxknwvyta10hg","content":"<p>日前，Facebook 发布了全新的 JS 套件管理工具 <a href=\"https://github.com/yarnpkg/yarn\" target=\"_blank\" rel=\"noopener\">Yarn</a>，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。<br>在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。<br><a id=\"more\"></a></p>\n<h2 id=\"Yarn-提供一个更快更稳定的套件管理方案\"><a href=\"#Yarn-提供一个更快更稳定的套件管理方案\" class=\"headerlink\" title=\"Yarn 提供一个更快更稳定的套件管理方案\"></a>Yarn 提供一个更快更稳定的套件管理方案</h2><ol>\n<li>透过 yarn.lock ，锁住套件版本，因此可以确保安装之套件在每台机器上都能保持一致。</li>\n<li>安装过的套件，都会加入到 global cache 中，下次有砍掉要重装，或是不同资料夹要装，都可以在无网络情況底下安裝。</li>\n<li>非常快，平行化处理每个 operation，全新的 resolving 演算法。</li>\n</ol>\n<h2 id=\"特性功能\"><a href=\"#特性功能\" class=\"headerlink\" title=\"特性功能\"></a>特性功能</h2><p>除了让安装过程更快更可靠，Yarn 还有额外的特性来更好地简化依赖管理的工作流。</p>\n<ul>\n<li>兼容 npm 和 bower 工作流，并且支持混合注册。</li>\n<li>能够限制已安装模块的证书以及输出证书信息。</li>\n<li>暴露一个稳定公开的JS API，通过构建工具提供抽象的日志记录。</li>\n<li>可读、最小化、良好的命令行输出。</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 以前装过 npm 再安装 yarn</span><br><span class=\"line\">npm install -g yarn</span><br><span class=\"line\"></span><br><span class=\"line\">// 直接安装 (mac为例，其余官网有介绍)</span><br><span class=\"line\">curl -o- -L https://yarnpkg.com/install.sh | bash</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般安装 (等同 npm install)</span><br><span class=\"line\">yarn</span><br><span class=\"line\"></span><br><span class=\"line\">// 安装特定套件 (等同 npm install --save)</span><br><span class=\"line\">yarn add react         </span><br><span class=\"line\">yarn add react@15.3.2</span><br><span class=\"line\"></span><br><span class=\"line\">// 更新特定套件 (等同 npm upgrade)</span><br><span class=\"line\">yarn upgrade react</span><br><span class=\"line\"></span><br><span class=\"line\">// 移除特定套件 (等同 npm uninstall)</span><br><span class=\"line\">yarn remove react</span><br><span class=\"line\"></span><br><span class=\"line\">// 新增 package.json</span><br><span class=\"line\">yarn init</span><br><span class=\"line\"></span><br><span class=\"line\">// 新增全域套件</span><br><span class=\"line\">yarn global add</span><br><span class=\"line\"></span><br><span class=\"line\">// 跑 script</span><br><span class=\"line\">yarn run</span><br><span class=\"line\"></span><br><span class=\"line\">// 其他常用选项</span><br><span class=\"line\">--offline   (离线模式，只拉 cache)</span><br><span class=\"line\">--flat      (将套件扁平化，一個资料夹只会有一個套件)</span><br><span class=\"line\">--dev       (加入到 devDependencies)</span><br><span class=\"line\">--peer      (加入到 peerDependencies)</span><br><span class=\"line\">--optional  (加入到 optionalDependencies)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Cheat\"><a href=\"#Cheat\" class=\"headerlink\" title=\"Cheat\"></a>Cheat</h2><table><thead><tr><th>NPM</th><th>YARN</th><th>说明</th></tr></thead><tbody><tr><td>npm init</td><td>yarn init</td><td>初始化某个项目</td></tr><tr><td>npm install/link</td><td>yarn install/link</td><td>默认的安装依赖操作</td></tr><tr><td>npm install taco —save</td><td>yarn add taco</td><td>安装某个依赖，并且默认保存到package.</td></tr><tr><td>npm uninstall taco —save</td><td>yarn remove taco</td><td>移除某个依赖项目</td></tr><tr><td>npm install taco —save-dev</td><td>yarn add taco —dev</td><td>安装某个开发时依赖项目</td></tr><tr><td>npm update taco —save</td><td>yarn upgrade taco</td><td>更新某个依赖项目</td></tr><tr><td>npm install taco –global</td><td>yarn global add taco</td><td>安装某个全局依赖项目</td></tr><tr><td>npm publish/login/logout</td><td>yarn publish/login/logout</td><td>发布/登录/登出，一系列NPM Registry操作</td></tr><tr><td>npm run/test</td><td>yarn run/test</td><td>运行某个命令</td></tr></tbody></table>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://code.facebook.com/posts/1840075619545360/yarn-a-new-package-manager-for-javascript/\" target=\"_blank\" rel=\"noopener\">Yarn: A new package manager for JavaScript</a></li>\n<li><a href=\"https://blog.getexponent.com/yarn-a-new-program-for-installing-javascript-dependencies-44961956e728#.qf8fmeg4g\" target=\"_blank\" rel=\"noopener\">Yarn: a new program for installing JavaScript dependencies</a></li>\n<li><a href=\"https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc#.dcd5qeolm\" target=\"_blank\" rel=\"noopener\">npm-vs-yarn-cheat-sheet</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>日前，Facebook 发布了全新的 JS 套件管理工具 <a href=\"https://github.com/yarnpkg/yarn\" target=\"_blank\" rel=\"noopener\">Yarn</a>，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。<br>在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。<br>","more":"</p>\n<h2 id=\"Yarn-提供一个更快更稳定的套件管理方案\"><a href=\"#Yarn-提供一个更快更稳定的套件管理方案\" class=\"headerlink\" title=\"Yarn 提供一个更快更稳定的套件管理方案\"></a>Yarn 提供一个更快更稳定的套件管理方案</h2><ol>\n<li>透过 yarn.lock ，锁住套件版本，因此可以确保安装之套件在每台机器上都能保持一致。</li>\n<li>安装过的套件，都会加入到 global cache 中，下次有砍掉要重装，或是不同资料夹要装，都可以在无网络情況底下安裝。</li>\n<li>非常快，平行化处理每个 operation，全新的 resolving 演算法。</li>\n</ol>\n<h2 id=\"特性功能\"><a href=\"#特性功能\" class=\"headerlink\" title=\"特性功能\"></a>特性功能</h2><p>除了让安装过程更快更可靠，Yarn 还有额外的特性来更好地简化依赖管理的工作流。</p>\n<ul>\n<li>兼容 npm 和 bower 工作流，并且支持混合注册。</li>\n<li>能够限制已安装模块的证书以及输出证书信息。</li>\n<li>暴露一个稳定公开的JS API，通过构建工具提供抽象的日志记录。</li>\n<li>可读、最小化、良好的命令行输出。</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 以前装过 npm 再安装 yarn</span><br><span class=\"line\">npm install -g yarn</span><br><span class=\"line\"></span><br><span class=\"line\">// 直接安装 (mac为例，其余官网有介绍)</span><br><span class=\"line\">curl -o- -L https://yarnpkg.com/install.sh | bash</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般安装 (等同 npm install)</span><br><span class=\"line\">yarn</span><br><span class=\"line\"></span><br><span class=\"line\">// 安装特定套件 (等同 npm install --save)</span><br><span class=\"line\">yarn add react         </span><br><span class=\"line\">yarn add react@15.3.2</span><br><span class=\"line\"></span><br><span class=\"line\">// 更新特定套件 (等同 npm upgrade)</span><br><span class=\"line\">yarn upgrade react</span><br><span class=\"line\"></span><br><span class=\"line\">// 移除特定套件 (等同 npm uninstall)</span><br><span class=\"line\">yarn remove react</span><br><span class=\"line\"></span><br><span class=\"line\">// 新增 package.json</span><br><span class=\"line\">yarn init</span><br><span class=\"line\"></span><br><span class=\"line\">// 新增全域套件</span><br><span class=\"line\">yarn global add</span><br><span class=\"line\"></span><br><span class=\"line\">// 跑 script</span><br><span class=\"line\">yarn run</span><br><span class=\"line\"></span><br><span class=\"line\">// 其他常用选项</span><br><span class=\"line\">--offline   (离线模式，只拉 cache)</span><br><span class=\"line\">--flat      (将套件扁平化，一個资料夹只会有一個套件)</span><br><span class=\"line\">--dev       (加入到 devDependencies)</span><br><span class=\"line\">--peer      (加入到 peerDependencies)</span><br><span class=\"line\">--optional  (加入到 optionalDependencies)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Cheat\"><a href=\"#Cheat\" class=\"headerlink\" title=\"Cheat\"></a>Cheat</h2><table><thead><tr><th>NPM</th><th>YARN</th><th>说明</th></tr></thead><tbody><tr><td>npm init</td><td>yarn init</td><td>初始化某个项目</td></tr><tr><td>npm install/link</td><td>yarn install/link</td><td>默认的安装依赖操作</td></tr><tr><td>npm install taco —save</td><td>yarn add taco</td><td>安装某个依赖，并且默认保存到package.</td></tr><tr><td>npm uninstall taco —save</td><td>yarn remove taco</td><td>移除某个依赖项目</td></tr><tr><td>npm install taco —save-dev</td><td>yarn add taco —dev</td><td>安装某个开发时依赖项目</td></tr><tr><td>npm update taco —save</td><td>yarn upgrade taco</td><td>更新某个依赖项目</td></tr><tr><td>npm install taco –global</td><td>yarn global add taco</td><td>安装某个全局依赖项目</td></tr><tr><td>npm publish/login/logout</td><td>yarn publish/login/logout</td><td>发布/登录/登出，一系列NPM Registry操作</td></tr><tr><td>npm run/test</td><td>yarn run/test</td><td>运行某个命令</td></tr></tbody></table>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://code.facebook.com/posts/1840075619545360/yarn-a-new-package-manager-for-javascript/\" target=\"_blank\" rel=\"noopener\">Yarn: A new package manager for JavaScript</a></li>\n<li><a href=\"https://blog.getexponent.com/yarn-a-new-program-for-installing-javascript-dependencies-44961956e728#.qf8fmeg4g\" target=\"_blank\" rel=\"noopener\">Yarn: a new program for installing JavaScript dependencies</a></li>\n<li><a href=\"https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc#.dcd5qeolm\" target=\"_blank\" rel=\"noopener\">npm-vs-yarn-cheat-sheet</a></li>\n</ul>"},{"title":"公众号用vue开发百度地图","abbrlink":7031,"date":"2019-09-10T15:01:18.000Z","_content":"## 功能描述\n最近用vue在公众号结合百度地图开发，功能是根据公众号定位获取经纬度，再用百度地图显示附近的店铺。由于公众号不能满足业务需求，所以加上百度地图。\n\n## 知识点\n- 微信公众号获取经纬度\n- 公众号经纬度转换百度经纬度\n- vue开发用[vue-baidu-map](https://github.com/Dafrok/vue-baidu-map)开发注意事项\n- 百度地图逆/地址解析\n- 推荐一些相关的开发/测试工具\n\n## 微信公众号获取经纬度\n公众号文档-[获取地理位置接口](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#36)\n前提是公众号的一切东西都设置好，要先调接口获取签名，然后通过`wx.config`安全验证，\n```\n/**\n*  获取公众号经纬度\n*/\nVue.prototype.wxLocation = (opts) => {\n  const ua = window.navigator.userAgent.toLowerCase();\n  if (ua.match(/MicroMessenger/i) == 'micromessenger') {\n    // 这是一个请求，获取签名\n    api.wxSignature({\n        url: window.location.href.split('#')[0]\n      })\n      .then(res => {\n        // 安全验证\n        wx.config({\n          debug: false,\n          appId: res.data.appid,\n          timestamp: res.data.timestamp,\n          nonceStr: res.data.nonceStr,\n          signature: res.data.signature,\n          jsApiList: [\n            'openLocation',\n            'getLocation',\n          ],\n        });\n\n        wx.ready(() => {\n          // 获取经纬度\n          wx.getLocation({\n            type: 'wgs84', // 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入'gcj02'\n            success: (res)=> {\n              var latitude = res.latitude; // 纬度，浮点数，范围为90 ~ -90\n              var longitude = res.longitude; // 经度，浮点数，范围为180 ~ -180。\n              opts.wxGetLocation(res)\n            },\n          });\n        })\n      })\n  } else {\n    console.log('非微信端，不获取地址！')\n  }\n},\n```\n页面调用：\n```\ncreated() {\n  this.wxLocation({\n    wxGetLocation: function(res) {\n      console.log(res);\n    }\n  });\n},\n\n```\n\n## 公众号经纬度转换百度经纬度\n**目前国内主要有以下三种坐标系：**\n\n- WGS84：为一种大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。\n\n- GCJ02：又称火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。\n\n- BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标。\n\n非中国地区地图，服务坐标统一使用WGS84坐标。\n[百度地图-坐标转换说明](http://lbsyun.baidu.com/index.php?title=jspopular3.0/guide/coorinfo)\n\n我了解的有两种方式转换：\n- [文档化-坐标转换服务](http://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition)\n- 通过接口转换\n下面介绍通过接口的方式转换：\n```\nhttp://api.map.baidu.com/ag/coord/convert?from=0&to=4&x=113.540124&y=23.517846\n```\n\n其中`from`参数：0代表WGS-84即标准GPS设备返回的坐标, 2代表国测局的标准；`to`参数：4代表百度的坐标；`x`参数：代表纬度latitude；`y`参数：代表经度longitude。\n\n大概会出现跨域问题，我用了vue-cli2配置的`proxyTable`无法解决，后来我用了朋友的跨域应用解决了：\n```\nhttps://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&to=4&x=113.540124&y=23.517846\n```\n转换出来是经过base64加码的，这样子：\n```\n{\"error\":0,\"x\":\"MTEzLjU1MTgxMDg2MDE5\",\"y\":\"MjMuNTIxMjM0OTM0OTE0\"}\n```\n用`js-base64`解码：\n```\nlet Base64 = require('js-base64').Base64;\n...\naxios.get('https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&to=4&x=113.540124&y=23.517846')\n      .then(res){\n        var longitude = Base64.decode(res.x);\n        var latitude = Base64.decode(res.y);\n      }\n\n```\n此时，转换经纬度大功告成！\n","source":"_posts/公众号用vue开发百度地图.md","raw":"---\ntitle: 公众号用vue开发百度地图\nabbrlink: 7031\ndate: 2019-09-10 23:01:18\ntags: 微信公众号\n---\n## 功能描述\n最近用vue在公众号结合百度地图开发，功能是根据公众号定位获取经纬度，再用百度地图显示附近的店铺。由于公众号不能满足业务需求，所以加上百度地图。\n\n## 知识点\n- 微信公众号获取经纬度\n- 公众号经纬度转换百度经纬度\n- vue开发用[vue-baidu-map](https://github.com/Dafrok/vue-baidu-map)开发注意事项\n- 百度地图逆/地址解析\n- 推荐一些相关的开发/测试工具\n\n## 微信公众号获取经纬度\n公众号文档-[获取地理位置接口](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#36)\n前提是公众号的一切东西都设置好，要先调接口获取签名，然后通过`wx.config`安全验证，\n```\n/**\n*  获取公众号经纬度\n*/\nVue.prototype.wxLocation = (opts) => {\n  const ua = window.navigator.userAgent.toLowerCase();\n  if (ua.match(/MicroMessenger/i) == 'micromessenger') {\n    // 这是一个请求，获取签名\n    api.wxSignature({\n        url: window.location.href.split('#')[0]\n      })\n      .then(res => {\n        // 安全验证\n        wx.config({\n          debug: false,\n          appId: res.data.appid,\n          timestamp: res.data.timestamp,\n          nonceStr: res.data.nonceStr,\n          signature: res.data.signature,\n          jsApiList: [\n            'openLocation',\n            'getLocation',\n          ],\n        });\n\n        wx.ready(() => {\n          // 获取经纬度\n          wx.getLocation({\n            type: 'wgs84', // 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入'gcj02'\n            success: (res)=> {\n              var latitude = res.latitude; // 纬度，浮点数，范围为90 ~ -90\n              var longitude = res.longitude; // 经度，浮点数，范围为180 ~ -180。\n              opts.wxGetLocation(res)\n            },\n          });\n        })\n      })\n  } else {\n    console.log('非微信端，不获取地址！')\n  }\n},\n```\n页面调用：\n```\ncreated() {\n  this.wxLocation({\n    wxGetLocation: function(res) {\n      console.log(res);\n    }\n  });\n},\n\n```\n\n## 公众号经纬度转换百度经纬度\n**目前国内主要有以下三种坐标系：**\n\n- WGS84：为一种大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。\n\n- GCJ02：又称火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。\n\n- BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标。\n\n非中国地区地图，服务坐标统一使用WGS84坐标。\n[百度地图-坐标转换说明](http://lbsyun.baidu.com/index.php?title=jspopular3.0/guide/coorinfo)\n\n我了解的有两种方式转换：\n- [文档化-坐标转换服务](http://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition)\n- 通过接口转换\n下面介绍通过接口的方式转换：\n```\nhttp://api.map.baidu.com/ag/coord/convert?from=0&to=4&x=113.540124&y=23.517846\n```\n\n其中`from`参数：0代表WGS-84即标准GPS设备返回的坐标, 2代表国测局的标准；`to`参数：4代表百度的坐标；`x`参数：代表纬度latitude；`y`参数：代表经度longitude。\n\n大概会出现跨域问题，我用了vue-cli2配置的`proxyTable`无法解决，后来我用了朋友的跨域应用解决了：\n```\nhttps://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&to=4&x=113.540124&y=23.517846\n```\n转换出来是经过base64加码的，这样子：\n```\n{\"error\":0,\"x\":\"MTEzLjU1MTgxMDg2MDE5\",\"y\":\"MjMuNTIxMjM0OTM0OTE0\"}\n```\n用`js-base64`解码：\n```\nlet Base64 = require('js-base64').Base64;\n...\naxios.get('https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&to=4&x=113.540124&y=23.517846')\n      .then(res){\n        var longitude = Base64.decode(res.x);\n        var latitude = Base64.decode(res.y);\n      }\n\n```\n此时，转换经纬度大功告成！\n","slug":"公众号用vue开发百度地图","published":1,"updated":"2019-09-10T15:54:08.155Z","_id":"ck0dyqhku001yxknwc0mle0sg","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"功能描述\"><a href=\"#功能描述\" class=\"headerlink\" title=\"功能描述\"></a>功能描述</h2><p>最近用vue在公众号结合百度地图开发，功能是根据公众号定位获取经纬度，再用百度地图显示附近的店铺。由于公众号不能满足业务需求，所以加上百度地图。</p>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ul>\n<li>微信公众号获取经纬度</li>\n<li>公众号经纬度转换百度经纬度</li>\n<li>vue开发用<a href=\"https://github.com/Dafrok/vue-baidu-map\" target=\"_blank\" rel=\"noopener\">vue-baidu-map</a>开发注意事项</li>\n<li>百度地图逆/地址解析</li>\n<li>推荐一些相关的开发/测试工具</li>\n</ul>\n<h2 id=\"微信公众号获取经纬度\"><a href=\"#微信公众号获取经纬度\" class=\"headerlink\" title=\"微信公众号获取经纬度\"></a>微信公众号获取经纬度</h2><p>公众号文档-<a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#36\" target=\"_blank\" rel=\"noopener\">获取地理位置接口</a><br>前提是公众号的一切东西都设置好，要先调接口获取签名，然后通过<code>wx.config</code>安全验证，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">*  获取公众号经纬度</span><br><span class=\"line\">*/</span><br><span class=\"line\">Vue.prototype.wxLocation = (opts) =&gt; &#123;</span><br><span class=\"line\">  const ua = window.navigator.userAgent.toLowerCase();</span><br><span class=\"line\">  if (ua.match(/MicroMessenger/i) == &apos;micromessenger&apos;) &#123;</span><br><span class=\"line\">    // 这是一个请求，获取签名</span><br><span class=\"line\">    api.wxSignature(&#123;</span><br><span class=\"line\">        url: window.location.href.split(&apos;#&apos;)[0]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .then(res =&gt; &#123;</span><br><span class=\"line\">        // 安全验证</span><br><span class=\"line\">        wx.config(&#123;</span><br><span class=\"line\">          debug: false,</span><br><span class=\"line\">          appId: res.data.appid,</span><br><span class=\"line\">          timestamp: res.data.timestamp,</span><br><span class=\"line\">          nonceStr: res.data.nonceStr,</span><br><span class=\"line\">          signature: res.data.signature,</span><br><span class=\"line\">          jsApiList: [</span><br><span class=\"line\">            &apos;openLocation&apos;,</span><br><span class=\"line\">            &apos;getLocation&apos;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        wx.ready(() =&gt; &#123;</span><br><span class=\"line\">          // 获取经纬度</span><br><span class=\"line\">          wx.getLocation(&#123;</span><br><span class=\"line\">            type: &apos;wgs84&apos;, // 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入&apos;gcj02&apos;</span><br><span class=\"line\">            success: (res)=&gt; &#123;</span><br><span class=\"line\">              var latitude = res.latitude; // 纬度，浮点数，范围为90 ~ -90</span><br><span class=\"line\">              var longitude = res.longitude; // 经度，浮点数，范围为180 ~ -180。</span><br><span class=\"line\">              opts.wxGetLocation(res)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;非微信端，不获取地址！&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>页面调用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">  this.wxLocation(&#123;</span><br><span class=\"line\">    wxGetLocation: function(res) &#123;</span><br><span class=\"line\">      console.log(res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"公众号经纬度转换百度经纬度\"><a href=\"#公众号经纬度转换百度经纬度\" class=\"headerlink\" title=\"公众号经纬度转换百度经纬度\"></a>公众号经纬度转换百度经纬度</h2><p><strong>目前国内主要有以下三种坐标系：</strong></p>\n<ul>\n<li><p>WGS84：为一种大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。</p>\n</li>\n<li><p>GCJ02：又称火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。</p>\n</li>\n<li><p>BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标。</p>\n</li>\n</ul>\n<p>非中国地区地图，服务坐标统一使用WGS84坐标。<br><a href=\"http://lbsyun.baidu.com/index.php?title=jspopular3.0/guide/coorinfo\" target=\"_blank\" rel=\"noopener\">百度地图-坐标转换说明</a></p>\n<p>我了解的有两种方式转换：</p>\n<ul>\n<li><a href=\"http://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition\" target=\"_blank\" rel=\"noopener\">文档化-坐标转换服务</a></li>\n<li>通过接口转换<br>下面介绍通过接口的方式转换：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中<code>from</code>参数：0代表WGS-84即标准GPS设备返回的坐标, 2代表国测局的标准；<code>to</code>参数：4代表百度的坐标；<code>x</code>参数：代表纬度latitude；<code>y</code>参数：代表经度longitude。</p>\n<p>大概会出现跨域问题，我用了vue-cli2配置的<code>proxyTable</code>无法解决，后来我用了朋友的跨域应用解决了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846</span><br></pre></td></tr></table></figure></p>\n<p>转换出来是经过base64加码的，这样子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;error&quot;:0,&quot;x&quot;:&quot;MTEzLjU1MTgxMDg2MDE5&quot;,&quot;y&quot;:&quot;MjMuNTIxMjM0OTM0OTE0&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用<code>js-base64</code>解码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let Base64 = require(&apos;js-base64&apos;).Base64;</span><br><span class=\"line\">...</span><br><span class=\"line\">axios.get(&apos;https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846&apos;)</span><br><span class=\"line\">      .then(res)&#123;</span><br><span class=\"line\">        var longitude = Base64.decode(res.x);</span><br><span class=\"line\">        var latitude = Base64.decode(res.y);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时，转换经纬度大功告成！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"功能描述\"><a href=\"#功能描述\" class=\"headerlink\" title=\"功能描述\"></a>功能描述</h2><p>最近用vue在公众号结合百度地图开发，功能是根据公众号定位获取经纬度，再用百度地图显示附近的店铺。由于公众号不能满足业务需求，所以加上百度地图。</p>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ul>\n<li>微信公众号获取经纬度</li>\n<li>公众号经纬度转换百度经纬度</li>\n<li>vue开发用<a href=\"https://github.com/Dafrok/vue-baidu-map\" target=\"_blank\" rel=\"noopener\">vue-baidu-map</a>开发注意事项</li>\n<li>百度地图逆/地址解析</li>\n<li>推荐一些相关的开发/测试工具</li>\n</ul>\n<h2 id=\"微信公众号获取经纬度\"><a href=\"#微信公众号获取经纬度\" class=\"headerlink\" title=\"微信公众号获取经纬度\"></a>微信公众号获取经纬度</h2><p>公众号文档-<a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#36\" target=\"_blank\" rel=\"noopener\">获取地理位置接口</a><br>前提是公众号的一切东西都设置好，要先调接口获取签名，然后通过<code>wx.config</code>安全验证，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">*  获取公众号经纬度</span><br><span class=\"line\">*/</span><br><span class=\"line\">Vue.prototype.wxLocation = (opts) =&gt; &#123;</span><br><span class=\"line\">  const ua = window.navigator.userAgent.toLowerCase();</span><br><span class=\"line\">  if (ua.match(/MicroMessenger/i) == &apos;micromessenger&apos;) &#123;</span><br><span class=\"line\">    // 这是一个请求，获取签名</span><br><span class=\"line\">    api.wxSignature(&#123;</span><br><span class=\"line\">        url: window.location.href.split(&apos;#&apos;)[0]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .then(res =&gt; &#123;</span><br><span class=\"line\">        // 安全验证</span><br><span class=\"line\">        wx.config(&#123;</span><br><span class=\"line\">          debug: false,</span><br><span class=\"line\">          appId: res.data.appid,</span><br><span class=\"line\">          timestamp: res.data.timestamp,</span><br><span class=\"line\">          nonceStr: res.data.nonceStr,</span><br><span class=\"line\">          signature: res.data.signature,</span><br><span class=\"line\">          jsApiList: [</span><br><span class=\"line\">            &apos;openLocation&apos;,</span><br><span class=\"line\">            &apos;getLocation&apos;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        wx.ready(() =&gt; &#123;</span><br><span class=\"line\">          // 获取经纬度</span><br><span class=\"line\">          wx.getLocation(&#123;</span><br><span class=\"line\">            type: &apos;wgs84&apos;, // 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入&apos;gcj02&apos;</span><br><span class=\"line\">            success: (res)=&gt; &#123;</span><br><span class=\"line\">              var latitude = res.latitude; // 纬度，浮点数，范围为90 ~ -90</span><br><span class=\"line\">              var longitude = res.longitude; // 经度，浮点数，范围为180 ~ -180。</span><br><span class=\"line\">              opts.wxGetLocation(res)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;非微信端，不获取地址！&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>页面调用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">  this.wxLocation(&#123;</span><br><span class=\"line\">    wxGetLocation: function(res) &#123;</span><br><span class=\"line\">      console.log(res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"公众号经纬度转换百度经纬度\"><a href=\"#公众号经纬度转换百度经纬度\" class=\"headerlink\" title=\"公众号经纬度转换百度经纬度\"></a>公众号经纬度转换百度经纬度</h2><p><strong>目前国内主要有以下三种坐标系：</strong></p>\n<ul>\n<li><p>WGS84：为一种大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。</p>\n</li>\n<li><p>GCJ02：又称火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。</p>\n</li>\n<li><p>BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标。</p>\n</li>\n</ul>\n<p>非中国地区地图，服务坐标统一使用WGS84坐标。<br><a href=\"http://lbsyun.baidu.com/index.php?title=jspopular3.0/guide/coorinfo\" target=\"_blank\" rel=\"noopener\">百度地图-坐标转换说明</a></p>\n<p>我了解的有两种方式转换：</p>\n<ul>\n<li><a href=\"http://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition\" target=\"_blank\" rel=\"noopener\">文档化-坐标转换服务</a></li>\n<li>通过接口转换<br>下面介绍通过接口的方式转换：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其中<code>from</code>参数：0代表WGS-84即标准GPS设备返回的坐标, 2代表国测局的标准；<code>to</code>参数：4代表百度的坐标；<code>x</code>参数：代表纬度latitude；<code>y</code>参数：代表经度longitude。</p>\n<p>大概会出现跨域问题，我用了vue-cli2配置的<code>proxyTable</code>无法解决，后来我用了朋友的跨域应用解决了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846</span><br></pre></td></tr></table></figure></p>\n<p>转换出来是经过base64加码的，这样子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;error&quot;:0,&quot;x&quot;:&quot;MTEzLjU1MTgxMDg2MDE5&quot;,&quot;y&quot;:&quot;MjMuNTIxMjM0OTM0OTE0&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用<code>js-base64</code>解码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let Base64 = require(&apos;js-base64&apos;).Base64;</span><br><span class=\"line\">...</span><br><span class=\"line\">axios.get(&apos;https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846&apos;)</span><br><span class=\"line\">      .then(res)&#123;</span><br><span class=\"line\">        var longitude = Base64.decode(res.x);</span><br><span class=\"line\">        var latitude = Base64.decode(res.y);</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时，转换经纬度大功告成！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck0dyqhj50001xknw3ztol3v0","category_id":"ck0dyqhjb0003xknwjtvl7sax","_id":"ck0dyqhjm000dxknwf6vlh90y"},{"post_id":"ck0dyqhje0005xknwoemosqtl","category_id":"ck0dyqhji0008xknwb3gfxx5c","_id":"ck0dyqhjr000kxknwgkya6mvn"},{"post_id":"ck0dyqhjl000cxknwb06orlhr","category_id":"ck0dyqhjb0003xknwjtvl7sax","_id":"ck0dyqhjt000oxknwqwil5090"},{"post_id":"ck0dyqhjf0006xknwvctaz48x","category_id":"ck0dyqhjm000exknwb29zvuui","_id":"ck0dyqhju000rxknwkk7ryyug"},{"post_id":"ck0dyqhjn000gxknwy84yorsc","category_id":"ck0dyqhjr000mxknw3akjvsfk","_id":"ck0dyqhjz000zxknwvgcsowez"},{"post_id":"ck0dyqhjx000wxknw04v21qt1","category_id":"ck0dyqhjv000uxknw1oq25203","_id":"ck0dyqhk20014xknw7m0rjhns"},{"post_id":"ck0dyqhjr000nxknwwy23x9gh","category_id":"ck0dyqhjv000uxknw1oq25203","_id":"ck0dyqhk30018xknwp8egjij1"},{"post_id":"ck0dyqhjt000qxknwn9b6hioq","category_id":"ck0dyqhjv000uxknw1oq25203","_id":"ck0dyqhk40019xknw2hjcdk0e"},{"post_id":"ck0dyqhjv000txknwqadbg0qz","category_id":"ck0dyqhjv000uxknw1oq25203","_id":"ck0dyqhk5001cxknwk4u0yt1d"},{"post_id":"ck0dyqhkn001oxknwf114d3an","category_id":"ck0dyqhjv000uxknw1oq25203","_id":"ck0dyqhkt001vxknw6yjd0ado"},{"post_id":"ck0dyqhkp001qxknwcrhlosia","category_id":"ck0dyqhks001txknwlj53dk2c","_id":"ck0dyqhkw0021xknwr5e78dte"},{"post_id":"ck0dyqhkr001sxknwcb0bt7fm","category_id":"ck0dyqhkv001zxknw72pnczdv","_id":"ck0dyqhkx0024xknwx0wt6kb7"},{"post_id":"ck0dyqhks001uxknwvyta10hg","category_id":"ck0dyqhkw0022xknw5gpzjtby","_id":"ck0dyqhky0027xknw4of60j7c"}],"PostTag":[{"post_id":"ck0dyqhj50001xknw3ztol3v0","tag_id":"ck0dyqhjd0004xknwbwhsoees","_id":"ck0dyqhjj000axknwbm2p97ux"},{"post_id":"ck0dyqhj90002xknwkm4i0t3t","tag_id":"ck0dyqhji0009xknwsrbrn0xu","_id":"ck0dyqhjo000hxknwwr1ud3zz"},{"post_id":"ck0dyqhjl000cxknwb06orlhr","tag_id":"ck0dyqhjd0004xknwbwhsoees","_id":"ck0dyqhjq000jxknwl1socd4y"},{"post_id":"ck0dyqhje0005xknwoemosqtl","tag_id":"ck0dyqhjm000fxknwjwx5ay1v","_id":"ck0dyqhjt000pxknw5117wp4m"},{"post_id":"ck0dyqhjf0006xknwvctaz48x","tag_id":"ck0dyqhjr000lxknw8yob8l9p","_id":"ck0dyqhjx000vxknwrufvura9"},{"post_id":"ck0dyqhjh0007xknw6vlhmxhe","tag_id":"ck0dyqhji0009xknwsrbrn0xu","_id":"ck0dyqhk00011xknwbs5jbwtr"},{"post_id":"ck0dyqhjy000yxknws7l7mxu5","tag_id":"ck0dyqhjm000fxknwjwx5ay1v","_id":"ck0dyqhk10013xknwrk909nqq"},{"post_id":"ck0dyqhjn000gxknwy84yorsc","tag_id":"ck0dyqhjy000xxknw77kjo63f","_id":"ck0dyqhk30017xknwy0ps5jls"},{"post_id":"ck0dyqhjp000ixknwpkrnzb63","tag_id":"ck0dyqhk20015xknwzh69hn1y","_id":"ck0dyqhk4001bxknwr2bi6hlk"},{"post_id":"ck0dyqhjr000nxknwwy23x9gh","tag_id":"ck0dyqhk20015xknwzh69hn1y","_id":"ck0dyqhk5001exknwfq22xokx"},{"post_id":"ck0dyqhjt000qxknwn9b6hioq","tag_id":"ck0dyqhk20015xknwzh69hn1y","_id":"ck0dyqhk6001gxknw9prmd3lp"},{"post_id":"ck0dyqhjv000txknwqadbg0qz","tag_id":"ck0dyqhk20015xknwzh69hn1y","_id":"ck0dyqhk7001ixknw4fuxccev"},{"post_id":"ck0dyqhjx000wxknw04v21qt1","tag_id":"ck0dyqhk20015xknwzh69hn1y","_id":"ck0dyqhk7001kxknwytn0ay1q"},{"post_id":"ck0dyqhk00012xknwfglyyrsy","tag_id":"ck0dyqhk7001jxknwwt8sc0tt","_id":"ck0dyqhk7001lxknw2rkfz6ge"},{"post_id":"ck0dyqhk00012xknwfglyyrsy","tag_id":"ck0dyqhjy000xxknw77kjo63f","_id":"ck0dyqhk8001mxknwiotlhb93"},{"post_id":"ck0dyqhkn001oxknwf114d3an","tag_id":"ck0dyqhk20015xknwzh69hn1y","_id":"ck0dyqhkr001rxknwlnssvc12"},{"post_id":"ck0dyqhkm001nxknw7w3k850u","tag_id":"ck0dyqhkp001pxknw6e85b2u2","_id":"ck0dyqhku001xxknw9uh9nkxg"},{"post_id":"ck0dyqhkp001qxknwcrhlosia","tag_id":"ck0dyqhkt001wxknwldovaksx","_id":"ck0dyqhky0026xknwiyypza7q"},{"post_id":"ck0dyqhkp001qxknwcrhlosia","tag_id":"ck0dyqhkv0020xknw71jxoe5g","_id":"ck0dyqhkz0028xknw3stal2ye"},{"post_id":"ck0dyqhkp001qxknwcrhlosia","tag_id":"ck0dyqhkx0023xknwwcduvyxd","_id":"ck0dyqhkz0029xknwpwjc91jj"},{"post_id":"ck0dyqhks001uxknwvyta10hg","tag_id":"ck0dyqhky0025xknwzx9360z5","_id":"ck0dyqhkz002axknw4c4j1cg5"},{"post_id":"ck0dyqhku001yxknwc0mle0sg","tag_id":"ck0dyr77t002bxknwk9em70az","_id":"ck0dyr77v002cxknw9faq9lv9"}],"Tag":[{"name":"es6","_id":"ck0dyqhjd0004xknwbwhsoees"},{"name":"mongodb","_id":"ck0dyqhji0009xknwsrbrn0xu"},{"name":"redux","_id":"ck0dyqhjm000fxknwjwx5ay1v"},{"name":"fetch","_id":"ck0dyqhjr000lxknw8yob8l9p"},{"name":"node","_id":"ck0dyqhjy000xxknw77kjo63f"},{"name":"react","_id":"ck0dyqhk20015xknwzh69hn1y"},{"name":"linux","_id":"ck0dyqhk7001jxknwwt8sc0tt"},{"name":"webpack","_id":"ck0dyqhkp001pxknw6e85b2u2"},{"name":"Vue","_id":"ck0dyqhkt001wxknwldovaksx"},{"name":"SEO","_id":"ck0dyqhkv0020xknw71jxoe5g"},{"name":"Phantomjs","_id":"ck0dyqhkx0023xknwwcduvyxd"},{"name":"yarn","_id":"ck0dyqhky0025xknwzx9360z5"},{"name":"微信公众号","_id":"ck0dyr77t002bxknwk9em70az"}]}}