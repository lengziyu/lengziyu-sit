<<<<<<< HEAD
{"meta":{"title":"冷子欲-喜欢折腾的前端er","subtitle":null,"description":null,"author":"lengziyu","url":"http://lengziyu.cn","root":"/blog/"},"pages":[{"title":"关于我","date":"2019-07-17T06:23:09.000Z","updated":"2020-09-08T13:34:47.031Z","comments":true,"path":"about/index.html","permalink":"http://lengziyu.cn/about/index.html","excerpt":"","text":"name: “陈广达”, sex: “男”, hobby: “摄影、撸喵、旅游、打羽毛球”, place: “广东茂名”, birthday: “01.22”, school: “广州华南理工”, age: “26岁”, height: “176cm”, tel: “13621424189”, email: “1058566903@qq.com“, qq: “1058566903”, wechat: “16626412342”"}],"posts":[{"title":"学习TypeScript第一课","slug":"learn-typescript-01","date":"2020-09-08T13:04:54.000Z","updated":"2020-09-08T13:20:18.961Z","comments":true,"path":"2020/09/08/learn-typescript-01/","link":"","permalink":"http://lengziyu.cn/2020/09/08/learn-typescript-01/","excerpt":"","text":"TypeScript是JavaScript的一个超集，支持ECMAScript6标准，设计目标是开发大型应用。 安装可以通过开发工具安装插件或用npm方式安装，这里介绍npm的方式。1npm i -g typescript 构建一个TypeScript文件新建一个greeter.ts文件，写入以下内容。1234567function greeter(person: string) &#123; return &quot;Hello, &quot; + person;&#125;let user = &quot;Jane User&quot;;document.body.innerHTML = greeter(user); 编译代码在命令行执行如下，运行TypeScript编译：1tsc greeter.ts 输出结果为一个greeter.js文件，它包含了和输入文件中相同的JavsScript代码。 基础类型 数据类型 关键字 描述 例子 任意类型 any 声明为 any 的变量可以赋予任意类型的值。 let x: any = 1; x = false; 数字类型 number 双精度 64 位浮点值。它可以用来表示整数和分数。 let decLiteral: number = 6; 字符串类型 string 一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。 let name: string = &quot;Runoob&quot;; 布尔类型 boolean 表示逻辑值true和false。 let flag: boolean = true; 数组类型 无 声明变量为数组。 let arr: number[] = [1, 2]; 元组 无 元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。 let x: [string, number]; x = [&#39;Runoob&#39;, 1]; 枚举 enum 枚举类型用于定义数值集合。 enum Color {Red, Green, Blue};let c: Color = Color.Blue; void void 用于标识方法返回值的类型，表示该方法没有返回值。 function hello(): void { alert(&quot;Hello Runoob&quot;) } null null 表示对象值缺失。 无 undefined undefined 用于初始化变量为一个未定义的值。 无 never never never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。 无 函数函数返回值123456function function_name():return_type &#123; // 语句 return value; &#125;// return_type 是返回值的类型。 实例：1234// 函数定义function greet():string &#123; // 返回一个字符串 return &quot;Hello World&quot; &#125; 带参数的函数123456function func_name( param1 [:datatype], param2 [:datatype]) &#123; &#125;// param1、param2 为参数名。// datatype 为参数类型。 实例：1234function add(x: number, y: number): number &#123; return x + y;&#125;console.log(add(1,2)) 可选参数和默认参数可选参数在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。123456function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + &quot; &quot; + lastName; else return firstName;&#125; 参数默认值 123function function_name(param1[:type],param2[:type] = default_value) &#123; &#125; 注意：参数不能同时设置为可选和默认。 实例：123456function calculate_discount(price:number, rate:number = 0.50) &#123; var discount = price * rate; console.log(&quot;计算结果: &quot;, discount); &#125; calculate_discount(1000) calculate_discount(1000, 0.30)","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://lengziyu.cn/tags/TypeScript/"},{"name":"ES6","slug":"ES6","permalink":"http://lengziyu.cn/tags/ES6/"}]},{"title":"vue项目优化","slug":"vue-performance-optimizing","date":"2020-08-26T09:14:45.000Z","updated":"2020-09-08T13:12:32.288Z","comments":true,"path":"2020/08/26/vue-performance-optimizing/","link":"","permalink":"http://lengziyu.cn/2020/08/26/vue-performance-optimizing/","excerpt":"","text":"项目主要针对首屏加载做处理，至少能提升70%。 vue-cli3 webpack3 cdn配置cdn优点：有利于减少打包体积，可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。 12345678910// vue.config.jsmodule.exports = &#123; chainWebpack: (config) =&gt;&#123; config.externals(&#123; &apos;vue&apos;: &apos;Vue&apos;, &apos;vuex&apos;: &apos;Vuex&apos;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;element-ui&apos;: &apos;ELEMENT&apos; &#125;)&#125; 相对稳定的cdn有bootcdn、unpkg。123456789// public/index.html&lt;!DOCTYPE html&gt; ... &lt;script src=&quot;https://unpkg.com/vue@2.6.10/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router@3.0.7/dist/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vuex@3.1.2/dist/vuex.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 去掉import，如：12// import Vue from &apos;vue&apos;// import Router from &apos;vue-router&apos; 去掉Vue.use(XXX)，如：1// Vue.use(Router) 服务器端开启Gzip开启 nginx 服务端 gzip性能优化。找到nginx配置文件在 http 配置里面添加如下代码，然后重启nginx服务即可。123456789http:&#123; gzip on; gzip_static on; gzip_buffers 4 16k; gzip_comp_level 5; gzip_types text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;&#125; 加载时长至少减少一半以上。 体积分析先安装webpack-bundle-analyzer1npm i webpack-bundle-analyzer -S 配置如下：123456chainWebpack: (config) =&gt;&#123; // 打包文件分析 config .plugin(&apos;webpack-bundle-analyzer&apos;) .use(require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin)&#125; 运行npm run serve启动就会自动打开浏览器页面http://127.0.0.1:8888。 对于用的少，体积又大的可以舍弃或者更换更小体积的库。 去掉预渲染该版本默认会自带预渲染，这样大大增加首屏渲染的加载时间。1234chainWebpack: (config) =&gt;&#123; // 移除prefetch插件 config.plugins.delete(&apos;prefetch&apos;)&#125; 如果部分需要预渲染的话，可以在router里配置：123const MenuTree = () =&gt; import(/* webpackChunkName: &quot;MenuTree&quot; */ &apos;./module/menu-tree&apos;);···components: &#123; MenuTree &#125; 小优化去掉线上的打印，关闭sourceMap。12345678910111213141516171819... chainWebpack: (config) =&gt;&#123; /** 去掉console.log debugger sourceMap*/ config.optimization.minimizer([ new UglifyJsWebpackPlugin(&#123; /**这个 sourceMap注释掉，默认就是置为false.(写为false 也是可以的)。 * 反之设为true 是生效的。 * 故在官方的配置(productionSourceMap: false)就可以注释掉了*/ sourceMap: false, uglifyOptions: &#123; warnings: false, compress: &#123; drop_console: true, drop_debugger: true &#125; &#125; &#125;) ]); &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://lengziyu.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lengziyu.cn/tags/Vue/"},{"name":"webpack3","slug":"webpack3","permalink":"http://lengziyu.cn/tags/webpack3/"},{"name":"vue-cli3","slug":"vue-cli3","permalink":"http://lengziyu.cn/tags/vue-cli3/"}]},{"title":"uniapp 自定义Tabbar探讨","slug":"uniapp-tabbar","date":"2020-02-13T07:46:37.000Z","updated":"2020-09-08T13:13:12.907Z","comments":true,"path":"2020/02/13/uniapp-tabbar/","link":"","permalink":"http://lengziyu.cn/2020/02/13/uniapp-tabbar/","excerpt":"","text":"为什么要用自定义tabbar？原生自带的满足不了吗？答：是的，基于两点需求，1.显示红点数量样式修改；2.底部弹框被原生tabbar挡住。 尝试过多种方案，也没有达到预期。1.tabbar组件形式每个tabbar页面都引用自定义tabbar组件，传当前页面的参数作为选中当前项。不足：每次切换tabbar页面，组件也重新加载，达不到效果。 2.页面组件形式tabbar页面全部作为组件形式，先新建一个index.vue页面，引入自定义tabbar，引入全部tabbar页面组件，为tabbar按钮添加点击事件，判断显示哪个页面组件。12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;page-work v-if=&quot;current == 0&quot; /&gt; &lt;page-maillist v-if=&quot;current == 1&quot; /&gt; &lt;page-order v-if=&quot;current == 2&quot; /&gt; &lt;page-my v-if=&quot;current == 3&quot; /&gt; &lt;sl-tabbar @tabbarBack=&quot;tabbarBack&quot; :current=&quot;current&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import pageWork from &apos;../../pages/work/index.vue&apos;import pageMaillist from &apos;../../pages/maillist/index.vue&apos;import pageOrder from &apos;../../pages/order/index.vue&apos;import pageMy from &apos;../../pages/my/index.vue&apos;import slTabbar from &apos;@/components/tabbar/index.vue&apos;export default &#123; components: &#123; pageWork, pageMaillist, pageOrder, pageMy, slTabbar, &#125;, data() &#123; return &#123; current: 0 &#125; &#125;, methods: &#123; tabbarBack(i, idx) &#123; this.current = idx; &#125; &#125; 不足：页面的特性已经丧失，页面生命周期不复存在，严重影响原有页面逻辑。 3.按需显示隐藏原生tabbar使用uni.showTabBar()和uni.hideTabBar()动态显示隐藏原生tabbar，弹框的时候隐藏原生tabbar，并同时显示自定义tabbar，否则反之。不足，切换时有闪烁效果，不理想。","categories":[],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"http://lengziyu.cn/tags/uniapp/"}]},{"title":"uniapp 开发记录","slug":"vue-summarizing-skills","date":"2019-10-18T11:53:40.000Z","updated":"2020-09-08T13:13:55.592Z","comments":true,"path":"2019/10/18/vue-summarizing-skills/","link":"","permalink":"http://lengziyu.cn/2019/10/18/vue-summarizing-skills/","excerpt":"","text":"基本单位用rpx，布局用Flex 打包云端打包安卓端&amp;iOS云端打包流程：打开HBuilderX，顶部菜单【发行-&gt;原生App-云打包】，选打自定义调试基座，等待打包成功，原生App-查看云打包状态，编辑器底部打印台会显示最近打包的地址，点击下载即可。注：iOS端需要苹果开发证书。 本地离线打包安卓 用官方HBuilder-Hello的项目，参考这个：uni-app用AndroidStudio打包apk文件 h5与app区别 CSSbackground-size属性，写在CSS里h5端生效，但是app端无效：1234// app无效uni-swiper-item&#123; background-size: 100% 100%;&#125; 解决方法：就是在标签动态添加backgroundSize属性：1234&lt;uni-swiper-item:style=&quot;&#123; backgroundImage: &apos;url(&apos;+ banner.url +&apos;)&apos;, backgroundSize: &apos;cover&apos; &#125;&quot;&gt;&lt;/uni-swiper-item&gt;","categories":[],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"http://lengziyu.cn/tags/uniapp/"}]},{"title":"公众号用vue开发百度地图","slug":"weixin_use_baidu_map","date":"2019-09-10T15:01:18.000Z","updated":"2019-09-16T14:37:55.676Z","comments":true,"path":"2019/09/10/weixin_use_baidu_map/","link":"","permalink":"http://lengziyu.cn/2019/09/10/weixin_use_baidu_map/","excerpt":"","text":"功能描述最近用vue在公众号结合百度地图开发，功能是根据公众号定位获取经纬度，再用百度地图显示附近的店铺。由于公众号不能满足业务需求，所以加上百度地图。 知识点 微信公众号获取经纬度 公众号经纬度转换百度经纬度 vue开发用vue-baidu-map开发注意事项 百度地图逆/地址解析 推荐一些相关的开发/测试工具 微信公众号获取经纬度公众号文档-获取地理位置接口前提是公众号的一切东西都设置好，要先调接口获取签名，然后通过wx.config安全验证，1234567891011121314151617181920212223242526272829303132333435363738394041/*** 获取公众号经纬度* Vue 注册全局函数的方式 */Vue.prototype.wxLocation = (opts) =&gt; &#123; const ua = window.navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == &apos;micromessenger&apos;) &#123; // 这是一个请求，获取签名 api.wxSignature(&#123; url: window.location.href.split(&apos;#&apos;)[0] &#125;) .then(res =&gt; &#123; // 安全验证 wx.config(&#123; debug: false, appId: res.data.appid, timestamp: res.data.timestamp, nonceStr: res.data.nonceStr, signature: res.data.signature, jsApiList: [ &apos;openLocation&apos;, &apos;getLocation&apos;, ], &#125;); wx.ready(() =&gt; &#123; // 获取经纬度 wx.getLocation(&#123; type: &apos;wgs84&apos;, // 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入&apos;gcj02&apos; success: (res)=&gt; &#123; var latitude = res.latitude; // 纬度，浮点数，范围为90 ~ -90 var longitude = res.longitude; // 经度，浮点数，范围为180 ~ -180。 opts.wxGetLocation(res) &#125;, &#125;); &#125;) &#125;) &#125; else &#123; console.log(&apos;非微信端，不获取地址！&apos;) &#125;&#125;, 页面调用：1234567created() &#123; this.wxLocation(&#123; wxGetLocation: function(res) &#123; console.log(res); &#125; &#125;);&#125;, 公众号经纬度转换百度经纬度目前国内主要有以下三种坐标系： WGS84：为一种大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。 GCJ02：又称火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。 BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标。 非中国地区地图，服务坐标统一使用WGS84坐标。百度地图-坐标转换说明 我了解的有两种方式转换： 文档化-坐标转换服务 通过接口转换下面介绍通过接口的方式转换：1http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846 其中from参数：0代表WGS-84即标准GPS设备返回的坐标, 2代表国测局的标准；to参数：4代表百度的坐标；x参数：代表纬度latitude；y参数：代表经度longitude。 大概会出现跨域问题，我用了vue-cli2配置的proxyTable无法解决，后来我用了朋友的跨域应用解决了：1https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846 转换出来是经过base64加码的，这样子：1&#123;&quot;error&quot;:0,&quot;x&quot;:&quot;MTEzLjU1MTgxMDg2MDE5&quot;,&quot;y&quot;:&quot;MjMuNTIxMjM0OTM0OTE0&quot;&#125; 用js-base64解码：1234567let Base64 = require(&apos;js-base64&apos;).Base64;...axios.get(&apos;https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846&apos;) .then(res)&#123; var longitude = Base64.decode(res.x); var latitude = Base64.decode(res.y); &#125; 此时，转换经纬度大功告成！ vue开发用vue-baidu-map开发注意事项安装就不说了，文档都有，说说遇到的坑吧。问题1. 自定义覆盖物，定义的按钮不触发事件，查看DOM，发现触发了地图蒙层，解决：引入1&lt;script src=&quot;http://api.map.baidu.com/library/EventWrapper/1.2/src/EventWrapper.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 使用：123456789101112// html&lt;baidu-map class=&quot;bm-view&quot; ref=&quot;baiduMap&quot; :zoom=&quot;15&quot; @click=&quot;overlay&quot;&gt;&lt;/baidu-map&gt;// jsmethods: &#123; overlay(event) &#123; BMapLib.EventWrapper.addDomListener(this.$refs.baiduMap.$el, &quot;touchend&quot;, (e)=&gt;&#123; alert(&apos;点击触发&apos;) &#125;, false)&#125;, 问题2.获取百度地图实例BMap，解决：123456789101112// html&lt;baidu-map class=&quot;bm-view&quot; ref=&quot;baiduMap&quot; @ready=&quot;mapHandler&quot; :zoom=&quot;15&quot;&gt;&lt;/baidu-map&gt;// jsmethods: &#123; // 初始化 mapHandler(e) &#123; console.log(e) // &#123; BMap: xx, map: xx &#125; &#125;,&#125;, 推荐一些相关的开发/测试工具 查询经纬度","categories":[],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://lengziyu.cn/tags/微信公众号/"}]},{"title":"Windows Flutter安装和运行","slug":"windows-flutter-install","date":"2019-08-01T08:34:21.000Z","updated":"2019-08-15T15:18:29.122Z","comments":true,"path":"2019/08/01/windows-flutter-install/","link":"","permalink":"http://lengziyu.cn/2019/08/01/windows-flutter-install/","excerpt":"","text":"Flutter介绍Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 Windows环境要求 Java环境（配置环境变量）； Android Studio（主要安装模拟器和自带环境）； Vscode（“宇宙之强”编辑器）； Git。 Flutter安装官网安装：https://flutter.dev/docs/get-started/installorGithub（有点大，可能要多试几次）：$ git clone -b beta https://github.com/flutter/flutter.git 测试是否安装完成：1$ flutter --help 查看是否需要安装任何依赖项来完成设置：1$ flutter doctor 提示：有报红的一个一个的解决（打×的要解决，!号的可以不用）。 Vscode插件安装 flutter dart安装完重启vscode，在编辑器的左下角的设置点击进入 “命令面板”，在命令面板中点击flutter：new project [项目名称] 启动在终端命令行里面输入 ： $ flutter run 等待程序的执行，完成hello world 123456R 键重新启动r 键热重载q 退出p 显示网格P 显示帧率o 切换Android与iOS的预览模式","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://lengziyu.cn/categories/Flutter/"}],"tags":[]},{"title":"基于Vue SEO的四种方案","slug":"vue-seo","date":"2019-06-30T11:29:45.000Z","updated":"2019-08-15T15:18:08.743Z","comments":true,"path":"2019/06/30/vue-seo/","link":"","permalink":"http://lengziyu.cn/2019/06/30/vue-seo/","excerpt":"","text":"前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。 1.SSR服务器渲染； 2.静态化； 3.预渲染prerender-spa-plugin； 4.使用Phantomjs针对爬虫做处理。 1.SSR服务器渲染关于服务器渲染：Vue官网介绍，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。 使用SSR权衡之处： 开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行； 环境和部署要求更高，需要Node.js server 运行环境； 高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。 优势： 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面； 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。 不足：（开发中遇到的坑）1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：123if(process.browser)&#123; console.log(window);&#125; 引用npm包，带有dom操作的，例如：wowjs，不能用import的方式，改用：1234if (process.browser) &#123; var &#123; WOW &#125; = require(&apos;wowjs&apos;); require(&apos;wowjs/css/libs/animate.css&apos;); &#125; 2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于页面组件调用： 1234567891011121314// 并发加载多个接口： async asyncData (&#123; app, query &#125;) &#123; let [resA, resB, resC] = await Promise.all([ app.$axios.get(&apos;/api/a&apos;), app.$axios.get(&apos;/api/b&apos;), app.$axios.get(&apos;/api/c&apos;), ]) return &#123; dataA: resA.data, dataB: resB.data, dataC: resC.data, &#125; &#125; 在asyncData中获取参数：1234567891011121314151617181.获取动态路由参数，如：/list/:id&apos; ==&gt; &apos;/list/123接收：async asyncData (&#123; app, query &#125;) &#123; console.log(app.context.params.id) //123&#125;2.获取url?获取参数，如：/list?id=123接收：async asyncData (&#123; app, query &#125;) &#123; console.log(query.id) //123&#125; 3.如果你使用v-if语法，部署到线上大概也会遇到这个错误：12Error while initializing app DOMException: Failed to execute &apos;appendChild&apos; on &apos;Node&apos;: This node type does not support this method. at Object.We [as appendChild] 根据github nuxt上的issue第1552条提示，要将v-if改为v-show语法。 4.坑太多，留坑，晚点更。 2.静态化静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。1234-| pages/---| index.vue---| users/-----| _id.vue 需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。12345678910// nuxt.config.jsmodule.exports = &#123; generate: &#123; routes: [ &apos;/users/1&apos;, &apos;/users/2&apos;, &apos;/users/3&apos; ] &#125;&#125; 运行打包，即可看见打包出来的页面。但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？ 使用一个返回 Promise 对象类型 的 函数； 使用一个回调是 callback(err, params) 的 函数。123456789101112131415161718// nuxt.config.jsimport axios from &apos;axios&apos;export default &#123; generate: &#123; routes: function () &#123; return axios.get(&apos;https://my-api/users&apos;) .then((res) =&gt; &#123; return res.data.map((user) =&gt; &#123; return &#123; route: &apos;/users/&apos; + user.id, payload: user &#125; &#125;) &#125;) &#125; &#125;&#125; 现在我们可以从/users/_id.vue访问的payload，如下所示：1234async asyncData (&#123; params, error, payload &#125;) &#123; if (payload) return &#123; user: payload &#125; else return &#123; user: await backend.fetchUser(params.id) &#125;&#125; 如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。优势： 纯静态文件，访问速度超快； 对比SSR，不涉及到服务器负载方面问题； 静态网页不宜遭到黑客攻击，安全性更高。 不足： 如果动态路由参数多的话不适用。 3.预渲染prerender-spa-plugin如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。1$ cnpm install prerender-spa-plugin --save vue cli 3 vue.config.js配置：1234567891011121314151617181920212223242526272829const PrerenderSPAPlugin = require(&apos;prerender-spa-plugin&apos;);const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;const path = require(&apos;path&apos;);module.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV !== &apos;production&apos;) return; return &#123; plugins: [ new PrerenderSPAPlugin(&#123; // 生成文件的路径，也可以与webpakc打包的一致。 // 下面这句话非常重要！！！ // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。 staticDir: path.join(__dirname,&apos;dist&apos;), // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。 routes: [&apos;/&apos;, &apos;/product&apos;,&apos;/about&apos;], // 这个很重要，如果没有配置这段，也不会进行预编译 renderer: new Renderer(&#123; inject: &#123; foo: &apos;bar&apos; &#125;, headless: false, // 在 main.js 中 document.dispatchEvent(new Event(&apos;render-event&apos;))，两者的事件名称要对应上。 renderAfterDocumentEvent: &apos;render-event&apos; &#125;) &#125;), ], &#125;; &#125;&#125; 在main.js中添加：1234567new Vue(&#123; router, render: h =&gt; h(App), mounted () &#123; document.dispatchEvent(new Event(&apos;render-event&apos;)) &#125;&#125;).$mount(&apos;#app&apos;) 注意：router中必须设置 mode: “history”。 打包出来可以看见文件，打包出文件夹/index.html，例如：about =&gt; about/index.html，里面有html内容。 优势： 改动小，引入个插件就完事； 不足： 无法使用动态路由； 只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢； 4.使用Phantomjs针对爬虫做处理Phantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。 具体代码戳这里：vue-seo-phantomjs。要安装全局phantomjs，局部express，测试：1$ phantomjs spider.js &apos;https://www.baidu.com&apos; 如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。启动之后或者用postman在请求头增加User-Agent值为Baiduspider，效果一样的。 部署上线线上要安装node、pm2、phantomjs，nginx相关配置： 123456789101112131415161718upstream spider_server &#123; server localhost:3000;&#125;server &#123; listen 80; server_name example.com; location / &#123; proxy_set_header Host $host:$proxy_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; if ($http_user_agent ~* &quot;Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider&quot;) &#123; proxy_pass http://spider_server; &#125; &#125;&#125; 优势： 完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多； 对已用SPA开发完成的项目，这是不二之选。 不足： 部署需要node服务器支持； 爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫； 如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。 总结如果构建大型网站，如商城类，别犹豫，直接上SSR服务器渲染，当然也有相应的坑等你，社区较成熟，英文好点，一切问题都迎刃而解。如果只是个人博客、公司官网这类，其余三种都可以。如果对已用SPA开发完成的项目进行SEO优化，而且支持node服务器，请使用Phantomjs。 很少写文章，这是我这个月对Vue SEO方案的探索，写的不对的地方请指出，谢谢理解~","categories":[{"name":"Vue","slug":"Vue","permalink":"http://lengziyu.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lengziyu.cn/tags/Vue/"},{"name":"SEO","slug":"SEO","permalink":"http://lengziyu.cn/tags/SEO/"},{"name":"Phantomjs","slug":"Phantomjs","permalink":"http://lengziyu.cn/tags/Phantomjs/"}]},{"title":"回顾我的2016","slug":"hello-2017","date":"2016-12-31T14:38:13.000Z","updated":"2019-08-15T15:03:33.955Z","comments":true,"path":"2016/12/31/hello-2017/","link":"","permalink":"http://lengziyu.cn/2016/12/31/hello-2017/","excerpt":"原来今天已经是2016最后一天，是时候写一个总结了。一方面可以总结这一年的收获和不足之处进行反思，一方面为新的一年埋下信念。","text":"原来今天已经是2016最后一天，是时候写一个总结了。一方面可以总结这一年的收获和不足之处进行反思，一方面为新的一年埋下信念。 关于工作今年3月份，公司内部管理发生变动。我们网站部被合并到发行部，遭遇发行部老大强势管理，气氛突然紧张起来。平时没事做也要陪发行部的加班到九点，还有老大之前和我们几个提工资也被取消了。钱没够心里也受尽委屈，渐渐也有了离职的打算。后来被老大约谈说公司准备在我们网站部和设计部分别裁员2人，我平时太闲，所以入了名单。最后争取了一个月赔偿金，总之感觉还不错吧~ 找工作之后的一星期，面试了几家，还在知乎回答了一个问题呢，Web前端岗位面试题有哪些？- 冷子欲的回答，就这样交了几个朋友。面试当中也算是遇上形形色色的面试官，大概面试了7家，收到了3家offer，过程学到了不少，也了解到自己需要加强的地方，最后选择了一家离租房近点，薪资高点，规模大点的 - 恒拓开源（开源中国）。 学习还是学习7月份，外包派驻到“南方航空”，离租房太远，被迫搬到白云区了。负责“新技术研究”这块，每天学习webpack、node、react、ES6/ES7 ，当然除了学习，也有活要做的： 搭建了一个内部用的gulp-webpack脚手架； 个人用react开发了”额外付费行李”项目； 用sinopia在linux服务器上搭建了南航内部npm管理系统； 和同事研究海外版react项目，并编写简单易懂的开发文档，并展开了技术分享会（供南航团队内部人学习）； 直到现在。 关于技术[ 2015.04 - 2016.04 ] 公司只有一个前端，活很少，所以见识和接触到的也比较少，空闲时间比较喜欢折腾新技术。并写一些小demo经过分析和测试，实战到工作当中，解决了一些痛点、提高了开发效率以及优化网站访问速度。 比如：fis3、requirejs、sass、gulp、按需加载、懒加载等等。[ 2016.04 - 2016.07 ] 这段时间，用阿里开源的sui开发，采用前后端分离模式…不多说了。[ 2016.07 - 至今 ] react全家桶、webpack从简单配置到大项目应用、ES6/ES7语法、node。当中也陆陆续续的用过vue，从vue1到vue2，并在 createjs中文网改版中实战了一把vue2，感觉小清新，比较快上手。学习webpack过程中综合了一些资源和教程，收获100多start github learn-webpack。2016还在继续维护 前端导航 呢。 关于创业？一个好朋友在筹备做一个DIY衣服的网站，已找到一些合伙人。某天听着他说的不错，我后来也加入了。我负责前端部分工作，一起商议搭建用的框架/技术，一起探讨盈利模式。我做了一部分，后来由于工作忙，而且我觉得创业这事我还未准备好，我就提出退出了。 其他 看了不少电影，最喜欢的是《碟中谍5》、《谍影重重5》啦； 书籍：《js高程》、《js设计模式》，比较少看书； 对于我家喵大人，平时当女孩纸养，绝育的时候才知道是蓝孩纸（尴尬）。还有就是5月份跑出去了几天，找到的时候真的很欣慰，2017继续做好铲屎君。 工作已两年半，今年才23岁。没错我没上大学，理由不说了，现在是中技学历，今年末参加了成人高考，成功在华南理工大学报考了专科，见笑了~盲羊补牢，为时不晚嘛。关于2017计划赶不上变化，所以我也不轻言计划了。想怎样就怎样吧，当然是继续努力啦。 相信2017将会发生更多有趣的故事，更多的改变。朋友，2017让我们一起为美好的生活而努力吧！！共勉。写文水平有限。","categories":[],"tags":[]},{"title":"ES6 function* yield yield*","slug":"es6-new-grammar","date":"2016-12-08T14:03:09.000Z","updated":"2019-08-15T15:03:33.954Z","comments":true,"path":"2016/12/08/es6-new-grammar/","link":"","permalink":"http://lengziyu.cn/2016/12/08/es6-new-grammar/","excerpt":"这里主要讲解es6新语法function*、yield和yield*。","text":"这里主要讲解es6新语法function*、yield和yield*。 function*简介定义一个generator（生成器）函数，返回一个Generator对象。 语法1function* name[ param[ param[ param…]]] &#123; statements &#125; name 函数名 param 传入函数的参数名，一个函数最多可有255个参数 statements 函数的主体 描述生成器是一种可以在从中退出并在之后重新进入的函数。生成器环境在执行后会被保存，下次执行可继续使用。 调用生成器函数，并不立即执行主体，而是返回这个生成器函数的迭代器对象，当这个迭代器调用next()方法时，生成器函数主体会被执行至第一个 yield 表达式，该表达式定义了迭代器返回的值，或者，被 yield* 委托至另一个生成器函数。next() 方法返回一个对象，该对象有一个value属性，表示产出的值，和一个done属性，表示生成器是否已经产出了它最后的值。 基本事例123456789101112function* idMaker()&#123; var index = 0; while(index&lt;3) yield index++;&#125;var gen = idMaker();console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2console.log(gen.next().value); // undefined yield* 事例12345678910111213141516171819function* anotherGenerator(i) &#123; yield i + 1; yield i + 2; yield i + 3;&#125;function* generator(i)&#123; yield i; yield* anotherGenerator(i); yield i + 10;&#125;var gen = generator(10);console.log(gen.next().value); // 10console.log(gen.next().value); // 11console.log(gen.next().value); // 12console.log(gen.next().value); // 13console.log(gen.next().value); // 20 兼容性属于ES6规范，请使用babel转换 yield简介yield关键词用来停止或继续一个生成器函数。 语法1yield[[ expression ]] expression 用作返回值，如果忽略，则返回undefined 描述yield 关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值. 可以把它想成是 return 关键字的一个基于生成器的版本.yield 关键字实际返回一个对象，包含两个属性, value 和 done. value 属性为 yield expression 的值, done 是一个布尔值用来指示生成器函数是否已经全部完成.一旦在 yield expression 处暂停, 除非外部调用生成器的 next() 方法，否则生成器的代码将不能继续执行. 这使得可以对生成器的执行以及渐进式的返回值进行直接控制. 事例12345678910111213function* foo()&#123; var index = 0; while (index &lt;= 2) // when index reaches 3, // yield&apos;s done will be true // and its value will be undefined; yield index++;&#125;一旦生成器函数已定义，可以通过构造一个迭代器来使用它.var iterator = foo();console.log(iterator.next()); // &#123; value:0, done:false &#125;console.log(iterator.next()); // &#123; value:1, done:false &#125;console.log(iterator.next()); // &#123; value:2, done:false &#125;console.log(iterator.next()); // &#123; value:undefined, done:true &#125; yield*简介在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。 语法yield*[[ expression ]] expression 任意可迭代的对象 描述yield 一个可迭代对象，就相当于把这个可迭代对象的所有迭代值分次 yield 出去。yield 表达式本身的值就是当前可迭代对象迭代完毕（当done为true时）时的返回值。 事例委托给其他生成器以下代码中，g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回，就像那些 yield 语句是写在 g2() 里一样。1234567891011121314151617181920function* g1() &#123; yield 2; yield 3; yield 4;&#125;function* g2() &#123; yield 1; yield* g1(); yield 5;&#125;var iterator = g2();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: 4, done: false &#125;console.log(iterator.next()); // &#123; value: 5, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; 委托给其他类型的可迭代对象除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。123456789101112131415function* g3() &#123; yield* [1, 2]; yield* &quot;34&quot;; yield* arguments;&#125;var iterator = g3(5, 6);console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: &quot;3&quot;, done: false &#125;console.log(iterator.next()); // &#123; value: &quot;4&quot;, done: false &#125;console.log(iterator.next()); // &#123; value: 5, done: false &#125;console.log(iterator.next()); // &#123; value: 6, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; yield* 表达式的值yield* 是一个表达式，不是语句，所以它会有自己的值。1234567891011121314151617181920function* g4() &#123; yield* [1, 2, 3]; return &quot;foo&quot;;&#125;var result;function* g5() &#123; result = yield* g4();&#125;var iterator = g5();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125;, // 此时 g4() 返回了 &#123; value: &quot;foo&quot;, done: true &#125;console.log(result); // &quot;foo&quot;","categories":[{"name":"es6","slug":"es6","permalink":"http://lengziyu.cn/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://lengziyu.cn/tags/es6/"}]},{"title":"redux 基础","slug":"redux-basics","date":"2016-12-08T14:01:25.000Z","updated":"2019-08-15T15:03:33.979Z","comments":true,"path":"2016/12/08/redux-basics/","link":"","permalink":"http://lengziyu.cn/2016/12/08/redux-basics/","excerpt":"StoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供createStore这个函数，用来生成 Store。","text":"StoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供createStore这个函数，用来生成 Store。12import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(fn); 上面createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 StateStore对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。当前时刻的 State，可以通过store.getState()拿到。1const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 Action12345Action 是一个对象。其中的type属性是必须的，表示 Action 的名称const action = &#123; type: &apos;ADD_TODO&apos;, payload: &apos;Learn Redux&apos;&#125;; Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 Action Creator可以定义一个函数来生成Action，这个函数叫Action Creator12345678const ADD_TODO = &apos;添加 TODO&apos;;function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo(&apos;Learn Redux&apos;); 上面代码中，add Todo就是一个Action Creator store.dispatch()store.dispatch()是view发出Action的唯一方法1234567import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(fn) store.dispatch(&#123; type: &apos;ADD_TODO&apos;, payload: &apos;Learn Redux&apos; &#125;) 结合1store.dispatch(addTodo(&apos;Learn Redux&apos;)) ReducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会有变化。这种 State 的计算过程叫做 Reducer是一个函数，它能接受 Action 和 当前 State 作为参数，返回新的 State。123const reducer = function(action, state) &#123; return newState;&#125; store.dispatch 会触发reducer自动执行，做法就是在生成store的时候，将reducer传入createStore方法。1const store = createStore(reducer); store.subscribe()Store 允许使用 store.subcribe() 设置为监听函数，一旦 State 发生变化，就自动执行这个函数。123import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(reducer);store.subscribe(listener); 只要把view的更新函数放入listener，就会实现view的自动渲染。 store.subscribe 方法返回一个函数，调用这个函数就可以解除1234let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()) )unsubscribe() Store 的实现提供了三个方法 store.getState() store.dispatch() store.subscrobe()12import &#123; createStore &#125; from &apos;redux&apos;;let &#123; getState, dispatch, subscribe &#125; = createStore(reducer); Reducer 拆分Redux 提供了 combineReducers 方法拆分 Reducer123456import &#123; combineReducers &#125; from &apos;redux&apos;;const reduer = combineReducers(&#123; a: doSomethingsWidthA, b: processB, c: c&#125;) 把子reducer放在一个文件里，然后统一引入123import &#123; createStore &#125; from &apos;redux&apos;import * as reducers from &apos;./reducers&apos;const reducer = combineReducers(reducers)","categories":[],"tags":[{"name":"redux","slug":"redux","permalink":"http://lengziyu.cn/tags/redux/"}]},{"title":"nodejs fs模块的使用","slug":"node-use-fs-modules","date":"2016-11-17T13:26:19.000Z","updated":"2019-08-15T15:03:33.958Z","comments":true,"path":"2016/11/17/node-use-fs-modules/","link":"","permalink":"http://lengziyu.cn/2016/11/17/node-use-fs-modules/","excerpt":"fs是nodejs的文件系统，使用方法均有异步和同步版本，建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。使用fs模块可以轻松地对文件/文件夹进行操作。","text":"fs是nodejs的文件系统，使用方法均有异步和同步版本，建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。使用fs模块可以轻松地对文件/文件夹进行操作。 异步和同步创建 test.txt 文件，内容如下：12blog.lengziyu.com文件读取test 创建 file.js 文件, 代码如下：123456789101112131415var fs = require(&quot;fs&quot;);// 异步读取fs.readFile(&apos;input.txt&apos;, function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;异步读取: &quot; + data.toString());&#125;);// 同步读取var data = fs.readFileSync(&apos;input.txt&apos;);console.log(&quot;同步读取: &quot; + data.toString());console.log(&quot;程序执行完毕。&quot;); 打开文件语法1fs.open(path, flags[, mode], callback) 参数 path - 文件的路径。 flags - 文件打开的行为。具体值详见下文。 mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。 callback - 回调函数，带有两个参数如：callback(err, fd)。 例子接下来我们创建 file.js 文件，并打开 test.txt 文件进行读写，代码如下所示：12345678910var fs = require(&quot;fs&quot;);// 异步打开文件console.log(&quot;准备打开文件！&quot;);fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;文件打开成功！&quot;); &#125;); 获取文件信息语法1fs.stat(path, callback) 参数 path - 文件路径。 callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。 例子接下来我们创建 file.js 文件，代码如下所示：1234567891011121314var fs = require(&quot;fs&quot;);console.log(&quot;准备打开文件！&quot;);fs.stat(&apos;test.txt&apos;, function (err, stats) &#123; if (err) &#123; return console.error(err); &#125; console.log(stats); console.log(&quot;读取文件信息成功！&quot;); // 检测文件类型 console.log(&quot;是否为文件(isFile) ? &quot; + stats.isFile()); console.log(&quot;是否为目录(isDirectory) ? &quot; + stats.isDirectory()); &#125;); 写入文件语法1fs.writeFile(filename, data[, options], callback) 参数 path - 文件路径。 data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。 options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’ callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。 例子接下来我们创建 file.js 文件，代码如下所示：1234567891011121314151617var fs = require(&quot;fs&quot;);console.log(&quot;准备写入文件&quot;);fs.writeFile(&apos;test.txt&apos;, &apos;我是通过写入的文件内容！&apos;, function(err) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;数据写入成功！&quot;); console.log(&quot;--------我是分割线-------------&quot;) console.log(&quot;读取写入的数据！&quot;); fs.readFile(&apos;test.txt&apos;, function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;异步读取文件数据: &quot; + data.toString()); &#125;);&#125;); 读取文件语法1fs.read(fd, buffer, offset, length, position, callback) 参数 fd - 通过 fs.open() 方法返回的文件描述符。 buffer - 数据写入的缓冲区。 offset - 缓冲区写入的写入偏移量。 length - 要从文件中读取的字节数。 position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。 callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。 例子test.txt 文件内容为：1www.lengziyu.com 接下来我们创建 file.js 文件，代码如下所示：12345678910111213141516171819202122var fs = require(&quot;fs&quot;);var buf = new Buffer(1024);console.log(&quot;准备打开已存在的文件！&quot;);fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;文件打开成功！&quot;); console.log(&quot;准备读取文件：&quot;); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123; if (err)&#123; console.log(err); &#125; console.log(bytes + &quot; 字节被读取&quot;); // 仅输出读取的字节 if(bytes &gt; 0)&#123; console.log(buf.slice(0, bytes).toString()); &#125; &#125;);&#125;); 删除文件语法1fs.unlink(path, callback) 参数 path - 文件路径。 callback - 回调函数，没有参数。 例子test.txt 文件内容为：1www.lengziyu.com 接下来我们创建 file.js 文件，代码如下所示：123456789var fs = require(&quot;fs&quot;);console.log(&quot;准备删除文件！&quot;);fs.unlink(&apos;test.txt&apos;, function(err) &#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;文件删除成功！&quot;);&#125;); 再去查看 test.txt 文件，发现已经不存在了。 创建目录语法1fs.mkdir(path[, mode], callback) 参数 path - 文件路径。 mode - 设置目录权限，默认为 0777。 callback - 回调函数，没有参数。 例子接下来我们创建 file.js 文件，代码如下所示：123456789var fs = require(&quot;fs&quot;);console.log(&quot;创建目录 /test/&quot;);fs.mkdir(&quot;/test/&quot;,function(err)&#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;目录创建成功。&quot;);&#125;); 读取目录语法1fs.readdir(path, callback) 参数 path - 文件路径。 callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。 例子接下来我们创建 file.js 文件，代码如下所示：1234567891011var fs = require(&quot;fs&quot;);console.log(&quot;查看 /test 目录&quot;);fs.readdir(&quot;/test/&quot;,function(err, files)&#123; if (err) &#123; return console.error(err); &#125; files.forEach( function (file)&#123; console.log( file ); &#125;);&#125;); 删除目录语法1fs.rmdir(path, callback) 参数 path - 文件路径。 callback - 回调函数，没有参数。 例子接下来我们创建 file.js 文件，代码如下所示：1234567891011121314151617var fs = require(&quot;fs&quot;);console.log(&quot;准备删除目录 /tmp/test&quot;);fs.rmdir(&quot;/tmp/test&quot;,function(err)&#123; if (err) &#123; return console.error(err); &#125; console.log(&quot;读取 /tmp 目录&quot;); fs.readdir(&quot;/tmp/&quot;,function(err, files)&#123; if (err) &#123; return console.error(err); &#125; files.forEach( function (file)&#123; console.log( file ); &#125;); &#125;);&#125;); 更多内容，请查看官网文件模块描述：File System。","categories":[{"name":"node","slug":"node","permalink":"http://lengziyu.cn/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://lengziyu.cn/tags/node/"}]},{"title":"MongoDB 学习笔记","slug":"MongoDB-learn-note","date":"2016-11-05T09:15:25.000Z","updated":"2019-08-15T15:03:33.958Z","comments":true,"path":"2016/11/05/MongoDB-learn-note/","link":"","permalink":"http://lengziyu.cn/2016/11/05/MongoDB-learn-note/","excerpt":"简介：MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。旨在为WEB应用提供可扩展的高性能数据存储解决方案。","text":"简介：MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 常用shell开启服务：1$ net start MongoDB 停止服务：1$ net stop MongoDB 删除服务：1$ &quot;D:\\MongoDB\\bin\\Server\\3.2\\mongod.exe&quot; --remove 简单操作命令用于查看当前操作的文档（数据库）：12345&gt; db //显示当前数据库对象或集合&gt; show dbs //显示所有数据的列表&gt; use test //运行&quot;use&quot;命令，可以连接到一个指定的数据库，这里连接到test数据库，如果连接的不存在，则自动新建&gt; db.runoob.insert(&#123;&quot;name&quot;:&quot;lengziyu&quot;&#125;) //向 runoob 数据库插入一些数据&gt; db.dropDatabase() //删除当前数据库","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://lengziyu.cn/tags/mongodb/"}]},{"title":"在win7上安装MongoDB","slug":"MongoDB-install-for-windows","date":"2016-11-05T09:14:45.000Z","updated":"2019-08-15T15:03:33.957Z","comments":true,"path":"2016/11/05/MongoDB-install-for-windows/","link":"","permalink":"http://lengziyu.cn/2016/11/05/MongoDB-install-for-windows/","excerpt":"最近用了一星期linux，感觉需要学习一门后端语言和一个数据库。暂时选定nodejs和MongoDB。","text":"最近用了一星期linux，感觉需要学习一门后端语言和一个数据库。暂时选定nodejs和MongoDB。 下载安装官网下载地址：https://www.mongodb.com/download-center#community老是提示下载不了，附百度云盘下载：http://pan.baidu.com/s/1c2KFwGC 密码:7vu0安装过程中我选择D:\\MongoDB安装目录，傻瓜式安装完成。 打开管理员命令提示需要通过管理员模式的命令提示符，来执行安装命令。管理员打开cmd输入以下命令：在MongoDB文件下创建data\\db：1mkdir D:\\MongoDB\\data\\db MongoDB需要数据目录来存储所有的数据，其默认的数据目录为\\data\\db ，可以通过mongod.exe –dbpath命令来指定MongoDB的数据目录。例如：1D:\\MongoDB\\Server\\3.2\\bin\\mongod.exe --dbpath D:\\MongoDB\\data\\db 看到上面的提示底部出现waiting for connections 字样，则表示dbpath配置完成，且MongoDB启动成功。而且此时打开资源管理器，进入MongoDB的dbpath目录，可以看见本地确实初始化数据库了。 运行MongoDB通过运行mongo.exe启动MongoDB。例如：1D:\\MongoDB\\Server\\3.2\\bin\\mongo.exe 命令行窗口显示如下内容：1232016-11-05T17:42:53.821+0800 I CONTROL [main] Hotfix KB2731284 or later update is not installed, will zero-out data filesMongoDB shell version: 3.2.10commecting to: test 窗口中可以看到当前MongoDB shell的版本，及此时连接的数据库。 设置全局path变量在计算机右键 ==&gt; 属性 ==&gt; 高级系统设置 ==&gt; 环境变量 ==&gt; 选择Path编辑 ==&gt;在最后面加;然后添加你安装的路径:D:\\MongoDB\\Server\\3.2\\bin\\mongo.exe确定保存。然后在cmd上输入：1mongo 此时会出现：1232016-11-05T17:42:53.821+0800 I CONTROL [main] Hotfix KB2731284 or later update is not installed, will zero-out data filesMongoDB shell version: 3.2.10connecting to: test 恭喜你，说明安装完成！","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://lengziyu.cn/tags/mongodb/"}]},{"title":"在 Linux 服务器上安装 node [搭建内部npm]","slug":"linux-nodejs","date":"2016-11-03T12:37:40.000Z","updated":"2019-08-15T15:03:33.956Z","comments":true,"path":"2016/11/03/linux-nodejs/","link":"","permalink":"http://lengziyu.cn/2016/11/03/linux-nodejs/","excerpt":"这周的工作任务是在 Linux 上搭建私人内部 npm，虽然网上很多教程，但是很多我缺踩了很多未知的坑，以此记录一下。","text":"这周的工作任务是在 Linux 上搭建私人内部 npm，虽然网上很多教程，但是很多我缺踩了很多未知的坑，以此记录一下。搭建私人npm大概有一下方法： 用 sinopia 安装； 淘宝 cnpm 安装。 cnpm 涉及到数据库mysql，弃之。 安装 node因为我的linux服务器无法连接外网，所以只能先连接外网下载好node源码，然后再用sftp上传到服务器上，这里我下载的是：node-v4.6.1-linux-x64.tar.gz。上传成功后，cd到该目录下，进行解压，并且cd进去：12$ tar xvf node-v4.6.1-linux-x64.tar.gz$ cd node-v4.6.1-linux-x64 安装：1./configure 测试是否安装成功：1./bin/node -v 此时成功的话会出现4.6.1。接下来设置为全局：12ln -s /home/node-v4.6.1-linux-x64/bin/node /usr/local/bin/nodeln -s /home/node-v4.6.1-linux-x64/bin/npm /usr/local/bin/npm 这里/home/这个路径是你自己放的，你将node文件解压到哪里就是哪里。1$ node -v 出现4.6.1，OK。此时设置全局完成。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://lengziyu.cn/tags/linux/"},{"name":"node","slug":"node","permalink":"http://lengziyu.cn/tags/node/"}]},{"title":"fetch 学习笔记","slug":"ajax-to-fetch","date":"2016-10-23T11:58:14.000Z","updated":"2019-08-15T15:03:33.953Z","comments":true,"path":"2016/10/23/ajax-to-fetch/","link":"","permalink":"http://lengziyu.cn/2016/10/23/ajax-to-fetch/","excerpt":"XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。","text":"XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。 安装npm ：1$ npm install whatwg-fetch --save 如果你项目在node.js环境运行，可以使用 node-fetch. 对于 babel 和 es2015+，可以这样导入 fetch：12import &apos;whatwg-fetch&apos;;fetch(...); 兼容性及解决方案原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+ ： 由于 IE8 是 ES3，需要引入 ES5 的 polyfill: es5-shim, es5-sham； 引入 Promise 的 polyfill: es6-promise； 引入 fetch 探测库：fetch-detector； 引入 fetch 的 polyfill: fetch-ie8； 可选：如果你还使用了 jsonp，引入 fetch-jsonp； 使用fetch 支持 HTTP 方法，下面主要用例子讲解 POST 和 GET 的请求。HTML 请求：123456fetch(&apos;/users.html&apos;) .then(function(response) &#123; return response.text() &#125;).then(function(body) &#123; document.body.innerHTML = body &#125;) JSON 请求：12345678fetch(&apos;/users.json&apos;) .then(function(response) &#123; return response.json() &#125;).then(function(json) &#123; console.log(&apos;parsed json&apos;, json) &#125;).catch(function(ex) &#123; console.log(&apos;parsing failed&apos;, ex) &#125;) 响应头设置：123456fetch(&apos;/users.json&apos;).then(function(response) &#123; console.log(response.headers.get(&apos;Content-Type&apos;)) console.log(response.headers.get(&apos;Date&apos;)) console.log(response.status) console.log(response.statusText)&#125;) Post 表单提交：123456var form = document.querySelector(&apos;form&apos;)fetch(&apos;/users&apos;, &#123; method: &apos;POST&apos;, body: new FormData(form)&#125;) Post JSON：1234567891011fetch(&apos;/users&apos;, &#123; method: &apos;POST&apos;, headers: &#123; &apos;Accept&apos;: &apos;application/json&apos;, &apos;Content-Type&apos;: &apos;application/json&apos; &#125;, body: JSON.stringify(&#123; name: &apos;Hubot&apos;, login: &apos;hubot&apos;, &#125;)&#125;) 上传文件：12345678910var input = document.querySelector(&apos;input[type=&quot;file&quot;]&apos;)var data = new FormData()data.append(&apos;file&apos;, input.files[0])data.append(&apos;user&apos;, &apos;hubot&apos;)fetch(&apos;/avatars&apos;, &#123; method: &apos;POST&apos;, body: data&#125;) 使用注意： Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: &#39;include&#39;}) 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。","categories":[{"name":"fetch","slug":"fetch","permalink":"http://lengziyu.cn/categories/fetch/"}],"tags":[{"name":"fetch","slug":"fetch","permalink":"http://lengziyu.cn/tags/fetch/"}]},{"title":"React 操作真实 DOM","slug":"react-use-dmo-refs","date":"2016-10-20T12:18:07.000Z","updated":"2019-08-15T15:03:33.962Z","comments":true,"path":"2016/10/20/react-use-dmo-refs/","link":"","permalink":"http://lengziyu.cn/2016/10/20/react-use-dmo-refs/","excerpt":"React中的每一个组件都是一个状态机，通常情况下，我们通过设置组件的状态就可以完成UI的更新，但是在某些情况下确实需要直接操作DOM。","text":"React中的每一个组件都是一个状态机，通常情况下，我们通过设置组件的状态就可以完成UI的更新，但是在某些情况下确实需要直接操作DOM。React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。 ref : 绑定属性 refs : 调用的时候使用 获取DOM实例通过ref属性，你可获取实例中的属性方法，甚至可以通过他获取到DOM实例节点 this.refs.xx.getDOMNode() ref 属性绑定1&lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt; refs 获取DOM实例获取支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。12// 输入框获取焦点this.refs.myInput.focus() 示例1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &apos;react&apos;;class MyComponent extends Component &#123; handleClick()&#123; this.refs.myInput.focus(); &#125; render()&#123; return( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;点我输入框获取焦点&quot; onClick=&#123;this.handleClick.bind(this)&#125; /&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;MyComponent/&gt;, document.querySelector(&apos;#app&apos;)); 获取myInput真实DOM的值：1var myInput = this.refs.myInput.props.value;","categories":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/tags/react/"}]},{"title":"React 笔记之 表单","slug":"react-to-biaodan","date":"2016-10-18T13:48:08.000Z","updated":"2019-08-15T15:03:33.979Z","comments":true,"path":"2016/10/18/react-to-biaodan/","link":"","permalink":"http://lengziyu.cn/2016/10/18/react-to-biaodan/","excerpt":"诸如： &lt;input&gt;、&lt;textarea&gt;、&lt;option&gt; 这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。","text":"诸如： &lt;input&gt;、&lt;textarea&gt;、&lt;option&gt; 这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。 交互属性在 HTML 中&lt;textarea&gt;的值通过子节点设置；在 React 中则应该使用 value 代替。表单组件可以通过onChange回调函数来监听组件变化。当用户做出以下交互时,onChange执行并通过浏览器做出响应： &lt;input&gt;或 &lt;textarea&gt; 的 value 发生变化时。 &lt;input&gt;的 checked 状态改变时。 &lt;option&gt; 的 selected 状态改变时。和所有 DOM 事件一样，所有的 HTML 原生组件都支持 onChange 属性，而且可以用来监听冒泡的 change 事件. 对于&lt;input&gt;和&lt;textarea&gt;，onChange应当被用于取代DOM内置的onInput事件处理 不可控组件和可控组件可控组件设置了 value 的 &lt;input&gt; 是一个受限组件。 对于受限的 &lt;input&gt;，渲染出来的 HTML 元素始终保持 value 属性的值。123render: function() &#123; return &lt;input type=&quot;text&quot; value=&quot;Hello!&quot;/&gt;; &#125; 上面的代码将渲染出一个值为 Hello! 的 input 元素。用户在渲染出来的元素里输入任何值都不起作用，因为 React 已经赋值为 Hello!。如果想响应更新用户输入的值，就得使用 onChange 事件12345678910getInitialState: function() &#123; return &#123;value: &apos;Hello!&apos;&#125;; &#125;, handleChange: function(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125;, render: function() &#123; var value = this.state.value; return &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;; &#125; Default Value初始值是状态中的value。如果要取数据，可直接使用 var inputValue = this.state.value。123render: function() &#123; return &lt;input type=&quot;text&quot; defaultValue=&#123;this.state.value&#125;/&gt;;&#125; 一个可控组件并不保持自己的原始状态；组件的呈现完全基于属性。实例1234567891011121314151617181920212223var Kekong = React.creatClass(&#123; getInitialState:function()&#123; return &#123; dada:&apos;shuaige&apos; &#125; &#125;, handleChange:function(e)&#123; this.setState(&#123; dada:e.target.value &#125;); &#125;, submitHandler:function(e)&#123; e.preventDefault(); alert(this.state.dada); &#125;, render:function()&#123; return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.dada&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;button type=&quot;submit&quot;&gt;speak&lt;/button&gt; &lt;/form&gt;; &#125;&#125;);ReactDOM.render(&lt;Kekong /&gt;,document.body); 不可控组件没有设置value(或者设为null) 的&lt;input&gt;组件是一个不可控组件。这样的话，组件中的数据和state中的数据并不对应，可以说，组件的数据不可控。123render: function() &#123; return &lt;input type=&quot;text&quot; /&gt;; &#125; 上面的代码将渲染出一个空值的输入框，用户输入将立即反应到元素上。和受限元素一样，使用 onChange 事件可以监听值的变化。Default Value如果想给组件设置一个非空的初始值，可以使用 defaultValue 属性。 数据在这里并没有存贮在状态中，而是写在input中。123render: function() &#123; return &lt;input type=&quot;text&quot; defaultValue=&quot;Hello!&quot; /&gt;;&#125; 如果要拿到input中的value，需先拿到其DOM节点，然后获取其value值1var inputValue = React.findDOMNode(this.refs.input).value 上面的代码渲染出来的元素和受限组件一样有一个初始值，但这个值用户可以改变并会反应到界面上。同样，&lt;input type=&quot;checkbox&quot;&gt;和&lt;input type=&quot;radio&quot;&gt;支持defaultChecked属性，&lt;select&gt;支持设置defaultValue。defaultValue和defaultChecked属性只能在初始的render函数中使用，如果你要在随后的render函数中更新value值，你需要使用可控组件。 实例1234567891011121314var UnKekong = React.creatClass(&#123; submitHandler:function(e)&#123; e.preventDefault(); var helloUnke = React.findDOMNode(this.refs.helloUnke).value; alert(helloUnke); &#125;, render:function()&#123; return &lt;form onsubmit=&#123;this.submitHandler&#125;&gt; &lt;input ref=&quot;helloUnke&quot; type=&quot;text&quot; defaultValue=&quot;Dada shuaige&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;speak&lt;/button&gt; &lt;/form&gt;; &#125;&#125;)React.render(&lt;Unkekong /&gt;,document.body); Checkbox和Radio的潜在问题 注意，在试图改变正常处理Checkbox和Radio input时，React用一个click事件来代替change事件。大多数情况下，这种行为与预期相同，除了调用preventDefault时。preventDefault从视觉上阻止浏览器更新input，即使checked被触发。它可以在移除调用preventDefault与用setTimeout来切换checked中起作用。Why use Controlled Components组件可控的优点： 符合React的数据流，单向数据流，从state流向render输出的结果。 数据存贮在state中，便于使用。 便于对数据进行处理 表单元素 &lt;label htmlFor=&quot;name&quot;&gt;Name&lt;/label&gt; 要注意for是js关键字，要写成htmlFor。具体JSX语法在之间笔记中有介绍，传送门：React.js学习笔记之JSX解读。现在多数提示用input的placeholder属性替代。 &lt;input type=&quot;&quot; onChange={this.handleChange}/&gt; &lt;textarea onChange={this.handleChange}/&gt; &lt;select onChange={this.handleChange}&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt; 实例这是一个demo传送门1234567891011121314151617181920212223242526272829303132333435363738394041424344var MyForm = React.createClass(&#123;getInitialState:function()&#123; return &#123; username:&apos;&apos;, gender:&apos;man&apos;, checked:true &#125;;&#125;,handleUsernameChange:function(e)&#123; this.setState(&#123; username:e.target.value &#125;);&#125;,handlerGenderChange:function(e)&#123; this.setState(&#123; gender:e.target.value &#125;);&#125;,handleCheckedChange:function(e)&#123; this.setState(&#123; checked:e.target.checked &#125;);&#125;,submitHandler:function (e) &#123; e.preventDefault(); console.log(this.state);&#125;,render:function () &#123; return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt; &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt; &lt;input type=&quot;text&quot; onChange=&#123;this.handleUsernameChange&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt; &lt;br/&gt; &lt;select onChange=&#123;this.handlerGenderChange&#125; value=&#123;this.state.gender&#125;&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleCheckedChange&#125; id=&quot;checkbox&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt;&#125;&#125;);ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;)); 事件处理函数1onChange=&#123;this.handleChange&#125; 若有多个元素要运用事件处理函数，常规的方法是编写多个onChange事件。这么写的话会导致代码维护比较困难并且也非常冗余。更好的做法是把事件处理函数编写为一个。可以采用bind复用和name复用这两种方法。 bind复用1234handleChange:function(name,event)&#123; ......&#125;onChagne=&#123;this.handleChange.bind(this,&apos;input&apos;)&#125; 书写简单，但需要对bind()机制熟悉，性能相对要好。 实例这是一个demo传送门12345678910111213141516171819202122232425262728293031323334var MyForm = React.createClass(&#123; getInitialState:function()&#123; return &#123; username:&apos;&apos;, gender:&apos;man&apos;, checked:true &#125;; &#125;, handleChange:function(name,event)&#123; var newState=&#123;&#125;; newState[name]=name==&quot;checked&quot;?event.target.checked:event.target.value; this.setState(newState); &#125;, submitHandler:function (e) &#123; e.preventDefault(); console.log(this.state); &#125;, render:function () &#123; return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt; &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt; &lt;input type=&quot;text&quot; onChange=&#123;this.handleChange.bind(this,&quot;username&quot;)&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt; &lt;br/&gt; &lt;select onChange=&#123;this.handleChange.bind(this,&quot;gender&quot;)&#125; value=&#123;this.state.gender&#125;&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange.bind(this,&quot;checked&quot;)&#125; id=&quot;checkbox&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &#125;&#125;);ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;)); name复用1234handleChange:function(event)&#123; var name = event.target.name&#125;onChange=&#123;this.handleChange&#125; 相比Bind写法会少一些参数，在函数中需要读取表单的name值，需要添加name属性。 实例12345678910111213141516171819202122232425262728293031323334var MyForm = React.createClass(&#123; getInitialState:function()&#123; return &#123; username:&apos;&apos;, gender:&apos;man&apos;, checked:true &#125;; &#125;, handleChange:function(event)&#123; var newState=&#123;&#125;; newState[event.target.name]=event.target.name==&quot;checked&quot;?event.target.checked:event.target.value; this.setState(newState); &#125;, submitHandler:function (e) &#123; e.preventDefault(); console.log(this.state); &#125;, render:function () &#123; return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt; &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt; &lt;br/&gt; &lt;select name=&quot;gender&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.gender&#125;&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange&#125; name=&quot;checked&quot; id=&quot;checkbox&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &#125;&#125;);ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;)); 自定义表单组件自定义表单组件能让我们更好的使用组件，让我们更好的开发网页。 why 自定义表单组件？自定义表单组件的原因： 内因：表单本身具备特殊性：样式统一、信息内聚、行为固定 外因：本质上是组件的嵌套，组织和管理组件的一种方式","categories":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/tags/react/"}]},{"title":"ES6笔记之 let 和 const","slug":"ES6-to-let-and-const","date":"2016-10-17T13:51:50.000Z","updated":"2019-08-15T15:03:33.955Z","comments":true,"path":"2016/10/17/ES6-to-let-and-const/","link":"","permalink":"http://lengziyu.cn/2016/10/17/ES6-to-let-and-const/","excerpt":"ES6新增了 let 和 const 命令，用来声明变量。它的用法类似于var，却有所区别。","text":"ES6新增了 let 和 const 命令，用来声明变量。它的用法类似于var，却有所区别。 letlet声明的变量只在其所在的代码块内有效。 1234&#123; let a = 1;&#125;console.log(a) //ReferenceError:a is not defined let声明变量不存在变量提升let不像var那样会发生“变量提升”现象，所以，变量一定要在声明后使用，不然就会报错。 12console.log(a) //ReferenceError:a is not definedlet a = 1; 暂时性死区只要块级作用域内存在let关键字，它所声明的变量就绑定这个区域，不再受外部影响。 12345var tmp = 20;if(true)&#123; tmp = &apos;abc&apos;; //ReferenceError:tmp is not defined let tmp;&#125; 上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定了这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。在语法上称为“暂时性死区(temporal dead zone,TDZ)”有时候，会不经间遇到比较隐蔽的“死区”，不太容易被发现。1234function bar(x=y,y=2)&#123; return [x,y];&#125;bar() //报错上面的代码中是因为参数x的默认值等于另一个参数y，而此时y还没有声明，属于死区。不允许重复声明let不允许在相同的作用域内声明同一个变量。1234567891011function bar()&#123; let a = 10; var a = 20;&#125;//报错function bat()&#123; let a = 10; let a = 20;&#125;//报错因此，所以也不能在函数内重复声明参数：1234567891011function bar(args)&#123; let args = 10; &#125;bar() //报错function bar(args)&#123; &#123; let args = 20; &#125;&#125;bar() //不报错块级作用域使用let和const可以实现块级作用域：1. 外层代码块不受内层代码块的影响。2. 外层作用域无法读取内层作用域的变量。3. 内层作用域可以定义外层作用域的同名变量。块级作用域的实现，使得广泛使用的自执行匿名函数(IIFE)变得不再必要了。12345678910//自执行模式(function()&#123; var a = 10;&#125;)()//块级作用域写法function()&#123; let a = 10;&#125;函数本身的作用域也在其所在的块级作用域之内。 constconst用来声明常量。一旦声明，其值就不能再改变。12const PI = 3.1415;const PI = 3 //TypeErrorL &quot;PI&quot; is read-only const声明的变量不得改变值，意味着 const 一旦声明常量就必须立即初始化，不能留到后面赋值。const与let关键字一样，只在声明所在的块级作用域内有效；const关键字声明的常量也不提升，同样存在暂时性死区，只能在声明后使用。对于复合型数据类型，常量名不指向数据，而是指向数据所在的地址。const关键字只是保证常量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须注意该点。","categories":[{"name":"es6","slug":"es6","permalink":"http://lengziyu.cn/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://lengziyu.cn/tags/es6/"}]},{"title":"Yarn - Javascript 新一代套件管理","slug":"yarn-a-new-javascript-pkg","date":"2016-10-14T15:25:51.000Z","updated":"2019-08-15T15:03:33.982Z","comments":true,"path":"2016/10/14/yarn-a-new-javascript-pkg/","link":"","permalink":"http://lengziyu.cn/2016/10/14/yarn-a-new-javascript-pkg/","excerpt":"日前，Facebook 发布了全新的 JS 套件管理工具 Yarn，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。","text":"日前，Facebook 发布了全新的 JS 套件管理工具 Yarn，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。 Yarn 提供一个更快更稳定的套件管理方案 透过 yarn.lock ，锁住套件版本，因此可以确保安装之套件在每台机器上都能保持一致。 安装过的套件，都会加入到 global cache 中，下次有砍掉要重装，或是不同资料夹要装，都可以在无网络情況底下安裝。 非常快，平行化处理每个 operation，全新的 resolving 演算法。 特性功能除了让安装过程更快更可靠，Yarn 还有额外的特性来更好地简化依赖管理的工作流。 兼容 npm 和 bower 工作流，并且支持混合注册。 能够限制已安装模块的证书以及输出证书信息。 暴露一个稳定公开的JS API，通过构建工具提供抽象的日志记录。 可读、最小化、良好的命令行输出。 使用12345678910111213141516171819202122232425262728293031323334// 以前装过 npm 再安装 yarnnpm install -g yarn// 直接安装 (mac为例，其余官网有介绍)curl -o- -L https://yarnpkg.com/install.sh | bash// 一般安装 (等同 npm install)yarn// 安装特定套件 (等同 npm install --save)yarn add react yarn add react@15.3.2// 更新特定套件 (等同 npm upgrade)yarn upgrade react// 移除特定套件 (等同 npm uninstall)yarn remove react// 新增 package.jsonyarn init// 新增全域套件yarn global add// 跑 scriptyarn run// 其他常用选项--offline (离线模式，只拉 cache)--flat (将套件扁平化，一個资料夹只会有一個套件)--dev (加入到 devDependencies)--peer (加入到 peerDependencies)--optional (加入到 optionalDependencies) CheatNPMYARN说明npm inityarn init初始化某个项目npm install/linkyarn install/link默认的安装依赖操作npm install taco —saveyarn add taco安装某个依赖，并且默认保存到package.npm uninstall taco —saveyarn remove taco移除某个依赖项目npm install taco —save-devyarn add taco —dev安装某个开发时依赖项目npm update taco —saveyarn upgrade taco更新某个依赖项目npm install taco –globalyarn global add taco安装某个全局依赖项目npm publish/login/logoutyarn publish/login/logout发布/登录/登出，一系列NPM Registry操作npm run/testyarn run/test运行某个命令 参考 Yarn: A new package manager for JavaScript Yarn: a new program for installing JavaScript dependencies npm-vs-yarn-cheat-sheet","categories":[{"name":"yarn","slug":"yarn","permalink":"http://lengziyu.cn/categories/yarn/"}],"tags":[{"name":"yarn","slug":"yarn","permalink":"http://lengziyu.cn/tags/yarn/"}]},{"title":"Redux 简明教程（转）","slug":"Redux-学习笔记","date":"2016-10-13T12:26:49.000Z","updated":"2019-08-15T15:03:33.980Z","comments":true,"path":"2016/10/13/Redux-学习笔记/","link":"","permalink":"http://lengziyu.cn/2016/10/13/Redux-学习笔记/","excerpt":"Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。","text":"Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。 Redux 除了和 React 一起用外，还支持其它界面库。它体小精悍（只有2kB）且没有任何依赖。 启示Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性。 Store首先要区分 store 和 statestate 是应用的状态，一般本质上是一个普通对象例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）：12345/** 应用初始 state，本代码块记为 code-1 **/&#123; counter: 0, todos: []&#125; store 是应用状态 state 的管理者，包含下列四个函数： getState() # 获取整个 state dispatch(action) # ※ 触发 state 改变的【唯一途径】※ subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用 二者的关系是：state = store.getState()Redux 规定，一个应用只应有一个单一的 store，其管理着唯一的应用状态 stateRedux 还规定，不能直接修改应用的状态 state，也就是说，下面的行为是不允许的： 12var state = store.getState()state.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state 若要改变 state，必须 dispatch 一个 action，这是修改应用状态的不二法门 现在您只需要记住 action 只是一个包含 type 属性的普通对象即可例如 { type: ‘INCREMENT’ }上面提到，state 是通过 store.getState() 获取，那么 store 又是怎么来的呢？想生成一个 store，我们需要调用 Redux 的 createStore：123import &#123; createStore &#125; from &apos;redux&apos;...const store = createStore(reducer, initialState) // store 是靠传入 reducer 生成的哦！现在您只需要记住 reducer 是一个 函数，负责更新并返回一个新的 state而 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染） Action上面提到，action（动作）实质上是包含 type 属性的普通对象，这个 type 是我们实现用户行为追踪的关键例如，增加一个待办事项 的 action 可能是像下面一样：123456789/** 本代码块记为 code-2 **/&#123; type: &apos;ADD_TODO&apos;, payload: &#123; id: 1, content: &apos;待办事项1&apos;, completed: false &#125;&#125; 当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了也就是说，下面这些 action 都是合法的：12345678910111213141516/** 如下都是合法的，但就是不够规范 **/&#123; type: &apos;ADD_TODO&apos;, id: 1, content: &apos;待办事项1&apos;, completed: false&#125;&#123; type: &apos;ADD_TODO&apos;, abcdefg: &#123; id: 1, content: &apos;待办事项1&apos;, completed: false &#125;&#125; 虽说没有约束，但最好还是遵循规范如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）：123456789/** 本代码块记为 code-3 **/&#123; counter: 0, todos: [&#123; id: 1, content: &apos;待办事项1&apos;, completed: false &#125;]&#125; 刨根问底，action 是谁生成的呢？ Action CreatorAction Creator 可以是同步的，也可以是异步的顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）例如下面就是一个 “新增一个待办事项” 的 Action Creator：123456789101112/** 本代码块记为 code-4 **/var id = 1function addTodo(content) &#123; return &#123; type: &apos;ADD_TODO&apos;, payload: &#123; id: id++, content: content, // 待办事项内容 completed: false // 是否完成的标识 &#125; &#125;&#125; 将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）：1234567891011&lt;--! 本代码块记为 code-5 --&gt;&lt;input type=&quot;text&quot; id=&quot;todoInput&quot; /&gt;&lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt;&lt;script&gt;$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123; var content = $(&apos;#todoInput&apos;).val() // 获取输入框的值 var action = addTodo(content) // 执行 Action Creator 获得 action store.dispatch(action) // 改变 state 的不二法门：dispatch 一个 action！！！&#125;)&lt;/script&gt; 在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了：12345678910111213/** 本代码块记为 code-6 **/&#123; counter: 0, todos: [&#123; id: 1, content: &apos;待办事项1&apos;, completed: false &#125;, &#123; id: 2, content: &apos;待办事项2&apos;, completed: false &#125;]&#125; 通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action)刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，Redux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？又是谁负责“写入”的呢？悬念即将揭晓… ReducerReducer 必须是同步的纯函数用户每次 dispatch(action) 后，都会触发 reducer 的执行reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState最后会用 reducer 的返回值 nextState 完全替换掉原来的 state 注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改Redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ … 等返回副本的函数在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)：12345678910111213141516171819202122/** 本代码块记为 code-7 **/var initState = &#123; counter: 0, todos: []&#125;function reducer(state, action) &#123; // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※ if (!state) state = initState switch (action.type) &#123; case &apos;ADD_TODO&apos;: var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆 nextState.todos.push(action.payload) return nextState default: // 由于 nextState 会把原 state 整个替换掉 // 若无修改，必须返回原 state（否则就是 undefined） return state &#125;&#125; 通俗点讲，就是 reducer 返回啥，state 就被替换成啥 总结 store 由 Redux 的 createStore(reducer) 生成 state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象 action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生 改变 state 必须 dispatch 一个 action reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数 reducer 必须返回值，否则 nextState 即为 undefined 实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单） Action Creator =&gt; action =&gt; store.dispatch(action) =&gt; reducer(state, action) =&gt; 原 state state = nextState 原文地址：Redux 简明教程","categories":[{"name":"redux","slug":"redux","permalink":"http://lengziyu.cn/categories/redux/"}],"tags":[{"name":"redux","slug":"redux","permalink":"http://lengziyu.cn/tags/redux/"}]},{"title":"React JSX语法","slug":"react-jsx-grammar","date":"2016-10-12T12:00:40.000Z","updated":"2019-08-15T15:03:33.960Z","comments":true,"path":"2016/10/12/react-jsx-grammar/","link":"","permalink":"http://lengziyu.cn/2016/10/12/react-jsx-grammar/","excerpt":"JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。","text":"JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。1JSX=JavaScriptXML JSX可以理解为在JS中编写与XML类似的语言（与XML有本质上的不同），它的目的不是要在浏览器或者引擎中实现，也不是把其加入ECMAScript标准。它的目的是通过各种编译器将这些标记编译成标准的JS语言。 JSX是： 基于ECMAScript的一种新特性（并不是一种新语言） 一种定义带属性树结构（DOM结构）的语法 JSX不是： XML或者HTML 一种限制 （你不需要为了 React 使用 JSX，可以直接使用纯粹的 JS。但更建议使用 JSX , 因为它能定义简洁且我们熟知的包含属性的树状结构语法。） JSX的特点： 类XML语法容易接受，结构清晰 增强JS语义 抽象程度高，屏蔽DOM操作，跨平台 代码模块化 JSX语法JSX本身就和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式，例如：1234567var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name=\"lengziyu\" /&gt;, mountNode); 一、元素名自定义出的组件标签名，React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。render渲染时，会把大写的组件名定义为自定义组件，把小写的组件名定义为HTML自带的标签名进行渲染。1var HelloMessage = JSX的标签与函数名都是使用的驼峰命名。 htmlFor和classNamefor和class为js的保留字，在书写for与class时需要修改为htmlFor何className，注意都是使用的驼峰命名。 自闭合标签在 JSX 中， 是合法的，而 就不合法。 所有的标签都必须闭合，可以是自闭和的形式，也可以是常规的闭合。 注意：所有 React component 都可以采用自闭和的形式，包括div等 二、子节点组件与组件之间就像标签与标签之间可以有嵌套关系，与HTML不同的是可以在子节点中使用求值表达式。目前， 一个 component 的 render，只能返回一个节点。如果你需要返回一堆 div ， 那你必须将你的组件用 一个div 或 span 或任何其他的组件包裹。 切记，JSX 会被编译成常规的 JS； 因此返回两个函数也就没什么意义了，同样地，千万不要在三元操作符中放入超过一个子节点。如果往原生 HTML 元素里传入 HTML 规范里不存在的属性，React 不会显示它们。如果需要使用自定义属性，要加 data- 前缀。 三、求值表达式要使用 JavaScript 表达式作为属性值，只需把这个表达式用一对大括号 ( { } ) 包起来，不要用引号 ( “ “ )。求值表达式本身与JSX没有多大关系，是JS中的特性。它是会返回值的表达式，与语句有本质上的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。 条件判断的写法你没法在JSX中使用 if-else 语句，因为 JSX 只是函数调用和对象创建的语法糖。在 { } 中使用，是不合法的JS代码，不过可以采用三元操作表达式。123456var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name ？ this.props.name : &quot;World&quot;&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body); 可以使用比较运算符“ || ”来书写，如果左边的值为真，则直接返回左边的值，否则返回右边的值，与if的效果相同。 123456var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name || &quot;World&quot;&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body); 也可以使用变量来书写：12345678910111213var HelloMessage = React.createClass(&#123; getName : function() &#123; if (this.props.name) return this.props.name else return &quot;world&quot; &#125; render: function() &#123; var name = this.getName(); return &lt;div&gt;Hello &#123;name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;, document.body); 其中可以把变量去掉，直接在 { } 中调用函数：123render: function() &#123; return &lt;div&gt;Hello &#123;this.getName()&#125;&lt;/div&gt;;&#125; 四、注释JSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 { } 包围要注释的部分。1234567891011var content = ( &lt;Nav&gt; &#123;/* 一般注释, 用 &#123;&#125; 包围 */&#125; &lt;Person /* 多 行 注释 */ name=&#123;window.isLoggedIn ? window.name : &apos;&apos;&#125; // 行尾注释 /&gt; &lt;/Nav&gt;); 五、样式尽管在大部分场景下我们应该将样式写在独立的CSS文件中，但是有时对于某个特定组件而言，其样式相当简单而且独立，那么也可以将其直接定义在JSX中。在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象，需要注意的是属性名同样需要驼峰命名法。例如：1&lt;div style=&#123;&#123;color: &apos;#ff0000&apos;, fontSize: &apos;14px&apos;&#125;&#125;&gt;Hello World.&lt;/div&gt; 12345678910var style = &#123; color : &quot;red&quot;, border : &quot;1px solid #000&quot;&#125;var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;div style=&#123;style&#125;&gt;&lt;HelloMessage name=&quot;xiaowang&quot; /&gt;&lt;/div&gt;, document.body); 小结本文主要介绍了声明组件的语法JSX。看似有点神秘的JSX背后的原理非常简单：只是一种用于创建组件的XML语法。让代码直观易懂是软件项目质量的重要保证之一，这意味着代码更加容易理解和维护，出现Bug时更容易调试和修复。因此React这种采用JSX语法，以声明式的方法来直观的定义用户界面的方式，正是其最大的价值。","categories":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/tags/react/"}]},{"title":"React 数据流 Props 和 State [组件沟通]","slug":"react-props-and-state-plus","date":"2016-10-11T10:50:20.000Z","updated":"2019-08-15T15:03:33.961Z","comments":true,"path":"2016/10/11/react-props-and-state-plus/","link":"","permalink":"http://lengziyu.cn/2016/10/11/react-props-and-state-plus/","excerpt":"组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。","text":"组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。 可以分为以下 3 种： 【父组件】向【子组件】传值； 【子组件】向【父组件】传值； 没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间传值） 【父组件】向【子组件】传值父组件更新子组件状态，通过传递props，就可以了。例子如下：1234567891011121314151617181920212223242526// 父组件var MyContainer = React.createClass(&#123; getInitialState: function () &#123; return &#123; checked: true &#125;; &#125;, render: function() &#123; return ( &lt;ToggleButton text=\"Toggle me\" checked=&#123;this.state.checked&#125; /&gt; ); &#125;&#125;);// 子组件var ToggleButton = React.createClass(&#123; render: function () &#123; // 从【父组件】获取的值 var checked = this.props.checked, text = this.props.text; return ( &lt;label&gt;&#123;text&#125;: &lt;input type=\"checkbox\" checked=&#123;checked&#125; /&gt;&lt;/label&gt; ); &#125;&#125;); 进一步讨论 如果组件嵌套层次太深，那么从外到内组件的交流成本就变得很高，通过 props 传递值的优势就不那么明显了。（PS：所以我建议尽可能的减少组件的层次，就像写 HTML 一样，简单清晰的结构更惹人爱） 1234567891011121314151617181920212223242526// 父组件var MyContainer = React.createClass(&#123; render: function() &#123; return ( &lt;Intermediate text=\"where is my son?\" /&gt; ); &#125;&#125;);// 子组件1：中间嵌套的组件var Intermediate = React.createClass(&#123; render: function () &#123; return ( &lt;Child text=&#123;this.props.text&#125; /&gt; ); &#125;&#125;);// 子组件2：子组件1的子组件var Child = React.createClass(&#123; render: function () &#123; return ( &lt;span&gt;&#123;this.props.text&#125;&lt;/span&gt; ); &#125;&#125;); 【子组件】向【父组件】传值接下来，我们介绍【子组件】控制自己的 state 然后告诉【父组件】的点击状态，然后在【父组件】中展示出来。因此，我们添加一个 change 事件来做交互。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 父组件var MyContainer = React.createClass(&#123; getInitialState: function () &#123; return &#123; checked: false &#125;; &#125;, onChildChanged: function (newState) &#123; this.setState(&#123; checked: newState &#125;); &#125;, render: function() &#123; var isChecked = this.state.checked ? 'yes' : 'no'; return ( &lt;div&gt; &lt;div&gt;Are you checked: &#123;isChecked&#125;&lt;/div&gt; &lt;ToggleButton text=\"Toggle me\" initialChecked=&#123;this.state.checked&#125; callbackParent=&#123;this.onChildChanged&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);// 子组件var ToggleButton = React.createClass(&#123; getInitialState: function () &#123; return &#123; checked: this.props.initialChecked &#125;; &#125;, onTextChange: function () &#123; var newState = !this.state.checked; this.setState(&#123; checked: newState &#125;); // 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值 this.props.callbackParent(newState); &#125;, render: function () &#123; // 从【父组件】获取的值 var text = this.props.text; // 组件自身的状态数据 var checked = this.state.checked; return ( &lt;label&gt;&#123;text&#125;: &lt;input type=\"checkbox\" checked=&#123;checked&#125; onChange=&#123;this.onTextChange&#125; /&gt;&lt;/label&gt; ); &#125;&#125;); 这样做其实是依赖 props 来传递事件的引用，并通过回调的方式来实现的，这样实现不是特别好，但是在没有任何工具的情况下也是一种简单的实现方式 这里会出现一个我们在之前讨论的问题，就是组件有多层嵌套的情况下，你必须要一次传入回调函数给 props 来实现子组件向父组件传值或者操作。 兄弟组件之间传值当两个组件有相同的父组件时，就称为兄弟组件（堂兄也算的）。按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的props。 方式一通过props传递父组件回调函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Brother1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.props.refresh&#125;&gt; 更新兄弟组件 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class Brother2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.text || \"兄弟组件未更新\"&#125; &lt;/div&gt; ) &#125;&#125;class Parent extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; refresh()&#123; return (e)=&gt;&#123; this.setState(&#123; text: \"兄弟组件沟通成功\", &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;兄弟组件沟通&lt;/h2&gt; &lt;Brother1 refresh=&#123;this.refresh()&#125;/&gt; &lt;Brother2 text=&#123;this.state.text&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 方式二但是如果组件层次太深，上面的兄弟组件沟通方式就效率低了（不建议组件层次太深）。React提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Brother1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.context.refresh&#125;&gt; 更新兄弟组件 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Brother1.contextTypes = &#123; refresh: React.PropTypes.any&#125;class Brother2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.context.text || \"兄弟组件未更新\"&#125; &lt;/div&gt; ) &#125;&#125;Brother2.contextTypes = &#123; text: React.PropTypes.any&#125;class Parent extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; getChildContext()&#123; return &#123; refresh: this.refresh(), text: this.state.text, &#125; &#125; refresh()&#123; return (e)=&gt;&#123; this.setState(&#123; text: \"兄弟组件沟通成功\", &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;兄弟组件沟通&lt;/h2&gt; &lt;Brother1 /&gt; &lt;Brother2 text=&#123;this.state.text&#125;/&gt; &lt;/div&gt; ) &#125;&#125;Parent.childContextTypes = &#123; refresh: React.PropTypes.any, text: React.PropTypes.any,&#125; 全局事件官网中提到可以使用全局事件来进行组件间的通信，官网推荐Flux（Facebook官方出的），还有Relay、Redux、trandux等第三方类库。这些框架思想都一致，都是统一管理组件state变化情况，达到数据可控目的。 总结简单的组件交流我们可以使用上面非全局事件的简单方式，但是当项目复杂，组件间层次越来越深，上面的交流方式就不太合适（当然还是要用到的，简单的交流）。强烈建议使用Flux、Relay、Redux、trandux等类库其中一种，这些类库不只适合React，像Angular等都可以使用。 参考 ReactJS组件间沟通的一些方法 React 数据流管理架构之 Redux 介绍","categories":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/tags/react/"}]},{"title":"React 数据流 Props 和 State [基础介绍]","slug":"react-props-and-state","date":"2016-10-10T11:17:09.000Z","updated":"2019-08-15T15:03:33.961Z","comments":true,"path":"2016/10/10/react-props-and-state/","link":"","permalink":"http://lengziyu.cn/2016/10/10/react-props-and-state/","excerpt":"使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。","text":"使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。 数据流React是单向数据流，从父节点传递到子节点（通过props）。如果顶层的某个props改变了，React会重渲染所有的子节点（未做性能优化）。严格意义上React只提供，也强烈建议使用这种数据交流方式。 Propsprops是property的缩写，可以理解为HTML标签的attribute。请把props当做只读的（不可以使用this.props直接修改props），props是用于整个组件树中传递数据和配置。在当前组件访问props，使用this.props。123456789101112var HelloWorld = React.createClass(&#123; render: function () &#123; return ( &lt;div data-title=&#123;this.props.title&#125;&gt;&#123;this.props.content&#125;&lt;/div&gt; ) &#125;&#125;);React.render( &lt;HelloWorld title=\"this is title\" content=\"this is content\"/&gt;, document.body); state每个组件都有属于自己的state，state和props的区别在于前者之只存在于组件内部，只能从当前组件调用this.setState修改state值（不可以直接修改this.state）。一般我们更新子组件都是通过改变state值，更新新子组件的props值从而达到更新。 那如何设置默认state?123456789101112131415//React提供的crateClass创建方式var Component = React.createClass(&#123; getInitialState()&#123; return &#123; //这里设置初始state值 &#125; &#125;&#125;)//ES6 &amp;&amp; ES7class Component &#123; constructor()&#123; this.state = &#123;&#125;//在ES6中的构造函数中初始化，可以之直接赋值，在其他方法中，只能使用this.setState &#125; ...&#125; 再看一个例子，点击按钮，切换按钮的颜色：123456789101112131415161718var ColorButton = React.createClass(&#123; getInitialState: function () &#123; return &#123;bColor: &apos;green&apos;&#125;; &#125;, render: function () &#123; return ( &lt;button onClick=&#123;this.handleClick&#125; style=&#123;&#123;backgroundColor: this.state.bColor&#125;&#125;&gt;click&lt;/button&gt; ) &#125;, handleClick: function (event) &#123; this.setState(&#123;bColor: this.state.bColor === &apos;green&apos; ? &apos;red&apos; : &apos;green&apos;&#125;); &#125;&#125;);React.render( &lt;ColorButton /&gt;, document.body); handleClick是用来处理我们点击事件的。 state工作原理通过调用setState(data, callback)方法，改变状态，就会触发React更新UI。大部分情况下，我们不需要提供callback函数。React会自动的帮我们更新UI。 什么样的组件该有state大部分的组件应该从props属性中获取数据并渲染。但有的时候组件得相应用户输入，同服务器交互，这些情况下会用到state。React的官方说法是：尽可能的保持你的组件无状态化。为了实现这个目标，得保持你的状态同业务逻辑分离，并减少冗余信息，尽可能保持组件的单一职责。 React官方推荐的一种模式就是：构建几个无状态的组件用来渲染数据，在这些之上构建一个有状态的组件同用户和服务交互，数据通过props传递给无状态的组件。我的理解大概就是这样：12345678910111213141516171819202122232425262728293031323334353637var RenderComponent = React.createClass(&#123; render: function () &#123; return ( &lt;ul&gt; &#123; this.props['data-list'].map(function (item) &#123; return (&lt;li&gt;&#123;item&#125;&lt;/li&gt;) &#125;) &#125; &lt;/ul&gt; ) &#125;&#125;);var StateComponent = React.createClass(&#123; getInitialState: function () &#123; return &#123;list: ['xxx', 'yyy']&#125;; &#125;, render: function () &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/button&gt; &lt;RenderComponent data-list=&#123;this.state.list&#125;/&gt; &lt;/div&gt; ) &#125;, handleClick: function () &#123; this.setState(&#123;list: [1, 2, 3]&#125;); &#125;&#125;);React.render( &lt;StateComponent /&gt;, document.body); UI交互会导致改变的数据。state不应包含什么样的数据：1.计算过的数据；2.组件；3.从props复制的数据。state应保含最原始的数据，比如说时间，格式化应该交给展现层去做。组件应在render方法里控制。 props和state使用方式尽可能使用props当做数据源，state用来存放状态值（简单的数据），如复选框、下拉菜单等。","categories":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/tags/react/"}]},{"title":"React 学习笔记","slug":"react-early-know","date":"2016-10-09T12:17:35.000Z","updated":"2019-08-15T15:03:33.959Z","comments":true,"path":"2016/10/09/react-early-know/","link":"","permalink":"http://lengziyu.cn/2016/10/09/react-early-know/","excerpt":"React是Facebook和Instagram用来创建用户界面的JavaScript库。很多人将React认为是MVC中的V。 React的创建是为了解决一个问题：如何构建一个数据交互频繁的大型应用程序？为了实现这个目标，React运用了两个思想：","text":"React是Facebook和Instagram用来创建用户界面的JavaScript库。很多人将React认为是MVC中的V。 React的创建是为了解决一个问题：如何构建一个数据交互频繁的大型应用程序？为了实现这个目标，React运用了两个思想： 实时更新数据React使得展现数据变得简单，并且当数据改变时，React能自动保持UI的更新。 构建通用组件React旨在构建通用组件。试试想，写React代码就是在构建组件。因为组件式封装的，所以组件使得代码的复用性、测试性和关注分离变得简单。 基本概念React.jsReact.js 是 React 的核心库，在应用中必须先加载核心库。 ReactDOM.jsReactDOM.js 是 React 的 DOM 渲染器，React 将核心库和渲染器分离开了，为了在 web 页面中显示开发的组件，需要调用 ReactDOM.render 方法， 第一个参数是 React 组件，第二个参数为 HTMLElement。 JSXJSX 是 React 自定义的语法，最终 JSX 会转化为 JS 运行于页面当中。 组件组件是 React 中的核心概念，页面当中的所有元素都是通过 React 组件来表达， 我们将要写的 React 代码绝大部分都是在做 React 组件的开发。 VIRTUAL DOMReact 抽象出来的虚拟 DOM 树，虚拟树是 React 高性能的关键。 单向数据流：one-way reactive data flowReact 应用的核心设计模式，数据流向自顶向下 Hello World创建一个简单的 Hello World，新建 index.html：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;React&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"example\"&gt;&lt;/div&gt;&lt;script src=\"js/react.js\"&gt;&lt;/script&gt;&lt;script src=\"js/JSXTransformer.js\"&gt;&lt;/script&gt;&lt;script src=\"js/app.js\" type=\"text/jsx\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; React独创了一种JS、CSS和HTML混写的JSX格式，可以通过在页面中引入JSXTransformer这个文件进行客户端的编译，不过还是推荐在服务端编译。app.js :12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);React.render( &lt;HelloMessage name=\"John\" /&gt;, document.getElementById('container')); React.createClass用来创建一个组件类，编写React代码主要就是构建通用的组件。 React.render将React的模板转化为HTML，并插入到相应的DOM结构中。要注意的是，React的渲染函数并不是简单地把HTML元素复制到页面上，而是维护了一张Virtual Dom映射表。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://lengziyu.cn/tags/react/"}]},{"title":"webpack基本使用配置[基础篇]","slug":"webpack-use-expo","date":"2016-10-08T12:28:47.000Z","updated":"2019-08-15T15:03:33.981Z","comments":true,"path":"2016/10/08/webpack-use-expo/","link":"","permalink":"http://lengziyu.cn/2016/10/08/webpack-use-expo/","excerpt":"webpack是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。还可以结合gulp使用，不冲突。","text":"webpack是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。还可以结合gulp使用，不冲突。 webpack优势 模块来源广泛，支持包括npm/bower等等的各种主流模块安装／依赖解决方案； 模块化规范支持全面，AMD/CommonJS一应具全； 插件机制完善，实现本身实现同样模块化，容易扩展； Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 安装首先要安装 Node.js， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。用 npm 全局安装 Webpack：1$ npm install webpack -g 初始化配置文件 package.json ：1$ npm init 到项目目录安装，将 webpack 添加到 package.json ：1$ npm install webpack --save-dev webpack常用命令 webpack 最基本的启动webpack命令 webpack -w 提供watch方法，实时进行打包更新 webpack -p 对打包后的文件进行压缩 webpack -d 提供SourceMaps，方便调试 webpack –colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤 webpack –profile 输出性能数据，可以看到每一步的耗时 webpack –display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块 前面的四个命令比较基础，使用频率会比较大，后面的命令主要是用来定位打包时间较长的原因，方便改进配置文件，提高打包效率。 例子首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：123456&lt;!-- index.html --&gt;&lt;html&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12// entry.jsdocument.write(&apos;It works.&apos;) 然后编译 entry.js 并打包到 bundle.js：1$ webpack entry.js bundle.js 打包过程会显示日志：123456Hash: e964f90ec65eb2c29bb9Version: webpack 1.12.2Time: 54ms Asset Size Chunks Chunk Namesbundle.js 1.42 kB 0 [emitted] main [0] ./entry.js 27 bytes &#123;0&#125; [built] 用浏览器打开 index.html 将会看到 It works.","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://lengziyu.cn/tags/webpack/"}]}]}
=======
{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-07-17T03:04:31.951Z","updated":"2019-07-17T03:04:31.951Z","comments":true,"path":"2019/07/17/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
>>>>>>> 0b7576d4c4a567b7ed13cbcd5621fdecbdf9f0dd
