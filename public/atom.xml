<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷子欲-喜欢折腾的前端er</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://lengziyu.cn/"/>
  <updated>2021-04-13T06:41:30.000Z</updated>
  <id>http://lengziyu.cn/</id>
  
  <author>
    <name>lengziyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习TypeScript第一课</title>
    <link href="http://lengziyu.cn/2020/09/08/learn-typescript-01/"/>
    <id>http://lengziyu.cn/2020/09/08/learn-typescript-01/</id>
    <published>2020-09-08T13:04:54.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TypeScript是JavaScript的一个超集，支持ECMAScript6标准，设计目标是开发大型应用。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以通过开发工具安装插件或用npm方式安装，这里介绍npm的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure></p><p><strong>构建一个TypeScript文件</strong><br>新建一个<code>greeter.ts</code>文件，写入以下内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function greeter(person: string) &#123;</span><br><span class="line">    return &quot;Hello, &quot; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &quot;Jane User&quot;;</span><br><span class="line"></span><br><span class="line">document.body.innerHTML = greeter(user);</span><br></pre></td></tr></table></figure></p><p><strong>编译代码</strong><br>在命令行执行如下，运行TypeScript编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc greeter.ts</span><br></pre></td></tr></table></figure></p><p>输出结果为一个greeter.js文件，它包含了和输入文件中相同的JavsScript代码。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><table><thead><tr><th style="text-align:left">数据类型</th><th>关键字</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td style="text-align:left">任意类型</td><td>any</td><td>声明为 any 的变量可以赋予任意类型的值。</td><td><code>let x: any = 1; x = false;</code></td></tr><tr><td style="text-align:left">数字类型</td><td>number</td><td>双精度 64 位浮点值。它可以用来表示整数和分数。</td><td><code>let decLiteral: number = 6;</code></td></tr><tr><td style="text-align:left">字符串类型</td><td>string</td><td>一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。</td><td><code>let name: string = &quot;Runoob&quot;;</code></td></tr><tr><td style="text-align:left">布尔类型</td><td>boolean</td><td>表示逻辑值<code>true</code>和<code>false</code>。</td><td><code>let flag: boolean = true;</code></td></tr><tr><td style="text-align:left">数组类型</td><td>无</td><td>声明变量为数组。</td><td><code>let arr: number[] = [1, 2];</code> </td></tr><tr><td style="text-align:left">元组</td><td>无</td><td>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。</td><td><code>let x: [string, number]; x = [&#39;Runoob&#39;, 1];</code></td></tr><tr><td style="text-align:left">枚举</td><td>enum</td><td>枚举类型用于定义数值集合。</td><td><code>enum Color {Red, Green, Blue};let c: Color = Color.Blue;</code></td></tr><tr><td style="text-align:left">void</td><td>void</td><td>用于标识方法返回值的类型，表示该方法没有返回值。</td><td><code>function hello(): void { alert(&quot;Hello Runoob&quot;) }</code></td></tr><tr><td style="text-align:left">null</td><td>null</td><td>表示对象值缺失。</td><td>无</td></tr><tr><td style="text-align:left">undefined</td><td>undefined</td><td>用于初始化变量为一个未定义的值。</td><td>无</td></tr><tr><td style="text-align:left">never</td><td>never</td><td>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</td><td>无</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function function_name():return_type &#123; </span><br><span class="line">    // 语句</span><br><span class="line">    return value; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// return_type 是返回值的类型。</span><br></pre></td></tr></table></figure><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义</span><br><span class="line">function greet():string &#123; // 返回一个字符串</span><br><span class="line">    return &quot;Hello World&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function func_name( param1 [:datatype], param2 [:datatype]) &#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// param1、param2 为参数名。</span><br><span class="line">// datatype 为参数类型。</span><br></pre></td></tr></table></figure><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1,2))</span><br></pre></td></tr></table></figure></p><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p><strong>可选参数</strong><br>在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName?: string) &#123;</span><br><span class="line">    if (lastName)</span><br><span class="line">        return firstName + &quot; &quot; + lastName;</span><br><span class="line">    else</span><br><span class="line">        return firstName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参数默认值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function function_name(param1[:type],param2[:type] = default_value) &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：参数不能同时设置为可选和默认。</p><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function calculate_discount(price:number, rate:number = 0.50) &#123; </span><br><span class="line">    var discount = price * rate; </span><br><span class="line">    console.log(&quot;计算结果: &quot;, discount); </span><br><span class="line">&#125; </span><br><span class="line">calculate_discount(1000) </span><br><span class="line">calculate_discount(1000, 0.30)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;TypeScript是JavaScript的一个超集，支持ECMAScript6标准，设计目标是开发大型应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://lengziyu.cn/tags/TypeScript/"/>
    
      <category term="ES6" scheme="http://lengziyu.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>vue项目优化</title>
    <link href="http://lengziyu.cn/2020/08/26/vue-performance-optimizing/"/>
    <id>http://lengziyu.cn/2020/08/26/vue-performance-optimizing/</id>
    <published>2020-08-26T09:14:45.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目主要针对首屏加载做处理，至少能提升70-。"><a href="#项目主要针对首屏加载做处理，至少能提升70-。" class="headerlink" title="项目主要针对首屏加载做处理，至少能提升70%。"></a>项目主要针对<em>首屏加载</em>做处理，至少能提升70%。</h2><ul><li>vue-cli3</li><li>webpack3</li></ul><h2 id="cdn配置"><a href="#cdn配置" class="headerlink" title="cdn配置"></a>cdn配置</h2><p>cdn优点：有利于减少打包体积，可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  chainWebpack: (config) =&gt;&#123;</span><br><span class="line">config.externals(&#123;</span><br><span class="line">&apos;vue&apos;: &apos;Vue&apos;,</span><br><span class="line">&apos;vuex&apos;: &apos;Vuex&apos;,</span><br><span class="line">&apos;vue-router&apos;: &apos;VueRouter&apos;,</span><br><span class="line">&apos;element-ui&apos;: &apos;ELEMENT&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对稳定的cdn有<a href="https://www.bootcdn.cn" target="_blank" rel="noopener">bootcdn</a>、<a href="https://unpkg.com" target="_blank" rel="noopener">unpkg</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// public/index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue@2.6.10/dist/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue-router@3.0.7/dist/vue-router.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vuex@3.1.2/dist/vuex.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>去掉import，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// import Vue from &apos;vue&apos;</span><br><span class="line">// import Router from &apos;vue-router&apos;</span><br></pre></td></tr></table></figure></p><p>去掉<code>Vue.use(XXX)</code>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Vue.use(Router)</span><br></pre></td></tr></table></figure></p><h2 id="服务器端开启Gzip"><a href="#服务器端开启Gzip" class="headerlink" title="服务器端开启Gzip"></a>服务器端开启Gzip</h2><p>开启 nginx 服务端 gzip性能优化。找到nginx配置文件在 http 配置里面添加如下代码，然后重启nginx服务即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http:&#123; </span><br><span class="line">      gzip on; </span><br><span class="line">      gzip_static on;</span><br><span class="line">      gzip_buffers 4 16k;</span><br><span class="line">      gzip_comp_level 5;</span><br><span class="line">      gzip_types text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg </span><br><span class="line">                 image/gif image/png;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加载时长至少减少一半以上。</p><h2 id="体积分析"><a href="#体积分析" class="headerlink" title="体积分析"></a>体积分析</h2><p>先安装<code>webpack-bundle-analyzer</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-bundle-analyzer -S</span><br></pre></td></tr></table></figure></p><p>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack: (config) =&gt;&#123;</span><br><span class="line">  // 打包文件分析</span><br><span class="line">  config</span><br><span class="line">.plugin(&apos;webpack-bundle-analyzer&apos;)</span><br><span class="line">.use(require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行<code>npm run serve</code>启动就会自动打开浏览器页面<code>http://127.0.0.1:8888</code>。</p><p>对于用的少，体积又大的可以舍弃或者更换更小体积的库。</p><h2 id="去掉预渲染"><a href="#去掉预渲染" class="headerlink" title="去掉预渲染"></a>去掉预渲染</h2><p>该版本默认会自带预渲染，这样大大增加首屏渲染的加载时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack: (config) =&gt;&#123;</span><br><span class="line">// 移除prefetch插件</span><br><span class="line">config.plugins.delete(&apos;prefetch&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果部分需要预渲染的话，可以在<code>router</code>里配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const MenuTree = () =&gt; import(/* webpackChunkName: &quot;MenuTree&quot; */ &apos;./module/menu-tree&apos;);</span><br><span class="line">···</span><br><span class="line">components: &#123; MenuTree &#125;</span><br></pre></td></tr></table></figure></p><h2 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h2><p>去掉线上的打印，关闭sourceMap。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">chainWebpack: (config) =&gt;&#123;</span><br><span class="line">      /** 去掉console.log debugger sourceMap*/</span><br><span class="line">      config.optimization.minimizer([</span><br><span class="line">        new UglifyJsWebpackPlugin(&#123;</span><br><span class="line">          /**这个 sourceMap注释掉，默认就是置为false.(写为false 也是可以的)。</span><br><span class="line">           * 反之设为true 是生效的。</span><br><span class="line">           * 故在官方的配置(productionSourceMap: false)就可以注释掉了*/</span><br><span class="line">          sourceMap: false,</span><br><span class="line">          uglifyOptions: &#123;</span><br><span class="line">            warnings: false,</span><br><span class="line">            compress: &#123;</span><br><span class="line">              drop_console: true,</span><br><span class="line">              drop_debugger: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目主要针对首屏加载做处理，至少能提升70-。&quot;&gt;&lt;a href=&quot;#项目主要针对首屏加载做处理，至少能提升70-。&quot; class=&quot;headerlink&quot; title=&quot;项目主要针对首屏加载做处理，至少能提升70%。&quot;&gt;&lt;/a&gt;项目主要针对&lt;em&gt;首屏加载&lt;/e
      
    
    </summary>
    
      <category term="Vue" scheme="http://lengziyu.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://lengziyu.cn/tags/Vue/"/>
    
      <category term="webpack3" scheme="http://lengziyu.cn/tags/webpack3/"/>
    
      <category term="vue-cli3" scheme="http://lengziyu.cn/tags/vue-cli3/"/>
    
  </entry>
  
  <entry>
    <title>uniapp 自定义Tabbar探讨</title>
    <link href="http://lengziyu.cn/2020/02/13/uniapp-tabbar/"/>
    <id>http://lengziyu.cn/2020/02/13/uniapp-tabbar/</id>
    <published>2020-02-13T07:46:37.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要用自定义tabbar？原生自带的满足不了吗？"><a href="#为什么要用自定义tabbar？原生自带的满足不了吗？" class="headerlink" title="为什么要用自定义tabbar？原生自带的满足不了吗？"></a>为什么要用自定义tabbar？原生自带的满足不了吗？</h2><p>答：是的，基于两点需求，1.显示红点数量样式修改；2.底部弹框被原生tabbar挡住。</p><h2 id="尝试过多种方案，也没有达到预期。"><a href="#尝试过多种方案，也没有达到预期。" class="headerlink" title="尝试过多种方案，也没有达到预期。"></a>尝试过多种方案，也没有达到预期。</h2><h3 id="1-tabbar组件形式"><a href="#1-tabbar组件形式" class="headerlink" title="1.tabbar组件形式"></a>1.tabbar组件形式</h3><p>每个tabbar页面都引用自定义tabbar组件，传当前页面的参数作为选中当前项。<br>不足：每次切换tabbar页面，组件也重新加载，达不到效果。</p><h3 id="2-页面组件形式"><a href="#2-页面组件形式" class="headerlink" title="2.页面组件形式"></a>2.页面组件形式</h3><p>tabbar页面全部作为组件形式，先新建一个index.vue页面，引入自定义tabbar，引入全部tabbar页面组件，为tabbar按钮添加点击事件，判断显示哪个页面组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;page-work v-if=&quot;current == 0&quot; /&gt;</span><br><span class="line">&lt;page-maillist v-if=&quot;current == 1&quot; /&gt;</span><br><span class="line">&lt;page-order v-if=&quot;current == 2&quot; /&gt;</span><br><span class="line">&lt;page-my v-if=&quot;current == 3&quot; /&gt;</span><br><span class="line">&lt;sl-tabbar  @tabbarBack=&quot;tabbarBack&quot; :current=&quot;current&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import pageWork from &apos;../../pages/work/index.vue&apos;</span><br><span class="line">import pageMaillist from &apos;../../pages/maillist/index.vue&apos;</span><br><span class="line">import pageOrder from &apos;../../pages/order/index.vue&apos;</span><br><span class="line">import pageMy from &apos;../../pages/my/index.vue&apos;</span><br><span class="line">import slTabbar from &apos;@/components/tabbar/index.vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">components: &#123;</span><br><span class="line">pageWork,</span><br><span class="line">pageMaillist,</span><br><span class="line">pageOrder,</span><br><span class="line">pageMy,</span><br><span class="line">slTabbar,</span><br><span class="line">&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">current: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">tabbarBack(i, idx) &#123;</span><br><span class="line">this.current = idx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不足：页面的特性已经丧失，页面生命周期不复存在，严重影响原有页面逻辑。</p><h3 id="3-按需显示隐藏原生tabbar"><a href="#3-按需显示隐藏原生tabbar" class="headerlink" title="3.按需显示隐藏原生tabbar"></a>3.按需显示隐藏原生tabbar</h3><p>使用<code>uni.showTabBar()</code>和<code>uni.hideTabBar()</code>动态显示隐藏原生tabbar，弹框的时候隐藏原生tabbar，并同时显示自定义tabbar，否则反之。<br>不足，切换时有闪烁效果，不理想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要用自定义tabbar？原生自带的满足不了吗？&quot;&gt;&lt;a href=&quot;#为什么要用自定义tabbar？原生自带的满足不了吗？&quot; class=&quot;headerlink&quot; title=&quot;为什么要用自定义tabbar？原生自带的满足不了吗？&quot;&gt;&lt;/a&gt;为什么要用自定义
      
    
    </summary>
    
    
      <category term="uniapp" scheme="http://lengziyu.cn/tags/uniapp/"/>
    
  </entry>
  
  <entry>
    <title>uniapp 开发记录</title>
    <link href="http://lengziyu.cn/2019/10/18/vue-summarizing-skills/"/>
    <id>http://lengziyu.cn/2019/10/18/vue-summarizing-skills/</id>
    <published>2019-10-18T11:53:40.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>单位用rpx，布局用Flex</p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h3 id="云端打包"><a href="#云端打包" class="headerlink" title="云端打包"></a>云端打包</h3><p><strong>安卓端&amp;iOS</strong><br>云端打包流程：打开HBuilderX，顶部菜单【发行-&gt;原生App-云打包】，选打自定义调试基座，等待打包成功，原生App-查看云打包状态，编辑器底部打印台会显示最近打包的地址，点击下载即可。<br>注：iOS端需要苹果开发证书。</p><h3 id="本地离线打包"><a href="#本地离线打包" class="headerlink" title="本地离线打包"></a>本地离线打包</h3><p><strong>安卓</strong></p><p>用官方HBuilder-Hello的项目，<br>参考这个：<a href="https://www.jianshu.com/p/e41d80c0cbc2" target="_blank" rel="noopener">uni-app用AndroidStudio打包apk文件</a></p><h1 id="h5与app区别"><a href="#h5与app区别" class="headerlink" title="h5与app区别"></a>h5与app区别</h1><ol><li>CSS<code>background-size</code>属性，写在CSS里h5端生效，但是app端无效：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// app无效</span><br><span class="line">uni-swiper-item&#123;</span><br><span class="line">        background-size: 100% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>解决方法：就是在标签动态添加<code>backgroundSize</code>属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;uni-swiper-item</span><br><span class="line">:style=&quot;&#123; backgroundImage: &apos;url(&apos;+ banner.url +&apos;)&apos;, backgroundSize: &apos;cover&apos; &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;/uni-swiper-item&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h1&gt;&lt;p&gt;单位用rpx，布局用Flex&lt;/p&gt;
&lt;h1 id=&quot;打包&quot;&gt;&lt;a href=&quot;#打包&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="uniapp" scheme="http://lengziyu.cn/tags/uniapp/"/>
    
  </entry>
  
  <entry>
    <title>公众号用vue开发百度地图</title>
    <link href="http://lengziyu.cn/2019/09/10/weixin_use_baidu_map/"/>
    <id>http://lengziyu.cn/2019/09/10/weixin_use_baidu_map/</id>
    <published>2019-09-10T15:01:18.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>最近用vue在公众号结合百度地图开发，功能是根据公众号定位获取经纬度，再用百度地图显示附近的店铺。由于公众号不能满足业务需求，所以加上百度地图。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>微信公众号获取经纬度</li><li>公众号经纬度转换百度经纬度</li><li>vue开发用<a href="https://github.com/Dafrok/vue-baidu-map" target="_blank" rel="noopener">vue-baidu-map</a>开发注意事项</li><li>百度地图逆/地址解析</li><li>推荐一些相关的开发/测试工具</li></ul><h2 id="微信公众号获取经纬度"><a href="#微信公众号获取经纬度" class="headerlink" title="微信公众号获取经纬度"></a>微信公众号获取经纬度</h2><p>公众号文档-<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#36" target="_blank" rel="noopener">获取地理位置接口</a><br>前提是公众号的一切东西都设置好，要先调接口获取签名，然后通过<code>wx.config</code>安全验证，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  获取公众号经纬度</span><br><span class="line">*  Vue 注册全局函数的方式  </span><br><span class="line">*/</span><br><span class="line">Vue.prototype.wxLocation = (opts) =&gt; &#123;</span><br><span class="line">  const ua = window.navigator.userAgent.toLowerCase();</span><br><span class="line">  if (ua.match(/MicroMessenger/i) == &apos;micromessenger&apos;) &#123;</span><br><span class="line">    // 这是一个请求，获取签名</span><br><span class="line">    api.wxSignature(&#123;</span><br><span class="line">        url: window.location.href.split(&apos;#&apos;)[0]</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(res =&gt; &#123;</span><br><span class="line">        // 安全验证</span><br><span class="line">        wx.config(&#123;</span><br><span class="line">          debug: false,</span><br><span class="line">          appId: res.data.appid,</span><br><span class="line">          timestamp: res.data.timestamp,</span><br><span class="line">          nonceStr: res.data.nonceStr,</span><br><span class="line">          signature: res.data.signature,</span><br><span class="line">          jsApiList: [</span><br><span class="line">            &apos;openLocation&apos;,</span><br><span class="line">            &apos;getLocation&apos;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        wx.ready(() =&gt; &#123;</span><br><span class="line">          // 获取经纬度</span><br><span class="line">          wx.getLocation(&#123;</span><br><span class="line">            type: &apos;wgs84&apos;, // 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入&apos;gcj02&apos;</span><br><span class="line">            success: (res)=&gt; &#123;</span><br><span class="line">              var latitude = res.latitude; // 纬度，浮点数，范围为90 ~ -90</span><br><span class="line">              var longitude = res.longitude; // 经度，浮点数，范围为180 ~ -180。</span><br><span class="line">              opts.wxGetLocation(res)</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&apos;非微信端，不获取地址！&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>页面调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  this.wxLocation(&#123;</span><br><span class="line">    wxGetLocation: function(res) &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h2 id="公众号经纬度转换百度经纬度"><a href="#公众号经纬度转换百度经纬度" class="headerlink" title="公众号经纬度转换百度经纬度"></a>公众号经纬度转换百度经纬度</h2><p><strong>目前国内主要有以下三种坐标系：</strong></p><ul><li><p>WGS84：为一种大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。</p></li><li><p>GCJ02：又称火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。</p></li><li><p>BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标。</p></li></ul><p>非中国地区地图，服务坐标统一使用WGS84坐标。<br><a href="http://lbsyun.baidu.com/index.php?title=jspopular3.0/guide/coorinfo" target="_blank" rel="noopener">百度地图-坐标转换说明</a></p><p>我了解的有两种方式转换：</p><ul><li><a href="http://lbsyun.baidu.com/index.php?title=webapi/guide/changeposition" target="_blank" rel="noopener">文档化-坐标转换服务</a></li><li>通过接口转换<br>下面介绍通过接口的方式转换：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846</span><br></pre></td></tr></table></figure></li></ul><p>其中<code>from</code>参数：0代表WGS-84即标准GPS设备返回的坐标, 2代表国测局的标准；<code>to</code>参数：4代表百度的坐标；<code>x</code>参数：代表纬度latitude；<code>y</code>参数：代表经度longitude。</p><p>大概会出现跨域问题，我用了vue-cli2配置的<code>proxyTable</code>无法解决，后来我用了朋友的跨域应用解决了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846</span><br></pre></td></tr></table></figure></p><p>转换出来是经过base64加码的，这样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;error&quot;:0,&quot;x&quot;:&quot;MTEzLjU1MTgxMDg2MDE5&quot;,&quot;y&quot;:&quot;MjMuNTIxMjM0OTM0OTE0&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>用<code>js-base64</code>解码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let Base64 = require(&apos;js-base64&apos;).Base64;</span><br><span class="line">...</span><br><span class="line">axios.get(&apos;https://bird.ioliu.cn/v2?url=http://api.map.baidu.com/ag/coord/convert?from=0&amp;to=4&amp;x=113.540124&amp;y=23.517846&apos;)</span><br><span class="line">      .then(res)&#123;</span><br><span class="line">        var longitude = Base64.decode(res.x);</span><br><span class="line">        var latitude = Base64.decode(res.y);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>此时，转换经纬度大功告成！</p><h2 id="vue开发用vue-baidu-map开发注意事项"><a href="#vue开发用vue-baidu-map开发注意事项" class="headerlink" title="vue开发用vue-baidu-map开发注意事项"></a>vue开发用<a href="https://github.com/Dafrok/vue-baidu-map" target="_blank" rel="noopener">vue-baidu-map</a>开发注意事项</h2><p>安装就不说了，文档都有，说说遇到的坑吧。<br>问题1.<br>   自定义覆盖物，定义的按钮不触发事件，查看DOM，发现触发了地图蒙层，<br>解决：<br>引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://api.map.baidu.com/library/EventWrapper/1.2/src/EventWrapper.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;baidu-map class=&quot;bm-view&quot; ref=&quot;baiduMap&quot; :zoom=&quot;15&quot; @click=&quot;overlay&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/baidu-map&gt;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">methods: &#123;</span><br><span class="line">  overlay(event) &#123;</span><br><span class="line">    BMapLib.EventWrapper.addDomListener(this.$refs.baiduMap.$el, &quot;touchend&quot;, (e)=&gt;&#123;</span><br><span class="line">      alert(&apos;点击触发&apos;)</span><br><span class="line">    &#125;, false)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>问题2.<br>获取百度地图实例<code>BMap</code>，<br>解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;baidu-map class=&quot;bm-view&quot; ref=&quot;baiduMap&quot;  @ready=&quot;mapHandler&quot; :zoom=&quot;15&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/baidu-map&gt;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">methods: &#123;</span><br><span class="line">  // 初始化</span><br><span class="line">  mapHandler(e) &#123;</span><br><span class="line">    console.log(e) // &#123; BMap: xx, map: xx &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h2 id="推荐一些相关的开发-测试工具"><a href="#推荐一些相关的开发-测试工具" class="headerlink" title="推荐一些相关的开发/测试工具"></a>推荐一些相关的开发/测试工具</h2><ul><li><a href="http://api.map.baidu.com/lbsapi/getpoint/index.html" target="_blank" rel="noopener">查询经纬度</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;功能描述&quot;&gt;&lt;a href=&quot;#功能描述&quot; class=&quot;headerlink&quot; title=&quot;功能描述&quot;&gt;&lt;/a&gt;功能描述&lt;/h2&gt;&lt;p&gt;最近用vue在公众号结合百度地图开发，功能是根据公众号定位获取经纬度，再用百度地图显示附近的店铺。由于公众号不能满足业务需求
      
    
    </summary>
    
    
      <category term="微信公众号" scheme="http://lengziyu.cn/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Windows Flutter安装和运行</title>
    <link href="http://lengziyu.cn/2019/08/01/windows-flutter-install/"/>
    <id>http://lengziyu.cn/2019/08/01/windows-flutter-install/</id>
    <published>2019-08-01T08:34:21.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter介绍"><a href="#Flutter介绍" class="headerlink" title="Flutter介绍"></a>Flutter介绍</h2><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p><h2 id="Windows环境要求"><a href="#Windows环境要求" class="headerlink" title="Windows环境要求"></a>Windows环境要求</h2><ul><li>Java环境（配置环境变量）；</li><li><a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">Android Studio</a>（主要安装模拟器和自带环境）；</li><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Vscode</a>（“宇宙之强”编辑器）；</li><li>Git。</li></ul><h2 id="Flutter安装"><a href="#Flutter安装" class="headerlink" title="Flutter安装"></a>Flutter安装</h2><p>官网安装：<a href="https://flutter.dev/docs/get-started/install" target="_blank" rel="noopener">https://flutter.dev/docs/get-started/install</a><br>or<br>Github（有点大，可能要多试几次）：<code>$ git clone -b beta https://github.com/flutter/flutter.git</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>是否安装完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter --help</span><br></pre></td></tr></table></figure></p><p>查看是否需要安装任何依赖项来完成设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter doctor</span><br></pre></td></tr></table></figure></p><p>提示：有报红的一个一个的解决（打×的要解决，!号的可以不用）。</p><h2 id="Vscode插件安装"><a href="#Vscode插件安装" class="headerlink" title="Vscode插件安装"></a>Vscode插件安装</h2><ul><li>flutter</li><li>dart<br>安装完重启vscode，<br>在编辑器的左下角的设置点击进入 “命令面板”，在命令面板中点击flutter：new project [项目名称]</li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在终端命令行里面输入 ： <code>$ flutter run</code>  等待程序的执行，完成<code>hello world</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">R 键重新启动</span><br><span class="line">r 键热重载</span><br><span class="line">q 退出</span><br><span class="line">p 显示网格</span><br><span class="line">P 显示帧率</span><br><span class="line">o 切换Android与iOS的预览模式</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flutter介绍&quot;&gt;&lt;a href=&quot;#Flutter介绍&quot; class=&quot;headerlink&quot; title=&quot;Flutter介绍&quot;&gt;&lt;/a&gt;Flutter介绍&lt;/h2&gt;&lt;p&gt;Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原
      
    
    </summary>
    
      <category term="Flutter" scheme="http://lengziyu.cn/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>基于Vue SEO的四种方案</title>
    <link href="http://lengziyu.cn/2019/06/30/vue-seo/"/>
    <id>http://lengziyu.cn/2019/06/30/vue-seo/</id>
    <published>2019-06-30T11:29:45.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。</p><ul><li>1.SSR服务器渲染；</li><li>2.静态化；</li><li>3.预渲染prerender-spa-plugin；</li><li>4.使用Phantomjs针对爬虫做处理。</li></ul><h2 id="1-SSR服务器渲染"><a href="#1-SSR服务器渲染" class="headerlink" title="1.SSR服务器渲染"></a>1.SSR服务器渲染</h2><p>关于服务器渲染：<a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F" target="_blank" rel="noopener">Vue官网介绍</a>，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。</p><p><strong>使用SSR权衡之处：</strong></p><ul><li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行；</li><li>环境和部署要求更高，需要Node.js server 运行环境；</li><li>高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><p><strong>优势：</strong></p><ul><li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；</li><li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</li></ul><p><strong>不足：（开发中遇到的坑）</strong><br>1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(process.browser)&#123;</span><br><span class="line"> console.log(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引用npm包，带有dom操作的，例如：<code>wowjs</code>，不能用<code>import</code>的方式，改用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (process.browser) &#123;</span><br><span class="line">     var &#123; WOW &#125; = require(&apos;wowjs&apos;);</span><br><span class="line">     require(&apos;wowjs/css/libs/animate.css&apos;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于<strong>页面组件</strong>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 并发加载多个接口：</span><br><span class="line">  async asyncData (&#123; app, query &#125;) &#123;</span><br><span class="line">    let [resA, resB, resC] = await Promise.all([</span><br><span class="line">      app.$axios.get(&apos;/api/a&apos;),</span><br><span class="line">      app.$axios.get(&apos;/api/b&apos;),</span><br><span class="line">      app.$axios.get(&apos;/api/c&apos;),</span><br><span class="line">     ])</span><br><span class="line"></span><br><span class="line">     return &#123;</span><br><span class="line">       dataA: resA.data,</span><br><span class="line">       dataB: resB.data,</span><br><span class="line">       dataC: resC.data,</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在asyncData中获取参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.获取动态路由参数，如：</span><br><span class="line"></span><br><span class="line">/list/:id&apos; ==&gt;  &apos;/list/123</span><br><span class="line"></span><br><span class="line">接收：</span><br><span class="line"></span><br><span class="line">async asyncData (&#123; app, query &#125;) &#123;</span><br><span class="line">  console.log(app.context.params.id) //123</span><br><span class="line">&#125;</span><br><span class="line">2.获取url?获取参数，如：</span><br><span class="line"></span><br><span class="line">/list?id=123</span><br><span class="line"></span><br><span class="line">接收：</span><br><span class="line"></span><br><span class="line">async asyncData (&#123; app, query &#125;) &#123;</span><br><span class="line">  console.log(query.id) //123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.如果你使用<code>v-if</code>语法，部署到线上大概也会遇到这个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error while initializing app DOMException: Failed to execute &apos;appendChild&apos; on &apos;Node&apos;: This node type does not support this method.</span><br><span class="line">    at Object.We [as appendChild]</span><br></pre></td></tr></table></figure></p><p>根据github nuxt上的<a href="https://github.com/nuxt/nuxt.js/issues/1552" target="_blank" rel="noopener">issue第1552条</a>提示，要将<code>v-if</code>改为<code>v-show</code>语法。</p><p>4.坑太多，留坑，晚点更。</p><h2 id="2-静态化"><a href="#2-静态化" class="headerlink" title="2.静态化"></a>2.静态化</h2><p>静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。<br>在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| pages/</span><br><span class="line">---| index.vue</span><br><span class="line">---| users/</span><br><span class="line">-----| _id.vue</span><br></pre></td></tr></table></figure></p><p>需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// nuxt.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  generate: &#123;</span><br><span class="line">    routes: [</span><br><span class="line">      &apos;/users/1&apos;,</span><br><span class="line">      &apos;/users/2&apos;,</span><br><span class="line">      &apos;/users/3&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行打包，即可看见打包出来的页面。<br>但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？</p><ul><li>使用一个返回 Promise 对象类型 的 函数；</li><li>使用一个回调是 callback(err, params) 的 函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// nuxt.config.js</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  generate: &#123;</span><br><span class="line">    routes: function () &#123;</span><br><span class="line">      return axios.get(&apos;https://my-api/users&apos;)</span><br><span class="line">      .then((res) =&gt; &#123;</span><br><span class="line">        return res.data.map((user) =&gt; &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            route: &apos;/users/&apos; + user.id,</span><br><span class="line">            payload: user</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>现在我们可以从<code>/users/_id.vue</code>访问的<code>payload</code>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async asyncData (&#123; params, error, payload &#125;) &#123;</span><br><span class="line">  if (payload) return &#123; user: payload &#125;</span><br><span class="line">  else return &#123; user: await backend.fetchUser(params.id) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。<br><strong>优势：</strong></p><ul><li>纯静态文件，访问速度超快；</li><li>对比SSR，不涉及到服务器负载方面问题；</li><li>静态网页不宜遭到黑客攻击，安全性更高。</li></ul><p><strong>不足：</strong></p><ul><li>如果动态路由参数多的话不适用。</li></ul><h2 id="3-预渲染prerender-spa-plugin"><a href="#3-预渲染prerender-spa-plugin" class="headerlink" title="3.预渲染prerender-spa-plugin"></a>3.预渲染prerender-spa-plugin</h2><p>如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install prerender-spa-plugin --save</span><br></pre></td></tr></table></figure></p><p>vue cli 3 <code>vue.config.js</code>配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const PrerenderSPAPlugin = require(&apos;prerender-spa-plugin&apos;);</span><br><span class="line">const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos;) return;</span><br><span class="line">        return &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">                new PrerenderSPAPlugin(&#123;</span><br><span class="line">                    // 生成文件的路径，也可以与webpakc打包的一致。</span><br><span class="line">                    // 下面这句话非常重要！！！</span><br><span class="line">                    // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。</span><br><span class="line">                    staticDir: path.join(__dirname,&apos;dist&apos;),</span><br><span class="line">                    // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。</span><br><span class="line">                    routes: [&apos;/&apos;, &apos;/product&apos;,&apos;/about&apos;],</span><br><span class="line">                    // 这个很重要，如果没有配置这段，也不会进行预编译</span><br><span class="line">                    renderer: new Renderer(&#123;</span><br><span class="line">                        inject: &#123;</span><br><span class="line">                            foo: &apos;bar&apos;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        headless: false,</span><br><span class="line">                        // 在 main.js 中 document.dispatchEvent(new Event(&apos;render-event&apos;))，两者的事件名称要对应上。</span><br><span class="line">                        renderAfterDocumentEvent: &apos;render-event&apos;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;),</span><br><span class="line">            ],</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在main.js中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    document.dispatchEvent(new Event(&apos;render-event&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p><p>注意：router中必须设置 <code>mode: “history”</code>。</p><p>打包出来可以看见文件，打包出文件夹<code>/index.html</code>，例如：<code>about</code> =&gt; <code>about/index.html</code>，里面有html内容。</p><p><strong>优势：</strong></p><ul><li>改动小，引入个插件就完事；</li></ul><p><strong>不足：</strong></p><ul><li>无法使用动态路由；</li><li>只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢；</li></ul><h2 id="4-使用Phantomjs针对爬虫做处理"><a href="#4-使用Phantomjs针对爬虫做处理" class="headerlink" title="4.使用Phantomjs针对爬虫做处理"></a>4.使用Phantomjs针对爬虫做处理</h2><p>Phantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。<br>虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。<br>这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，<strong>判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。</strong></p><p><img src="https://image-static.segmentfault.com/320/346/3203467011-5d18823332fe1_articlex" alt="图片描述"></p><p>具体代码戳这里：<a href="https://github.com/lengziyu/vue-seo-phantomjs" target="_blank" rel="noopener">vue-seo-phantomjs</a>。<br>要安装全局<code>phantomjs</code>，局部<code>express</code>，测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ phantomjs spider.js &apos;https://www.baidu.com&apos;</span><br></pre></td></tr></table></figure></p><p>如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。<br>启动之后或者用postman在请求头增加<code>User-Agent</code>值为<code>Baiduspider</code>，效果一样的。</p><p><strong>部署上线</strong><br>线上要安装<code>node</code>、<code>pm2</code>、<code>phantomjs</code>，nginx相关配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream spider_server &#123;</span><br><span class="line">  server localhost:3000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_set_header  Host            $host:$proxy_port;</span><br><span class="line">      proxy_set_header  X-Real-IP       $remote_addr;</span><br><span class="line">      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">      if ($http_user_agent ~* &quot;Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider&quot;) &#123;</span><br><span class="line">        proxy_pass  http://spider_server;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优势：</strong></p><ul><li>完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多；</li><li>对已用SPA开发完成的项目，这是不二之选。</li></ul><p><strong>不足：</strong></p><ul><li>部署需要node服务器支持；</li><li>爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；</li><li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果构建大型网站，如商城类，别犹豫，直接上SSR服务器渲染，当然也有相应的坑等你，社区较成熟，英文好点，一切问题都迎刃而解。<br>如果只是个人博客、公司官网这类，其余三种都可以。<br>如果对已用SPA开发完成的项目进行SEO优化，而且支持node服务器，请使用<code>Phantomjs</code>。</p><p>很少写文章，这是我这个月对Vue SEO方案的探索，写的不对的地方请指出，谢谢理解~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.SSR服务器渲染；&lt;/li&gt;
&lt;li&gt;2.静态化；&lt;/li&gt;
&lt;li&gt;3.预渲染p
      
    
    </summary>
    
      <category term="Vue" scheme="http://lengziyu.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://lengziyu.cn/tags/Vue/"/>
    
      <category term="SEO" scheme="http://lengziyu.cn/tags/SEO/"/>
    
      <category term="Phantomjs" scheme="http://lengziyu.cn/tags/Phantomjs/"/>
    
  </entry>
  
  <entry>
    <title>回顾我的2016</title>
    <link href="http://lengziyu.cn/2016/12/31/hello-2017/"/>
    <id>http://lengziyu.cn/2016/12/31/hello-2017/</id>
    <published>2016-12-31T14:38:13.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>原来今天已经是2016最后一天，是时候写一个总结了。一方面可以总结这一年的收获和不足之处进行反思，一方面为新的一年埋下信念。<br><a id="more"></a></p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>今年3月份，公司内部管理发生变动。我们网站部被合并到发行部，遭遇发行部老大强势管理，气氛突然紧张起来。<br>平时没事做也要陪发行部的加班到九点，还有老大之前和我们几个提工资也被取消了。钱没够心里也受尽委屈，渐渐也有了离职的打算。后来被老大约谈说公司准备在我们网站部和设计部分别裁员2人，我平时太闲，所以入了名单。最后争取了一个月赔偿金，总之感觉还不错吧~</p><p><strong>找工作</strong><br>之后的一星期，面试了几家，还在知乎回答了一个问题呢，<a href="https://www.zhihu.com/question/41466747/answer/93430578" target="_blank" rel="noopener">Web前端岗位面试题有哪些？- 冷子欲的回答</a>，就这样交了几个朋友。<br>面试当中也算是遇上形形色色的面试官，大概面试了7家，收到了3家offer，过程学到了不少，也了解到自己需要加强的地方，最后选择了一家离租房近点，薪资高点，规模大点的 - 恒拓开源（开源中国）。</p><p><strong>学习还是学习</strong><br>7月份，外包派驻到“南方航空”，离租房太远，被迫搬到白云区了。负责“新技术研究”这块，每天学习webpack、node、react、ES6/ES7 ，当然除了学习，也有活要做的：</p><ul><li>搭建了一个内部用的gulp-webpack脚手架；</li><li>个人用react开发了”额外付费行李”项目；</li><li>用sinopia在linux服务器上搭建了南航内部npm管理系统；</li><li>和同事研究海外版react项目，并编写简单易懂的开发文档，并展开了技术分享会（供南航团队内部人学习）；</li></ul><p>直到现在。</p><h2 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h2><p>[ 2015.04 - 2016.04 ] 公司只有一个前端，活很少，所以见识和接触到的也比较少，空闲时间比较喜欢折腾新技术。并写一些小demo经过分析和测试，实战到工作当中，解决了一些痛点、提高了开发效率以及优化网站访问速度。 比如：fis3、requirejs、sass、gulp、按需加载、懒加载等等。<br>[ 2016.04 - 2016.07 ] 这段时间，用阿里开源的sui开发，采用前后端分离模式…不多说了。<br>[ 2016.07 - 至今 ] react全家桶、webpack从简单配置到大项目应用、ES6/ES7语法、node。<br>当中也陆陆续续的用过vue，从vue1到vue2，并在 <a href="http://createjs.cc" target="_blank" rel="noopener">createjs中文网</a>改版中实战了一把vue2，感觉小清新，比较快上手。<br>学习webpack过程中综合了一些资源和教程，收获100多start <a href="https://github.com/lengziyu/learn-webpack" target="_blank" rel="noopener">github learn-webpack</a>。<br>2016还在继续维护 <a href="http://fenav.com" target="_blank" rel="noopener">前端导航</a> 呢。</p><h2 id="关于创业？"><a href="#关于创业？" class="headerlink" title="关于创业？"></a>关于创业？</h2><p>一个好朋友在筹备做一个DIY衣服的网站，已找到一些合伙人。某天听着他说的不错，我后来也加入了。我负责前端部分工作，一起商议搭建用的框架/技术，一起探讨盈利模式。<br>我做了一部分，后来由于工作忙，而且我觉得创业这事我还未准备好，我就提出退出了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>看了不少电影，最喜欢的是《碟中谍5》、《谍影重重5》啦；</li><li>书籍：《js高程》、《js设计模式》，比较少看书；</li><li>对于我家喵大人，平时当女孩纸养，绝育的时候才知道是蓝孩纸（尴尬）。还有就是5月份跑出去了几天，找到的时候真的很欣慰，2017继续做好铲屎君。</li><li>工作已两年半，今年才23岁。没错我没上大学，理由不说了，现在是中技学历，今年末参加了成人高考，成功在华南理工大学报考了专科，见笑了~盲羊补牢，为时不晚嘛。<h2 id="关于2017"><a href="#关于2017" class="headerlink" title="关于2017"></a>关于2017</h2>计划赶不上变化，所以我也不轻言计划了。<br>想怎样就怎样吧，当然是继续努力啦。</li></ul><p>相信2017将会发生更多有趣的故事，更多的改变。<br>朋友，2017让我们一起为美好的生活而努力吧！！共勉。<br>写文水平有限。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原来今天已经是2016最后一天，是时候写一个总结了。一方面可以总结这一年的收获和不足之处进行反思，一方面为新的一年埋下信念。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6 function* yield yield*</title>
    <link href="http://lengziyu.cn/2016/12/08/es6-new-grammar/"/>
    <id>http://lengziyu.cn/2016/12/08/es6-new-grammar/</id>
    <published>2016-12-08T14:03:09.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要讲解es6新语法<code>function*</code>、<code>yield</code>和<code>yield*</code>。<br><a id="more"></a></p><h1 id="function"><a href="#function" class="headerlink" title="function*"></a>function*</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>定义一个generator（生成器）函数，返回一个Generator对象。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function* name[ param[ param[ param…]]] &#123; statements &#125;</span><br></pre></td></tr></table></figure><ul><li>name 函数名</li><li>param 传入函数的参数名，一个函数最多可有255个参数</li><li>statements 函数的主体</li></ul><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>生成器是一种可以在从中退出并在之后重新进入的函数。生成器环境在执行后会被保存，下次执行可继续使用。</p><p>调用生成器函数，并不立即执行主体，而是返回这个生成器函数的迭代器对象，当这个迭代器调用next()方法时，生成器函数主体会被执行至第一个 yield 表达式，该表达式定义了迭代器返回的值，或者，被 yield* 委托至另一个生成器函数。next() 方法返回一个对象，该对象有一个value属性，表示产出的值，和一个done属性，表示生成器是否已经产出了它最后的值。</p><h3 id="基本事例"><a href="#基本事例" class="headerlink" title="基本事例"></a>基本事例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* idMaker()&#123;</span><br><span class="line">  var index = 0;</span><br><span class="line">  while(index&lt;3)</span><br><span class="line">    yield index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = idMaker();</span><br><span class="line"></span><br><span class="line">console.log(gen.next().value); // 0</span><br><span class="line">console.log(gen.next().value); // 1</span><br><span class="line">console.log(gen.next().value); // 2</span><br><span class="line">console.log(gen.next().value); // undefined</span><br></pre></td></tr></table></figure><h3 id="yield-事例"><a href="#yield-事例" class="headerlink" title="yield* 事例"></a>yield* 事例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* anotherGenerator(i) &#123;</span><br><span class="line">  yield i + 1;</span><br><span class="line">  yield i + 2;</span><br><span class="line">  yield i + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* generator(i)&#123;</span><br><span class="line">  yield i;</span><br><span class="line">  yield* anotherGenerator(i);</span><br><span class="line">  yield i + 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen = generator(10);</span><br><span class="line"></span><br><span class="line">console.log(gen.next().value); // 10</span><br><span class="line">console.log(gen.next().value); // 11</span><br><span class="line">console.log(gen.next().value); // 12</span><br><span class="line">console.log(gen.next().value); // 13</span><br><span class="line">console.log(gen.next().value); // 20</span><br></pre></td></tr></table></figure><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>属于ES6规范，请使用babel转换</p><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>yield关键词用来停止或继续一个生成器函数。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield[[ expression ]]</span><br></pre></td></tr></table></figure><ul><li>expression 用作返回值，如果忽略，则返回undefined</li></ul><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>yield 关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值. 可以把它想成是 return 关键字的一个基于生成器的版本.<br>yield 关键字实际返回一个对象，包含两个属性, value 和 done.  value 属性为 yield expression 的值,  done 是一个布尔值用来指示生成器函数是否已经全部完成.<br>一旦在 yield expression 处暂停,  除非外部调用生成器的 next() 方法，否则生成器的代码将不能继续执行. 这使得可以对生成器的执行以及渐进式的返回值进行直接控制.</p><h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* foo()&#123;</span><br><span class="line">  var index = 0;</span><br><span class="line">  while (index &lt;= 2) // when index reaches 3,</span><br><span class="line">                     // yield&apos;s done will be true</span><br><span class="line">                     // and its value will be undefined;</span><br><span class="line">    yield index++;</span><br><span class="line">&#125;</span><br><span class="line">一旦生成器函数已定义，可以通过构造一个迭代器来使用它.</span><br><span class="line">var iterator = foo();</span><br><span class="line">console.log(iterator.next()); // &#123; value:0, done:false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value:1, done:false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value:2, done:false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value:undefined, done:true &#125;</span><br></pre></td></tr></table></figure><h1 id="yield-1"><a href="#yield-1" class="headerlink" title="yield*"></a>yield*</h1><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>yield*[[ expression ]]</p><ul><li>expression 任意可迭代的对象</li></ul><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>yield<em> 一个可迭代对象，就相当于把这个可迭代对象的所有迭代值分次 yield 出去。<br>yield</em> 表达式本身的值就是当前可迭代对象迭代完毕（当done为true时）时的返回值。</p><h3 id="事例-1"><a href="#事例-1" class="headerlink" title="事例"></a>事例</h3><p><strong>委托给其他生成器</strong><br>以下代码中，g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回，就像那些 yield 语句是写在 g2() 里一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function* g1() &#123;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  yield 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* g2() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield* g1();</span><br><span class="line">  yield 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var iterator = g2();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 4, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><p><strong>委托给其他类型的可迭代对象</strong><br>除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* g3() &#123;</span><br><span class="line">  yield* [1, 2];</span><br><span class="line">  yield* &quot;34&quot;;</span><br><span class="line">  yield* arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var iterator = g3(5, 6);</span><br><span class="line"></span><br><span class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: &quot;3&quot;, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: &quot;4&quot;, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 6, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><h3 id="yield-表达式的值"><a href="#yield-表达式的值" class="headerlink" title="yield* 表达式的值"></a>yield* 表达式的值</h3><p>yield* 是一个表达式，不是语句，所以它会有自己的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function* g4() &#123;</span><br><span class="line">  yield* [1, 2, 3];</span><br><span class="line">  return &quot;foo&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result;</span><br><span class="line"></span><br><span class="line">function* g5() &#123;</span><br><span class="line">  result = yield* g4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var iterator = g5();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</span><br><span class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;,</span><br><span class="line">                              // 此时 g4() 返回了 &#123; value: &quot;foo&quot;, done: true &#125;</span><br><span class="line"></span><br><span class="line">console.log(result);          // &quot;foo&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里主要讲解es6新语法&lt;code&gt;function*&lt;/code&gt;、&lt;code&gt;yield&lt;/code&gt;和&lt;code&gt;yield*&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://lengziyu.cn/categories/es6/"/>
    
    
      <category term="es6" scheme="http://lengziyu.cn/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>redux 基础</title>
    <link href="http://lengziyu.cn/2016/12/08/redux-basics/"/>
    <id>http://lengziyu.cn/2016/12/08/redux-basics/</id>
    <published>2016-12-08T14:01:25.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。<br>Redux 提供createStore这个函数，用来生成 Store。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">const store = createStore(fn);</span><br></pre></td></tr></table></figure></p><p>上面createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。<br>当前时刻的 State，可以通过store.getState()拿到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = store.getState();</span><br></pre></td></tr></table></figure></p><p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Action 是一个对象。其中的type属性是必须的，表示 Action 的名称</span><br><span class="line">const action = &#123;</span><br><span class="line">  type: &apos;ADD_TODO&apos;,</span><br><span class="line">  payload: &apos;Learn Redux&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux<br>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p><h3 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a>Action Creator</h3><p>可以定义一个函数来生成Action，这个函数叫Action Creator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const ADD_TODO = &apos;添加 TODO&apos;;</span><br><span class="line">function addTodo(text) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const action = addTodo(&apos;Learn Redux&apos;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，add Todo就是一个Action Creator</p><h3 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a>store.dispatch()</h3><p>store.dispatch()是view发出Action的唯一方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">const store = createStore(fn)</span><br><span class="line"></span><br><span class="line"> store.dispatch(&#123;</span><br><span class="line">     type: &apos;ADD_TODO&apos;,</span><br><span class="line">     payload: &apos;Learn Redux&apos;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><p> 结合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(addTodo(&apos;Learn Redux&apos;))</span><br></pre></td></tr></table></figure></p><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会有变化。这种 State 的计算过程叫做 Reducer<br>是一个函数，它能接受 Action 和 当前 State 作为参数，返回新的 State。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const reducer = function(action, state) &#123;</span><br><span class="line">  return newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>store.dispatch 会触发reducer自动执行，做法就是在生成store的时候，将reducer传入createStore方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(reducer);</span><br></pre></td></tr></table></figure></p><h3 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a>store.subscribe()</h3><p>Store 允许使用 store.subcribe() 设置为监听函数，一旦 State 发生变化，就自动执行这个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">const store = createStore(reducer);</span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure></p><p>只要把view的更新函数放入listener，就会实现view的自动渲染。</p><p>store.subscribe 方法返回一个函数，调用这个函数就可以解除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let unsubscribe = store.subscribe(() =&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line"> )</span><br><span class="line">unsubscribe()</span><br></pre></td></tr></table></figure></p><h3 id="Store-的实现"><a href="#Store-的实现" class="headerlink" title="Store 的实现"></a>Store 的实现</h3><p>提供了三个方法</p><ul><li>store.getState()</li><li>store.dispatch()</li><li>store.subscrobe()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">let &#123; getState, dispatch, subscribe &#125; = createStore(reducer);</span><br></pre></td></tr></table></figure></li></ul><h3 id="Reducer-拆分"><a href="#Reducer-拆分" class="headerlink" title="Reducer 拆分"></a>Reducer 拆分</h3><p>Redux 提供了 combineReducers 方法拆分 Reducer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">const reduer = combineReducers(&#123;</span><br><span class="line">  a: doSomethingsWidthA,</span><br><span class="line">  b: processB,</span><br><span class="line">  c: c</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>把子reducer放在一个文件里，然后统一引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class="line">import * as reducers from &apos;./reducers&apos;</span><br><span class="line">const reducer = combineReducers(reducers)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Store&quot;&gt;&lt;a href=&quot;#Store&quot; class=&quot;headerlink&quot; title=&quot;Store&quot;&gt;&lt;/a&gt;Store&lt;/h3&gt;&lt;p&gt;Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。&lt;br&gt;Redux 提供createStore这个函数，用来生成 Store。&lt;br&gt;
    
    </summary>
    
    
      <category term="redux" scheme="http://lengziyu.cn/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>nodejs fs模块的使用</title>
    <link href="http://lengziyu.cn/2016/11/17/node-use-fs-modules/"/>
    <id>http://lengziyu.cn/2016/11/17/node-use-fs-modules/</id>
    <published>2016-11-17T13:26:19.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>fs是nodejs的文件系统，使用方法均有异步和同步版本，建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。使用fs模块可以轻松地对文件/文件夹进行操作。<br><a id="more"></a></p><h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p>创建 test.txt 文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blog.lengziyu.com</span><br><span class="line">文件读取test</span><br></pre></td></tr></table></figure></p><p>创建 file.js 文件, 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">// 异步读取</span><br><span class="line">fs.readFile(&apos;input.txt&apos;, function (err, data) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;异步读取: &quot; + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 同步读取</span><br><span class="line">var data = fs.readFileSync(&apos;input.txt&apos;);</span><br><span class="line">console.log(&quot;同步读取: &quot; + data.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.open(path, flags[, mode], callback)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>path - 文件的路径。</li><li>flags - 文件打开的行为。具体值详见下文。</li><li>mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li><li>callback - 回调函数，带有两个参数如：callback(err, fd)。</li></ul><p><strong>例子</strong><br>接下来我们创建 file.js 文件，并打开 test.txt 文件进行读写，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">// 异步打开文件</span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">  console.log(&quot;文件打开成功！&quot;);     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.stat(path, callback)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>path - 文件路径。</li><li>callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。</li></ul><p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.stat(&apos;test.txt&apos;, function (err, stats) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(stats);</span><br><span class="line">   console.log(&quot;读取文件信息成功！&quot;);</span><br><span class="line"></span><br><span class="line">   // 检测文件类型</span><br><span class="line">   console.log(&quot;是否为文件(isFile) ? &quot; + stats.isFile());</span><br><span class="line">   console.log(&quot;是否为目录(isDirectory) ? &quot; + stats.isDirectory());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(filename, data[, options], callback)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>path - 文件路径。</li><li>data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。</li><li>options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</li><li>callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li></ul><p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备写入文件&quot;);</span><br><span class="line">fs.writeFile(&apos;test.txt&apos;, &apos;我是通过写入的文件内容！&apos;,  function(err) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;数据写入成功！&quot;);</span><br><span class="line">   console.log(&quot;--------我是分割线-------------&quot;)</span><br><span class="line">   console.log(&quot;读取写入的数据！&quot;);</span><br><span class="line">   fs.readFile(&apos;test.txt&apos;, function (err, data) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">         return console.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&quot;异步读取文件数据: &quot; + data.toString());</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.read(fd, buffer, offset, length, position, callback)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>fd - 通过 fs.open() 方法返回的文件描述符。</li><li>buffer - 数据写入的缓冲区。</li><li>offset - 缓冲区写入的写入偏移量。</li><li>length - 要从文件中读取的字节数。</li><li>position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li><li>callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li></ul><p><strong>例子</strong><br>test.txt 文件内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.lengziyu.com</span><br></pre></td></tr></table></figure></p><p>接下来我们创建 file.js 文件，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line">var buf = new Buffer(1024);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开已存在的文件！&quot;);</span><br><span class="line">fs.open(&apos;test.txt&apos;, &apos;r+&apos;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件打开成功！&quot;);</span><br><span class="line">   console.log(&quot;准备读取文件：&quot;);</span><br><span class="line">   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class="line">      if (err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(bytes + &quot;  字节被读取&quot;);</span><br><span class="line"></span><br><span class="line">      // 仅输出读取的字节</span><br><span class="line">      if(bytes &gt; 0)&#123;</span><br><span class="line">         console.log(buf.slice(0, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.unlink(path, callback)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>path - 文件路径。</li><li>callback - 回调函数，没有参数。</li></ul><p><strong>例子</strong><br>test.txt 文件内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.lengziyu.com</span><br></pre></td></tr></table></figure></p><p>接下来我们创建 file.js 文件，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备删除文件！&quot;);</span><br><span class="line">fs.unlink(&apos;test.txt&apos;, function(err) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件删除成功！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>再去查看 test.txt 文件，发现已经不存在了。</p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(path[, mode], callback)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>path - 文件路径。</li><li>mode - 设置目录权限，默认为 0777。</li><li>callback - 回调函数，没有参数。</li></ul><p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;创建目录 /test/&quot;);</span><br><span class="line">fs.mkdir(&quot;/test/&quot;,function(err)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;目录创建成功。&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(path, callback)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>path - 文件路径。</li><li>callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</li></ul><p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;查看 /test 目录&quot;);</span><br><span class="line">fs.readdir(&quot;/test/&quot;,function(err, files)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   files.forEach( function (file)&#123;</span><br><span class="line">       console.log( file );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.rmdir(path, callback)</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li>path - 文件路径。</li><li>callback - 回调函数，没有参数。</li></ul><p><strong>例子</strong><br>接下来我们创建 file.js 文件，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备删除目录 /tmp/test&quot;);</span><br><span class="line">fs.rmdir(&quot;/tmp/test&quot;,function(err)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;读取 /tmp 目录&quot;);</span><br><span class="line">   fs.readdir(&quot;/tmp/&quot;,function(err, files)&#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">          return console.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      files.forEach( function (file)&#123;</span><br><span class="line">          console.log( file );</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>更多内容，请查看官网文件模块描述：<a href="https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback" target="_blank" rel="noopener">File System</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fs是nodejs的文件系统，使用方法均有异步和同步版本，建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。使用fs模块可以轻松地对文件/文件夹进行操作。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://lengziyu.cn/categories/node/"/>
    
    
      <category term="node" scheme="http://lengziyu.cn/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 学习笔记</title>
    <link href="http://lengziyu.cn/2016/11/05/MongoDB-learn-note/"/>
    <id>http://lengziyu.cn/2016/11/05/MongoDB-learn-note/</id>
    <published>2016-11-05T09:15:25.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>简介：MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br><a id="more"></a></p><h2 id="常用shell"><a href="#常用shell" class="headerlink" title="常用shell"></a>常用shell</h2><p>开启服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ net start MongoDB</span><br></pre></td></tr></table></figure></p><p>停止服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ net stop MongoDB</span><br></pre></td></tr></table></figure></p><p>删除服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &quot;D:\MongoDB\bin\Server\3.2\mongod.exe&quot; --remove</span><br></pre></td></tr></table></figure></p><h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><p>命令用于查看当前操作的文档（数据库）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; db          //显示当前数据库对象或集合</span><br><span class="line">&gt; show dbs     //显示所有数据的列表</span><br><span class="line">&gt; use test    //运行&quot;use&quot;命令，可以连接到一个指定的数据库，这里连接到test数据库，如果连接的不存在，则自动新建</span><br><span class="line">&gt; db.runoob.insert(&#123;&quot;name&quot;:&quot;lengziyu&quot;&#125;) //向 runoob 数据库插入一些数据</span><br><span class="line">&gt; db.dropDatabase()   //删除当前数据库</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介：MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。旨在为WEB应用提供可扩展的高性能数据存储解决方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://lengziyu.cn/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>在win7上安装MongoDB</title>
    <link href="http://lengziyu.cn/2016/11/05/MongoDB-install-for-windows/"/>
    <id>http://lengziyu.cn/2016/11/05/MongoDB-install-for-windows/</id>
    <published>2016-11-05T09:14:45.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近用了一星期linux，感觉需要学习一门后端语言和一个数据库。暂时选定nodejs和MongoDB。<br><a id="more"></a></p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>官网下载地址：<a href="https://www.mongodb.com/download-center#community" target="_blank" rel="noopener">https://www.mongodb.com/download-center#community</a><br>老是提示下载不了，附百度云盘下载：<a href="http://pan.baidu.com/s/1c2KFwGC" target="_blank" rel="noopener">http://pan.baidu.com/s/1c2KFwGC</a> 密码:7vu0<br>安装过程中我选择<code>D:\MongoDB</code>安装目录，傻瓜式安装完成。</p><p><strong>打开管理员命令提示</strong><br>需要通过管理员模式的命令提示符，来执行安装命令。<br>管理员打开cmd输入以下命令：<br>在MongoDB文件下创建<code>data\db</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir D:\MongoDB\data\db</span><br></pre></td></tr></table></figure></p><p>MongoDB需要数据目录来存储所有的数据，其默认的数据目录为<code>\data\db</code> ，可以通过mongod.exe –dbpath命令来指定MongoDB的数据目录。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\MongoDB\Server\3.2\bin\mongod.exe --dbpath D:\MongoDB\data\db</span><br></pre></td></tr></table></figure></p><p>看到上面的提示底部出现waiting for connections 字样，则表示dbpath配置完成，且MongoDB启动成功。<br>而且此时打开资源管理器，进入MongoDB的dbpath目录，可以看见本地确实初始化数据库了。</p><h2 id="运行MongoDB"><a href="#运行MongoDB" class="headerlink" title="运行MongoDB"></a>运行MongoDB</h2><p>通过运行mongo.exe启动MongoDB。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\MongoDB\Server\3.2\bin\mongo.exe</span><br></pre></td></tr></table></figure></p><p>命令行窗口显示如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files</span><br><span class="line">MongoDB shell version: 3.2.10</span><br><span class="line">commecting to: test</span><br></pre></td></tr></table></figure></p><p>窗口中可以看到当前MongoDB shell的版本，及此时连接的数据库。</p><h2 id="设置全局path变量"><a href="#设置全局path变量" class="headerlink" title="设置全局path变量"></a>设置全局path变量</h2><p>在计算机右键 ==&gt; 属性 ==&gt; 高级系统设置 ==&gt; 环境变量 ==&gt; 选择Path编辑 ==&gt;<br>在最后面加<code>;</code>然后添加你安装的路径:<code>D:\MongoDB\Server\3.2\bin\mongo.exe</code><br>确定保存。<br>然后在cmd上输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure></p><p>此时会出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-11-05T17:42:53.821+0800 I CONTROL  [main] Hotfix KB2731284 or later update is not installed, will zero-out data files</span><br><span class="line">MongoDB shell version: 3.2.10</span><br><span class="line">connecting to: test</span><br></pre></td></tr></table></figure></p><p>恭喜你，说明安装完成！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用了一星期linux，感觉需要学习一门后端语言和一个数据库。暂时选定nodejs和MongoDB。&lt;br&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://lengziyu.cn/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 服务器上安装 node [搭建内部npm]</title>
    <link href="http://lengziyu.cn/2016/11/03/linux-nodejs/"/>
    <id>http://lengziyu.cn/2016/11/03/linux-nodejs/</id>
    <published>2016-11-03T12:37:40.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周的工作任务是在 Linux 上搭建私人内部 npm，虽然网上很多教程，但是很多我缺踩了很多未知的坑，以此记录一下。<br><a id="more"></a><br><strong>搭建私人npm大概有一下方法：</strong></p><ul><li>用 <a href="https://github.com/rlidwka/sinopia" target="_blank" rel="noopener">sinopia</a> 安装；</li><li>淘宝  <a href="https://github.com/cnpm/cnpmjs.org" target="_blank" rel="noopener">cnpm</a> 安装。</li></ul><p><code>cnpm</code> 涉及到数据库mysql，弃之。</p><h2 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 node</h2><p>因为我的linux服务器无法连接外网，所以只能先连接外网下载好<a href="https://nodejs.org/dist/latest-v4.x/" target="_blank" rel="noopener">node</a>源码，然后再用sftp上传到服务器上，这里我下载的是：node-v4.6.1-linux-x64.tar.gz。<br>上传成功后，cd到该目录下，进行解压，并且cd进去：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar xvf node-v4.6.1-linux-x64.tar.gz</span><br><span class="line"><span class="meta">$</span> cd node-v4.6.1-linux-x64</span><br></pre></td></tr></table></figure></p><p>安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure></p><p>测试是否安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/node -v</span><br></pre></td></tr></table></figure></p><p>此时成功的话会出现4.6.1。<br>接下来设置为全局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/node-v4.6.1-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /home/node-v4.6.1-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></p><p>这里/home/这个路径是你自己放的，你将node文件解压到哪里就是哪里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure></p><p>出现4.6.1，OK。此时设置全局完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的工作任务是在 Linux 上搭建私人内部 npm，虽然网上很多教程，但是很多我缺踩了很多未知的坑，以此记录一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://lengziyu.cn/tags/linux/"/>
    
      <category term="node" scheme="http://lengziyu.cn/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>fetch 学习笔记</title>
    <link href="http://lengziyu.cn/2016/10/23/ajax-to-fetch/"/>
    <id>http://lengziyu.cn/2016/10/23/ajax-to-fetch/</id>
    <published>2016-10-23T11:58:14.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install whatwg-fetch --save</span><br></pre></td></tr></table></figure></p><p>如果你项目在node.js环境运行，可以使用 <a href="https://github.com/bitinn/node-fetch" target="_blank" rel="noopener">node-fetch</a>.</p><p>对于 babel 和 es2015+，可以这样导入 fetch：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;whatwg-fetch&apos;;</span><br><span class="line">fetch(...);</span><br></pre></td></tr></table></figure></p><h2 id="兼容性及解决方案"><a href="#兼容性及解决方案" class="headerlink" title="兼容性及解决方案"></a>兼容性及解决方案</h2><p>原生支持率并不高，幸运的是，引入下面这些 <code>polyfill</code> 后可以完美支持 IE8+ ：</p><ul><li>由于 IE8 是 ES3，需要引入 ES5 的 <code>polyfill</code>: <code>es5-shim</code>, <code>es5-sham</code>；</li><li>引入 Promise 的 <code>polyfill</code>: <code>es6-promise</code>；</li><li>引入 fetch 探测库：fetch-detector；</li><li>引入 fetch 的 polyfill: fetch-ie8；</li><li>可选：如果你还使用了 jsonp，引入 fetch-jsonp；</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>fetch 支持 HTTP 方法，下面主要用例子讲解 POST 和 GET 的请求。<br><strong>HTML 请求：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;/users.html&apos;)</span><br><span class="line">  .then(function(response) &#123;</span><br><span class="line">    return response.text()</span><br><span class="line">  &#125;).then(function(body) &#123;</span><br><span class="line">    document.body.innerHTML = body</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p><strong>JSON 请求：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;/users.json&apos;)</span><br><span class="line">  .then(function(response) &#123;</span><br><span class="line">    return response.json()</span><br><span class="line">  &#125;).then(function(json) &#123;</span><br><span class="line">    console.log(&apos;parsed json&apos;, json)</span><br><span class="line">  &#125;).catch(function(ex) &#123;</span><br><span class="line">    console.log(&apos;parsing failed&apos;, ex)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p><strong>响应头设置：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;/users.json&apos;).then(function(response) &#123;</span><br><span class="line">  console.log(response.headers.get(&apos;Content-Type&apos;))</span><br><span class="line">  console.log(response.headers.get(&apos;Date&apos;))</span><br><span class="line">  console.log(response.status)</span><br><span class="line">  console.log(response.statusText)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>Post 表单提交：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var form = document.querySelector(&apos;form&apos;)</span><br><span class="line"></span><br><span class="line">fetch(&apos;/users&apos;, &#123;</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  body: new FormData(form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>Post JSON：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;/users&apos;, &#123;</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  body: JSON.stringify(&#123;</span><br><span class="line">    name: &apos;Hubot&apos;,</span><br><span class="line">    login: &apos;hubot&apos;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>上传文件：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var input = document.querySelector(&apos;input[type=&quot;file&quot;]&apos;)</span><br><span class="line"></span><br><span class="line">var data = new FormData()</span><br><span class="line">data.append(&apos;file&apos;, input.files[0])</span><br><span class="line">data.append(&apos;user&apos;, &apos;hubot&apos;)</span><br><span class="line"></span><br><span class="line">fetch(&apos;/avatars&apos;, &#123;</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  body: data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="使用注意："><a href="#使用注意：" class="headerlink" title="使用注意："></a>使用注意：</h2><ul><li>Fetch 请求默认是不带 cookie 的，需要设置 <code>fetch(url, {credentials: &#39;include&#39;})</code></li><li>服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。&lt;br&gt;
    
    </summary>
    
      <category term="fetch" scheme="http://lengziyu.cn/categories/fetch/"/>
    
    
      <category term="fetch" scheme="http://lengziyu.cn/tags/fetch/"/>
    
  </entry>
  
  <entry>
    <title>React 操作真实 DOM</title>
    <link href="http://lengziyu.cn/2016/10/20/react-use-dmo-refs/"/>
    <id>http://lengziyu.cn/2016/10/20/react-use-dmo-refs/</id>
    <published>2016-10-20T12:18:07.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>React中的每一个组件都是一个状态机，通常情况下，我们通过设置组件的状态就可以完成UI的更新，但是在某些情况下确实需要直接操作DOM。<br><a id="more"></a><br>React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。</p><ul><li>ref : 绑定属性</li><li>refs : 调用的时候使用</li></ul><h2 id="获取DOM实例"><a href="#获取DOM实例" class="headerlink" title="获取DOM实例"></a>获取DOM实例</h2><p>通过ref属性，你可获取实例中的属性方法，甚至可以通过他获取到DOM实例节点 <code>this.refs.xx.getDOMNode()</code></p><p><strong>ref 属性绑定</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p><strong>refs 获取DOM实例</strong><br>获取支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输入框获取焦点</span><br><span class="line">this.refs.myInput.focus()</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class MyComponent extends Component &#123;</span><br><span class="line">  handleClick()&#123;</span><br><span class="line">    this.refs.myInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&quot;myInput&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;点我输入框获取焦点&quot;</span><br><span class="line">          onClick=&#123;this.handleClick.bind(this)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyComponent/&gt;,</span><br><span class="line">  document.querySelector(&apos;#app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>获取<code>myInput</code>真实DOM的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myInput = this.refs.myInput.props.value;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React中的每一个组件都是一个状态机，通常情况下，我们通过设置组件的状态就可以完成UI的更新，但是在某些情况下确实需要直接操作DOM。&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="http://lengziyu.cn/categories/react/"/>
    
    
      <category term="react" scheme="http://lengziyu.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 笔记之 表单</title>
    <link href="http://lengziyu.cn/2016/10/18/react-to-biaodan/"/>
    <id>http://lengziyu.cn/2016/10/18/react-to-biaodan/</id>
    <published>2016-10-18T13:48:08.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>诸如： <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;option&gt;</code> 这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。<br><a id="more"></a></p><h2 id="交互属性"><a href="#交互属性" class="headerlink" title="交互属性"></a>交互属性</h2><p>在 HTML 中<code>&lt;textarea&gt;</code>的值通过子节点设置；在 React 中则应该使用 value 代替。<br>表单组件可以通过onChange回调函数来监听组件变化。当用户做出以下交互时,onChange执行并通过浏览器做出响应：</p><ul><li><code>&lt;input&gt;</code>或 <code>&lt;textarea&gt;</code> 的 <code>value</code> 发生变化时。</li><li><code>&lt;input&gt;</code>的 <code>checked</code> 状态改变时。</li><li><code>&lt;option&gt;</code> 的 <code>selected</code> 状态改变时。<br>和所有 DOM 事件一样，所有的 HTML 原生组件都支持 onChange 属性，而且可以用来监听冒泡的 change 事件.</li></ul><div class="tip"><br>对于<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>，onChange应当被用于取代DOM内置的onInput事件处理<br></div><h2 id="不可控组件和可控组件"><a href="#不可控组件和可控组件" class="headerlink" title="不可控组件和可控组件"></a>不可控组件和可控组件</h2><p><strong>可控组件</strong><br>设置了 <code>value</code> 的 <code>&lt;input&gt;</code> 是一个受限组件。 对于受限的 <code>&lt;input&gt;</code>，渲染出来的 HTML 元素始终保持 <code>value</code> 属性的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: function() &#123;</span><br><span class="line">    return &lt;input type=&quot;text&quot; value=&quot;Hello!&quot;/&gt;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码将渲染出一个值为 Hello! 的 input 元素。用户在渲染出来的元素里输入任何值都不起作用，因为 React 已经赋值为 Hello!。如果想响应更新用户输入的值，就得使用 onChange 事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getInitialState: function() &#123;</span><br><span class="line">    return &#123;value: &apos;Hello!&apos;&#125;;</span><br><span class="line"> &#125;,</span><br><span class="line"> handleChange: function(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line"> &#125;,</span><br><span class="line"> render: function() &#123;</span><br><span class="line">    var value = this.state.value;</span><br><span class="line">    return &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>Default Value</strong><br>初始值是状态中的value。如果要取数据，可直接使用 <code>var inputValue = this.state.value</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: function() &#123;</span><br><span class="line">   return &lt;input type=&quot;text&quot; defaultValue=&#123;this.state.value&#125;/&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><div class="tip"><br>一个可控组件并不保持自己的原始状态；组件的呈现完全基于属性。<br></div><br><strong>实例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var Kekong = React.creatClass(&#123;</span><br><span class="line">    getInitialState:function()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            dada:&apos;shuaige&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange:function(e)&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            dada:e.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    submitHandler:function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(this.state.dada);</span><br><span class="line">    &#125;,</span><br><span class="line">    render:function()&#123;</span><br><span class="line">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; value=&#123;this.state.dada&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">            &lt;button type=&quot;submit&quot;&gt;speak&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(&lt;Kekong /&gt;,document.body);</span><br></pre></td></tr></table></figure></p><p><strong>不可控组件</strong><br>没有设置value(或者设为null) 的<code>&lt;input&gt;</code>组件是一个不可控组件。这样的话，组件中的数据和state中的数据并不对应，可以说，组件的数据不可控。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: function() &#123;</span><br><span class="line">    return &lt;input type=&quot;text&quot; /&gt;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码将渲染出一个空值的输入框，用户输入将立即反应到元素上。和受限元素一样，使用 onChange 事件可以监听值的变化。<br><strong>Default Value</strong><br>如果想给组件设置一个非空的初始值，可以使用 defaultValue 属性。 数据在这里并没有存贮在状态中，而是写在input中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: function() &#123;</span><br><span class="line">   return &lt;input type=&quot;text&quot; defaultValue=&quot;Hello!&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要拿到input中的value，需先拿到其DOM节点，然后获取其value值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var inputValue = React.findDOMNode(this.refs.input).value</span><br></pre></td></tr></table></figure></p><p>上面的代码渲染出来的元素和受限组件一样有一个初始值，但这个值用户可以改变并会反应到界面上。<br>同样，<code>&lt;input type=&quot;checkbox&quot;&gt;</code>和<code>&lt;input type=&quot;radio&quot;&gt;</code>支持defaultChecked属性，<code>&lt;select&gt;</code>支持设置defaultValue。<br><code>defaultValue</code>和<code>defaultChecked</code>属性只能在初始的render函数中使用，如果你要在随后的render函数中更新value值，你需要使用可控组件。</p><p><strong>实例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var UnKekong = React.creatClass(&#123;</span><br><span class="line">    submitHandler:function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        var helloUnke = React.findDOMNode(this.refs.helloUnke).value;</span><br><span class="line">        alert(helloUnke);</span><br><span class="line">    &#125;,</span><br><span class="line">    render:function()&#123;</span><br><span class="line">        return &lt;form onsubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class="line">            &lt;input ref=&quot;helloUnke&quot; type=&quot;text&quot; defaultValue=&quot;Dada shuaige&quot; /&gt;</span><br><span class="line">            &lt;button type=&quot;submit&quot;&gt;speak&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">React.render(&lt;Unkekong /&gt;,document.body);</span><br></pre></td></tr></table></figure></p><p><strong>Checkbox和Radio的潜在问题</strong></p><p><div class="tip"><br>注意，在试图改变正常处理Checkbox和Radio input时，React用一个click事件来代替change事件。大多数情况下，这种行为与预期相同，除了调用preventDefault时。preventDefault从视觉上阻止浏览器更新input，即使checked被触发。它可以在移除调用preventDefault与用setTimeout来切换checked中起作用。<br></div><br><strong>Why use Controlled Components</strong><br>组件可控的优点：</p><ul><li>符合React的数据流，单向数据流，从state流向render输出的结果。</li><li>数据存贮在state中，便于使用。</li><li>便于对数据进行处理</li></ul><h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><ul><li><code>&lt;label htmlFor=&quot;name&quot;&gt;Name&lt;/label&gt;</code></li><li>要注意for是js关键字，要写成htmlFor。具体JSX语法在之间笔记中有介绍，传送门：React.js学习笔记之JSX解读。现在多数提示用input的placeholder属性替代。</li><li><code>&lt;input type=&quot;&quot; onChange={this.handleChange}/&gt;</code></li><li><code>&lt;textarea onChange={this.handleChange}/&gt;</code></li><li><code>&lt;select onChange={this.handleChange}&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt;</code></li></ul><p><strong>实例</strong><br><a href="https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3" target="_blank" rel="noopener">这是一个demo传送门</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var MyForm = React.createClass(&#123;</span><br><span class="line">getInitialState:function()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        username:&apos;&apos;,</span><br><span class="line">        gender:&apos;man&apos;,</span><br><span class="line">        checked:true</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">handleUsernameChange:function(e)&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        username:e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">handlerGenderChange:function(e)&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        gender:e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">handleCheckedChange:function(e)&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        checked:e.target.checked</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">submitHandler:function (e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(this.state);</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class="line">        &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; onChange=&#123;this.handleUsernameChange&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;select onChange=&#123;this.handlerGenderChange&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class="line">            &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class="line">        &lt;/select&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleCheckedChange&#125; id=&quot;checkbox&quot;/&gt;</span><br><span class="line">        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p><h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChange=&#123;this.handleChange&#125;</span><br></pre></td></tr></table></figure><p>若有多个元素要运用事件处理函数，常规的方法是编写多个onChange事件。这么写的话会导致代码维护比较困难并且也非常冗余。更好的做法是把事件处理函数编写为一个。可以采用bind复用和name复用这两种方法。</p><p><strong>bind复用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleChange:function(name,event)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">onChagne=&#123;this.handleChange.bind(this,&apos;input&apos;)&#125;</span><br></pre></td></tr></table></figure></p><p>书写简单，但需要对bind()机制熟悉，性能相对要好。</p><p><strong>实例</strong><br><a href="https://github.com/Xiaoxianrou/Blog/tree/master/2016.03/React-Demo/demo3" target="_blank" rel="noopener">这是一个demo传送门</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var MyForm = React.createClass(&#123;</span><br><span class="line">    getInitialState:function()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            username:&apos;&apos;,</span><br><span class="line">            gender:&apos;man&apos;,</span><br><span class="line">            checked:true</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange:function(name,event)&#123;</span><br><span class="line">        var newState=&#123;&#125;;</span><br><span class="line">        newState[name]=name==&quot;checked&quot;?event.target.checked:event.target.value;</span><br><span class="line">        this.setState(newState);</span><br><span class="line">    &#125;,</span><br><span class="line">    submitHandler:function (e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        console.log(this.state);</span><br><span class="line">    &#125;,</span><br><span class="line">    render:function () &#123;</span><br><span class="line">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class="line">            &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; onChange=&#123;this.handleChange.bind(this,&quot;username&quot;)&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;select onChange=&#123;this.handleChange.bind(this,&quot;gender&quot;)&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class="line">                &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class="line">                &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class="line">            &lt;/select&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange.bind(this,&quot;checked&quot;)&#125; id=&quot;checkbox&quot;/&gt;</span><br><span class="line">            &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p><p><strong>name复用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleChange:function(event)&#123;</span><br><span class="line">    var name = event.target.name</span><br><span class="line">&#125;</span><br><span class="line">onChange=&#123;this.handleChange&#125;</span><br></pre></td></tr></table></figure></p><p>相比Bind写法会少一些参数，在函数中需要读取表单的name值，需要添加name属性。</p><p><strong>实例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var MyForm = React.createClass(&#123;</span><br><span class="line">    getInitialState:function()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            username:&apos;&apos;,</span><br><span class="line">            gender:&apos;man&apos;,</span><br><span class="line">            checked:true</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange:function(event)&#123;</span><br><span class="line">        var newState=&#123;&#125;;</span><br><span class="line">        newState[event.target.name]=event.target.name==&quot;checked&quot;?event.target.checked:event.target.value;</span><br><span class="line">        this.setState(newState);</span><br><span class="line">    &#125;,</span><br><span class="line">    submitHandler:function (e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        console.log(this.state);</span><br><span class="line">    &#125;,</span><br><span class="line">    render:function () &#123;</span><br><span class="line">        return &lt;form onSubmit=&#123;this.submitHandler&#125;&gt;</span><br><span class="line">            &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; name=&quot;username&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.username&#125; id=&quot;username&quot;/&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;select name=&quot;gender&quot; onChange=&#123;this.handleChange&#125; value=&#123;this.state.gender&#125;&gt;</span><br><span class="line">                &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</span><br><span class="line">                &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</span><br><span class="line">            &lt;/select&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;label htmlFor=&quot;checkbox&quot;&gt;大大是帅哥吗&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;checkbox&quot; value=&quot;大大是帅哥&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange&#125; name=&quot;checked&quot; id=&quot;checkbox&quot;/&gt;</span><br><span class="line">            &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(&lt;MyForm /&gt;,document.getElementById(&apos;reactDemo&apos;));</span><br></pre></td></tr></table></figure></p><h2 id="自定义表单组件"><a href="#自定义表单组件" class="headerlink" title="自定义表单组件"></a>自定义表单组件</h2><p>自定义表单组件能让我们更好的使用组件，让我们更好的开发网页。</p><p><strong>why 自定义表单组件？</strong><br>自定义表单组件的原因：</p><ul><li>内因：表单本身具备特殊性：样式统一、信息内聚、行为固定</li><li>外因：本质上是组件的嵌套，组织和管理组件的一种方式</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;诸如： &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 这样的表单组件不同于其他组件，因为他们可以通过用户交互发生变化。这些组件提供的界面使响应用户交互的表单数据处理更加容易。&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="http://lengziyu.cn/categories/react/"/>
    
    
      <category term="react" scheme="http://lengziyu.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>ES6笔记之 let 和 const</title>
    <link href="http://lengziyu.cn/2016/10/17/ES6-to-let-and-const/"/>
    <id>http://lengziyu.cn/2016/10/17/ES6-to-let-and-const/</id>
    <published>2016-10-17T13:51:50.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6新增了 let 和 const 命令，用来声明变量。它的用法类似于var，却有所区别。<br><a id="more"></a></p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let声明的变量只在其所在的代码块内有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a)   //ReferenceError:a is not defined</span><br></pre></td></tr></table></figure><p><strong>let声明变量不存在变量提升</strong><br>let不像var那样会发生“变量提升”现象，所以，变量一定要在声明后使用，不然就会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)   //ReferenceError:a is not defined</span><br><span class="line">let a = 1;</span><br></pre></td></tr></table></figure><p><strong>暂时性死区</strong><br>只要块级作用域内存在let关键字，它所声明的变量就绑定这个区域，不再受外部影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 20;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    tmp = &apos;abc&apos;;    //ReferenceError:tmp is not defined</span><br><span class="line">    let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定了这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><div class="tip">ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。在语法上称为“暂时性死区(temporal dead zone,TDZ)”</div>有时候，会不经间遇到比较隐蔽的“死区”，不太容易被发现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function bar(x=y,y=2)&#123;</span><br><span class="line">    return [x,y];</span><br><span class="line">&#125;</span><br><span class="line">bar() //报错</span><br></pre></td></tr></table></figure><br><br>上面的代码中是因为参数x的默认值等于另一个参数y，而此时y还没有声明，属于死区。<br><br><strong>不允许重复声明</strong><br>let不允许在相同的作用域内声明同一个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function bar()&#123;</span><br><span class="line">    let a = 10;</span><br><span class="line">    var a = 20;</span><br><span class="line">&#125;</span><br><span class="line">//报错</span><br><span class="line"></span><br><span class="line">function bat()&#123;</span><br><span class="line">    let a = 10;</span><br><span class="line">    let a = 20;</span><br><span class="line">&#125;</span><br><span class="line">//报错</span><br></pre></td></tr></table></figure><br><br>因此，所以也不能在函数内重复声明参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function bar(args)&#123;</span><br><span class="line">    let args = 10;  </span><br><span class="line">&#125;</span><br><span class="line">bar() //报错</span><br><span class="line"></span><br><span class="line">function bar(args)&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        let args = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bar()  //不报错</span><br></pre></td></tr></table></figure><br><br><strong>块级作用域</strong><br><br>使用let和const可以实现块级作用域：<br><br>1. 外层代码块不受内层代码块的影响。<br>2. 外层作用域无法读取内层作用域的变量。<br>3. 内层作用域可以定义外层作用域的同名变量。<br><br>块级作用域的实现，使得广泛使用的自执行匿名函数(IIFE)变得不再必要了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//自执行模式</span><br><span class="line">(function()&#123;</span><br><span class="line">    var a = 10;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//块级作用域写法</span><br><span class="line">function()&#123;</span><br><span class="line">    let a = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><div class="tip">函数本身的作用域也在其所在的块级作用域之内。</div><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const用来声明常量。一旦声明，其值就不能再改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">const PI = 3  //TypeErrorL &quot;PI&quot; is read-only</span><br></pre></td></tr></table></figure></p><div class="tip">const声明的变量不得改变值，意味着 const 一旦声明常量就必须立即初始化，不能留到后面赋值。</div><br>const与let关键字一样，只在声明所在的块级作用域内有效；const关键字声明的常量也不提升，同样存在暂时性死区，只能在声明后使用。<br><div class="tip">对于复合型数据类型，常量名不指向数据，而是指向数据所在的地址。const关键字只是保证常量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须注意该点。</div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6新增了 let 和 const 命令，用来声明变量。它的用法类似于var，却有所区别。&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://lengziyu.cn/categories/es6/"/>
    
    
      <category term="es6" scheme="http://lengziyu.cn/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Yarn - Javascript 新一代套件管理</title>
    <link href="http://lengziyu.cn/2016/10/14/yarn-a-new-javascript-pkg/"/>
    <id>http://lengziyu.cn/2016/10/14/yarn-a-new-javascript-pkg/</id>
    <published>2016-10-14T15:25:51.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>日前，Facebook 发布了全新的 JS 套件管理工具 <a href="https://github.com/yarnpkg/yarn" target="_blank" rel="noopener">Yarn</a>，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。<br>在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。<br><a id="more"></a></p><h2 id="Yarn-提供一个更快更稳定的套件管理方案"><a href="#Yarn-提供一个更快更稳定的套件管理方案" class="headerlink" title="Yarn 提供一个更快更稳定的套件管理方案"></a>Yarn 提供一个更快更稳定的套件管理方案</h2><ol><li>透过 yarn.lock ，锁住套件版本，因此可以确保安装之套件在每台机器上都能保持一致。</li><li>安装过的套件，都会加入到 global cache 中，下次有砍掉要重装，或是不同资料夹要装，都可以在无网络情況底下安裝。</li><li>非常快，平行化处理每个 operation，全新的 resolving 演算法。</li></ol><h2 id="特性功能"><a href="#特性功能" class="headerlink" title="特性功能"></a>特性功能</h2><p>除了让安装过程更快更可靠，Yarn 还有额外的特性来更好地简化依赖管理的工作流。</p><ul><li>兼容 npm 和 bower 工作流，并且支持混合注册。</li><li>能够限制已安装模块的证书以及输出证书信息。</li><li>暴露一个稳定公开的JS API，通过构建工具提供抽象的日志记录。</li><li>可读、最小化、良好的命令行输出。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 以前装过 npm 再安装 yarn</span><br><span class="line">npm install -g yarn</span><br><span class="line"></span><br><span class="line">// 直接安装 (mac为例，其余官网有介绍)</span><br><span class="line">curl -o- -L https://yarnpkg.com/install.sh | bash</span><br><span class="line"></span><br><span class="line">// 一般安装 (等同 npm install)</span><br><span class="line">yarn</span><br><span class="line"></span><br><span class="line">// 安装特定套件 (等同 npm install --save)</span><br><span class="line">yarn add react         </span><br><span class="line">yarn add react@15.3.2</span><br><span class="line"></span><br><span class="line">// 更新特定套件 (等同 npm upgrade)</span><br><span class="line">yarn upgrade react</span><br><span class="line"></span><br><span class="line">// 移除特定套件 (等同 npm uninstall)</span><br><span class="line">yarn remove react</span><br><span class="line"></span><br><span class="line">// 新增 package.json</span><br><span class="line">yarn init</span><br><span class="line"></span><br><span class="line">// 新增全域套件</span><br><span class="line">yarn global add</span><br><span class="line"></span><br><span class="line">// 跑 script</span><br><span class="line">yarn run</span><br><span class="line"></span><br><span class="line">// 其他常用选项</span><br><span class="line">--offline   (离线模式，只拉 cache)</span><br><span class="line">--flat      (将套件扁平化，一個资料夹只会有一個套件)</span><br><span class="line">--dev       (加入到 devDependencies)</span><br><span class="line">--peer      (加入到 peerDependencies)</span><br><span class="line">--optional  (加入到 optionalDependencies)</span><br></pre></td></tr></table></figure><h2 id="Cheat"><a href="#Cheat" class="headerlink" title="Cheat"></a>Cheat</h2><table><thead><tr><th>NPM</th><th>YARN</th><th>说明</th></tr></thead><tbody><tr><td>npm init</td><td>yarn init</td><td>初始化某个项目</td></tr><tr><td>npm install/link</td><td>yarn install/link</td><td>默认的安装依赖操作</td></tr><tr><td>npm install taco —save</td><td>yarn add taco</td><td>安装某个依赖，并且默认保存到package.</td></tr><tr><td>npm uninstall taco —save</td><td>yarn remove taco</td><td>移除某个依赖项目</td></tr><tr><td>npm install taco —save-dev</td><td>yarn add taco —dev</td><td>安装某个开发时依赖项目</td></tr><tr><td>npm update taco —save</td><td>yarn upgrade taco</td><td>更新某个依赖项目</td></tr><tr><td>npm install taco –global</td><td>yarn global add taco</td><td>安装某个全局依赖项目</td></tr><tr><td>npm publish/login/logout</td><td>yarn publish/login/logout</td><td>发布/登录/登出，一系列NPM Registry操作</td></tr><tr><td>npm run/test</td><td>yarn run/test</td><td>运行某个命令</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://code.facebook.com/posts/1840075619545360/yarn-a-new-package-manager-for-javascript/" target="_blank" rel="noopener">Yarn: A new package manager for JavaScript</a></li><li><a href="https://blog.getexponent.com/yarn-a-new-program-for-installing-javascript-dependencies-44961956e728#.qf8fmeg4g" target="_blank" rel="noopener">Yarn: a new program for installing JavaScript dependencies</a></li><li><a href="https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc#.dcd5qeolm" target="_blank" rel="noopener">npm-vs-yarn-cheat-sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日前，Facebook 发布了全新的 JS 套件管理工具 &lt;a href=&quot;https://github.com/yarnpkg/yarn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yarn&lt;/a&gt;，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。&lt;br&gt;在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。&lt;br&gt;
    
    </summary>
    
      <category term="yarn" scheme="http://lengziyu.cn/categories/yarn/"/>
    
    
      <category term="yarn" scheme="http://lengziyu.cn/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>Redux 简明教程（转）</title>
    <link href="http://lengziyu.cn/2016/10/13/Redux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://lengziyu.cn/2016/10/13/Redux-学习笔记/</id>
    <published>2016-10-13T12:26:49.000Z</published>
    <updated>2021-04-13T06:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p><p>可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个<a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="noopener">时间旅行调试器可以编辑后实时预览</a>。<br><a id="more"></a></p><p>Redux 除了和 React 一起用外，还支持其它界面库。<br>它体小精悍（只有2kB）且没有任何依赖。</p><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性。</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>首先要区分 <code>store</code> 和 <code>state</code><br><code>state</code> 是应用的状态，一般本质上是一个普通对象<br>例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能<br>那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** 应用初始 state，本代码块记为 code-1 **/</span><br><span class="line">&#123;</span><br><span class="line">  counter: 0,</span><br><span class="line">  todos: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>store</code> 是应用状态 <code>state</code> 的管理者，包含下列四个函数：</p><ul><li>getState() # 获取整个 state</li><li>dispatch(action) # ※ 触发 state 改变的【唯一途径】※</li><li>subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener</li><li>replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用</li></ul><p>二者的关系是：<code>state = store.getState()</code><br>Redux 规定，一个应用只应有一个单一的 <code>store</code>，其管理着唯一的应用状态 <code>state</code><br>Redux 还规定，不能直接修改应用的状态 <code>state</code>，也就是说，下面的行为是不允许的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var state = store.getState()</span><br><span class="line">state.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state</span><br></pre></td></tr></table></figure><p>若要改变 <code>state</code>，必须 <code>dispatch</code> 一个 <code>action</code>，这是修改应用状态的不二法门</p><div class="tip"><br>现在您只需要记住 action 只是一个包含 type 属性的普通对象即可<br>例如 { type: ‘INCREMENT’ }<br></div><br>上面提到，<code>state</code> 是通过 <code>store.getState()</code> 获取，那么 <code>store</code> 又是怎么来的呢？<br>想生成一个 <code>store</code>，我们需要调用 Redux 的 <code>createStore</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;</span><br><span class="line">...</span><br><span class="line">const store = createStore(reducer, initialState) // store 是靠传入 reducer 生成的哦！</span><br></pre></td></tr></table></figure><br><br><div class="tip"><br>现在您只需要记住 reducer 是一个 函数，负责更新并返回一个新的 state<br>而 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染）<br></div><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>上面提到，<code>action</code>（动作）实质上是包含 <code>type</code> 属性的普通对象，这个 <code>type</code> 是我们实现用户行为追踪的关键<br>例如，增加一个待办事项 的 <code>action</code> 可能是像下面一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** 本代码块记为 code-2 **/</span><br><span class="line">&#123;</span><br><span class="line">  type: &apos;ADD_TODO&apos;,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    content: &apos;待办事项1&apos;,</span><br><span class="line">    completed: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了<br>也就是说，下面这些 action 都是合法的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** 如下都是合法的，但就是不够规范 **/</span><br><span class="line">&#123;</span><br><span class="line">  type: &apos;ADD_TODO&apos;,</span><br><span class="line">  id: 1,</span><br><span class="line">  content: &apos;待办事项1&apos;,</span><br><span class="line">  completed: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: &apos;ADD_TODO&apos;,</span><br><span class="line">  abcdefg: &#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    content: &apos;待办事项1&apos;,</span><br><span class="line">    completed: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>虽说没有约束，但最好还是遵循<a href="https://github.com/acdlite/flux-standard-action" target="_blank" rel="noopener">规范</a></strong><br>如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** 本代码块记为 code-3 **/</span><br><span class="line">&#123;</span><br><span class="line">  counter: 0,</span><br><span class="line">  todos: [&#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    content: &apos;待办事项1&apos;,</span><br><span class="line">    completed: false</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>刨根问底，action 是谁生成的呢？</p><h2 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a>Action Creator</h2><p><div class="tip"><br>Action Creator 可以是同步的，也可以是异步的<br></div><br>顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）<br>例如下面就是一个 “新增一个待办事项” 的 Action Creator：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** 本代码块记为 code-4 **/</span><br><span class="line">var id = 1</span><br><span class="line">function addTodo(content) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &apos;ADD_TODO&apos;,</span><br><span class="line">    payload: &#123;</span><br><span class="line">      id: id++,</span><br><span class="line">      content: content, // 待办事项内容</span><br><span class="line">      completed: false  // 是否完成的标识</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;--! 本代码块记为 code-5 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;todoInput&quot; /&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123;</span><br><span class="line">  var content = $(&apos;#todoInput&apos;).val() // 获取输入框的值</span><br><span class="line">  var action = addTodo(content) // 执行 Action Creator 获得 action</span><br><span class="line">  store.dispatch(action) // 改变 state 的不二法门：dispatch 一个 action！！！</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** 本代码块记为 code-6 **/</span><br><span class="line">&#123;</span><br><span class="line">  counter: 0,</span><br><span class="line">  todos: [&#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    content: &apos;待办事项1&apos;,</span><br><span class="line">    completed: false</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    id: 2,</span><br><span class="line">    content: &apos;待办事项2&apos;,</span><br><span class="line">    completed: false</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action)</strong><br>刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，<br>Redux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？<br>又是谁负责“写入”的呢？悬念即将揭晓…</p><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p><strong>Reducer 必须是同步的纯函数</strong><br>用户每次 dispatch(action) 后，都会触发 reducer 的执行<br>reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState<br>最后会用 reducer 的返回值 nextState 完全替换掉原来的 state</p><p><div class="tip"><br>注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改<br>Redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作<br>例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ … 等返回副本的函数<br></div><br>在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/** 本代码块记为 code-7 **/</span><br><span class="line">var initState = &#123;</span><br><span class="line">  counter: 0,</span><br><span class="line">  todos: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※</span><br><span class="line">  if (!state) state = initState</span><br><span class="line"></span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &apos;ADD_TODO&apos;:</span><br><span class="line">      var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆</span><br><span class="line">      nextState.todos.push(action.payload)</span><br><span class="line">      return nextState</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">    // 由于 nextState 会把原 state 整个替换掉</span><br><span class="line">    // 若无修改，必须返回原 state（否则就是 undefined）</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通俗点讲，就是 reducer 返回啥，state 就被替换成啥</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>store 由 Redux 的 createStore(reducer) 生成</li><li>state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象</li><li>action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生</li><li>改变 state 必须 dispatch 一个 action</li><li>reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数</li><li>reducer 必须返回值，否则 nextState 即为 undefined</li><li>实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单）</li></ul><p><strong>Action Creator =&gt; action =&gt; store.dispatch(action) =&gt; reducer(state, action) =&gt; 原 state state = nextState</strong></p><p>原文地址：<a href="https://github.com/kenberkeley/redux-simple-tutorial" target="_blank" rel="noopener">Redux 简明教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redux 是 JavaScript 状态容器，提供可预测化的状态管理。&lt;/p&gt;
&lt;p&gt;可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;时间旅行调试器可以编辑后实时预览&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="redux" scheme="http://lengziyu.cn/categories/redux/"/>
    
    
      <category term="redux" scheme="http://lengziyu.cn/tags/redux/"/>
    
  </entry>
  
</feed>
