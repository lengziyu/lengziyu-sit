<!DOCTYPE HTML>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="冷子欲-喜欢折腾的前端er">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/blog/">
    <link rel="dns-prefetch" href="http://lengziyu.cn">
    <!--SEO-->

    <meta name="keywords" content="Vue,SEO,Phantomjs">


    <meta name="description" content="前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。

1.SSR服务器渲染；
2.静...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>基于Vue SEO的四种方案 | 冷子欲-喜欢折腾的前端er</title>


    <link rel="alternate" href="/atom.xml" title="冷子欲-喜欢折腾的前端er" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/blog/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/blog/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/blog/css/style.css?rev=@@hash">




    



    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?6df3e7dd5bb844afb79fcf7c69c0a58f";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(/blog/./img/bg.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='lengziyu'>
            <img src="/blog/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/blog/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://lengziyu.cn">冷子欲-喜欢折腾的前端er</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/categories/vue/"><i class="fa "></i>vue</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/blog/about"><i class="fa "></i>关于我</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="基于Vue SEO的四种方案">
            
	            基于Vue SEO的四种方案
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/blog/categories/Vue/">Vue</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/blog/tags/Phantomjs/">Phantomjs</a> <a class="tag-link" href="/blog/tags/SEO/">SEO</a> <a class="tag-link" href="/blog/tags/Vue/">Vue</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/06/30</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <p>前言：众所周知，Vue SPA单页面应用对SEO不友好，当然也有相应的解决方案，下面列出几种最近研究和使用过的SEO方案，SSR和静态化基于Nuxt.js来说。</p>
<ul>
<li>1.SSR服务器渲染；</li>
<li>2.静态化；</li>
<li>3.预渲染prerender-spa-plugin；</li>
<li>4.使用Phantomjs针对爬虫做处理。</li>
</ul>
<h2 id="1-SSR服务器渲染"><a href="#1-SSR服务器渲染" class="headerlink" title="1.SSR服务器渲染"></a>1.SSR服务器渲染</h2><p>关于服务器渲染：<a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F" target="_blank" rel="noopener">Vue官网介绍</a>，对Vue版本有要求，对服务器也有一定要求，需要支持nodejs环境。</p>
<p><strong>使用SSR权衡之处：</strong></p>
<ul>
<li>开发条件所限，浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行；</li>
<li>环境和部署要求更高，需要Node.js server 运行环境；</li>
<li>高流量的情况下，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；</li>
<li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</li>
</ul>
<p><strong>不足：（开发中遇到的坑）</strong><br>1.一套代码两套执行环境，会引起各种问题，比如服务端没有window、document对象，处理方式是增加判断，如果是客户端才执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(process.browser)&#123;</span><br><span class="line"> console.log(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>引用npm包，带有dom操作的，例如：<code>wowjs</code>，不能用<code>import</code>的方式，改用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (process.browser) &#123;</span><br><span class="line">     var &#123; WOW &#125; = require(&apos;wowjs&apos;);</span><br><span class="line">     require(&apos;wowjs/css/libs/animate.css&apos;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.Nuxt asyncData方法，初始化页面前先得到数据，但仅限于<strong>页面组件</strong>调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 并发加载多个接口：</span><br><span class="line">  async asyncData (&#123; app, query &#125;) &#123;</span><br><span class="line">    let [resA, resB, resC] = await Promise.all([</span><br><span class="line">      app.$axios.get(&apos;/api/a&apos;),</span><br><span class="line">      app.$axios.get(&apos;/api/b&apos;),</span><br><span class="line">      app.$axios.get(&apos;/api/c&apos;),</span><br><span class="line">     ])</span><br><span class="line"></span><br><span class="line">     return &#123;</span><br><span class="line">       dataA: resA.data,</span><br><span class="line">       dataB: resB.data,</span><br><span class="line">       dataC: resC.data,</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在asyncData中获取参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.获取动态路由参数，如：</span><br><span class="line"></span><br><span class="line">/list/:id&apos; ==&gt;  &apos;/list/123</span><br><span class="line"></span><br><span class="line">接收：</span><br><span class="line"></span><br><span class="line">async asyncData (&#123; app, query &#125;) &#123;</span><br><span class="line">  console.log(app.context.params.id) //123</span><br><span class="line">&#125;</span><br><span class="line">2.获取url?获取参数，如：</span><br><span class="line"></span><br><span class="line">/list?id=123</span><br><span class="line"></span><br><span class="line">接收：</span><br><span class="line"></span><br><span class="line">async asyncData (&#123; app, query &#125;) &#123;</span><br><span class="line">  console.log(query.id) //123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.如果你使用<code>v-if</code>语法，部署到线上大概也会遇到这个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error while initializing app DOMException: Failed to execute &apos;appendChild&apos; on &apos;Node&apos;: This node type does not support this method.</span><br><span class="line">    at Object.We [as appendChild]</span><br></pre></td></tr></table></figure></p>
<p>根据github nuxt上的<a href="https://github.com/nuxt/nuxt.js/issues/1552" target="_blank" rel="noopener">issue第1552条</a>提示，要将<code>v-if</code>改为<code>v-show</code>语法。</p>
<p>4.坑太多，留坑，晚点更。</p>
<h2 id="2-静态化"><a href="#2-静态化" class="headerlink" title="2.静态化"></a>2.静态化</h2><p>静态化是Nuxt.js打包的另一种方式，算是 Nuxt.js 的一个创新点，页面加载速度很快。<br>在 Nuxt.js 执行 generate 静态化打包时，动态路由会被忽略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| pages/</span><br><span class="line">---| index.vue</span><br><span class="line">---| users/</span><br><span class="line">-----| _id.vue</span><br></pre></td></tr></table></figure></p>
<p>需要动态路由先生成静态页面，你需要指定动态路由参数的值，并配置到 routes 数组中去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// nuxt.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  generate: &#123;</span><br><span class="line">    routes: [</span><br><span class="line">      &apos;/users/1&apos;,</span><br><span class="line">      &apos;/users/2&apos;,</span><br><span class="line">      &apos;/users/3&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行打包，即可看见打包出来的页面。<br>但是如果路由动态参数的值是动态的而不是固定的，应该怎么做呢？</p>
<ul>
<li>使用一个返回 Promise 对象类型 的 函数；</li>
<li>使用一个回调是 callback(err, params) 的 函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// nuxt.config.js</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  generate: &#123;</span><br><span class="line">    routes: function () &#123;</span><br><span class="line">      return axios.get(&apos;https://my-api/users&apos;)</span><br><span class="line">      .then((res) =&gt; &#123;</span><br><span class="line">        return res.data.map((user) =&gt; &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            route: &apos;/users/&apos; + user.id,</span><br><span class="line">            payload: user</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在我们可以从<code>/users/_id.vue</code>访问的<code>payload</code>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async asyncData (&#123; params, error, payload &#125;) &#123;</span><br><span class="line">  if (payload) return &#123; user: payload &#125;</span><br><span class="line">  else return &#123; user: await backend.fetchUser(params.id) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你的动态路由的参数很多，例如商品详情，可能高达几千几万个。需要一个接口返回所有id，然后打包时遍历id，打包到本地，如果某个商品修改了或者下架了，又要重新打包，数量多的情况下打包也是非常慢的，非常不现实。<br><strong>优势：</strong></p>
<ul>
<li>纯静态文件，访问速度超快；</li>
<li>对比SSR，不涉及到服务器负载方面问题；</li>
<li>静态网页不宜遭到黑客攻击，安全性更高。</li>
</ul>
<p><strong>不足：</strong></p>
<ul>
<li>如果动态路由参数多的话不适用。</li>
</ul>
<h2 id="3-预渲染prerender-spa-plugin"><a href="#3-预渲染prerender-spa-plugin" class="headerlink" title="3.预渲染prerender-spa-plugin"></a>3.预渲染prerender-spa-plugin</h2><p>如果你只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install prerender-spa-plugin --save</span><br></pre></td></tr></table></figure></p>
<p>vue cli 3 <code>vue.config.js</code>配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const PrerenderSPAPlugin = require(&apos;prerender-spa-plugin&apos;);</span><br><span class="line">const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &apos;production&apos;) return;</span><br><span class="line">        return &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">                new PrerenderSPAPlugin(&#123;</span><br><span class="line">                    // 生成文件的路径，也可以与webpakc打包的一致。</span><br><span class="line">                    // 下面这句话非常重要！！！</span><br><span class="line">                    // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。</span><br><span class="line">                    staticDir: path.join(__dirname,&apos;dist&apos;),</span><br><span class="line">                    // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。</span><br><span class="line">                    routes: [&apos;/&apos;, &apos;/product&apos;,&apos;/about&apos;],</span><br><span class="line">                    // 这个很重要，如果没有配置这段，也不会进行预编译</span><br><span class="line">                    renderer: new Renderer(&#123;</span><br><span class="line">                        inject: &#123;</span><br><span class="line">                            foo: &apos;bar&apos;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        headless: false,</span><br><span class="line">                        // 在 main.js 中 document.dispatchEvent(new Event(&apos;render-event&apos;))，两者的事件名称要对应上。</span><br><span class="line">                        renderAfterDocumentEvent: &apos;render-event&apos;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;),</span><br><span class="line">            ],</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在main.js中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    document.dispatchEvent(new Event(&apos;render-event&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<p>注意：router中必须设置 <code>mode: “history”</code>。</p>
<p>打包出来可以看见文件，打包出文件夹<code>/index.html</code>，例如：<code>about</code> =&gt; <code>about/index.html</code>，里面有html内容。</p>
<p><strong>优势：</strong></p>
<ul>
<li>改动小，引入个插件就完事；</li>
</ul>
<p><strong>不足：</strong></p>
<ul>
<li>无法使用动态路由；</li>
<li>只适用少量页面的项目，页面多达几百个的情况下，打包会很很很慢；</li>
</ul>
<h2 id="4-使用Phantomjs针对爬虫做处理"><a href="#4-使用Phantomjs针对爬虫做处理" class="headerlink" title="4.使用Phantomjs针对爬虫做处理"></a>4.使用Phantomjs针对爬虫做处理</h2><p>Phantomjs是一个基于webkit内核的无头浏览器，即没有UI界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。<br>虽然“PhantomJS宣布终止开发”，但是已经满足对Vue的SEO处理。<br>这种解决方案其实是一种旁路机制，原理就是通过Nginx配置，<strong>判断访问的来源UA是否是爬虫访问，如果是则将搜索引擎的爬虫请求转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。</strong></p>
<p><img src="https://image-static.segmentfault.com/320/346/3203467011-5d18823332fe1_articlex" alt="图片描述"></p>
<p>具体代码戳这里：<a href="https://github.com/lengziyu/vue-seo-phantomjs" target="_blank" rel="noopener">vue-seo-phantomjs</a>。<br>要安装全局<code>phantomjs</code>，局部<code>express</code>，测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ phantomjs spider.js &apos;https://www.baidu.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果见到在命令行里出现了一推html，那恭喜你，你已经征服PhantomJS啦。<br>启动之后或者用postman在请求头增加<code>User-Agent</code>值为<code>Baiduspider</code>，效果一样的。</p>
<p><strong>部署上线</strong><br>线上要安装<code>node</code>、<code>pm2</code>、<code>phantomjs</code>，nginx相关配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream spider_server &#123;</span><br><span class="line">  server localhost:3000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_set_header  Host            $host:$proxy_port;</span><br><span class="line">      proxy_set_header  X-Real-IP       $remote_addr;</span><br><span class="line">      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">      if ($http_user_agent ~* &quot;Baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|bingbot|Sosospider|Sogou Pic Spider|Googlebot|360Spider&quot;) &#123;</span><br><span class="line">        proxy_pass  http://spider_server;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优势：</strong></p>
<ul>
<li>完全不用改动项目代码，按原本的SPA开发即可，对比开发SSR成本小不要太多；</li>
<li>对已用SPA开发完成的项目，这是不二之选。</li>
</ul>
<p><strong>不足：</strong></p>
<ul>
<li>部署需要node服务器支持；</li>
<li>爬虫访问比网页访问要慢一些，因为定时要定时资源加载完成才返回给爬虫；</li>
<li>如果被恶意模拟百度爬虫大量循环爬取，会造成服务器负载方面问题，解决方法是判断访问的IP，是否是百度官方爬虫的IP。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果构建大型网站，如商城类，别犹豫，直接上SSR服务器渲染，当然也有相应的坑等你，社区较成熟，英文好点，一切问题都迎刃而解。<br>如果只是个人博客、公司官网这类，其余三种都可以。<br>如果对已用SPA开发完成的项目进行SEO优化，而且支持node服务器，请使用<code>Phantomjs</code>。</p>
<p>很少写文章，这是我这个月对Vue SEO方案的探索，写的不对的地方请指出，谢谢理解~</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="http://lengziyu.cn" target="_blank">lengziyu</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/blog/2019/08/01/windows-flutter-install/" class="pre-post btn btn-default" title='Windows Flutter安装和运行'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Windows Flutter安装和运行</span>
        </a>
    
    
        <a href="/blog/2016/12/31/hello-2017/" class="next-post btn btn-default" title='回顾我的2016'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">回顾我的2016</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/blog/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'n5eMVNdQYjjvTrgaAJ5sa6I4-gzGzoHsz',
            appKey: 'Xunr2giiNkqKLYz2wLmXcgOA',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: ''.toLowerCase()
        })
    </script>


    </div>





                </main>

                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SSR服务器渲染"><span class="toc-text">1.SSR服务器渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-静态化"><span class="toc-text">2.静态化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-预渲染prerender-spa-plugin"><span class="toc-text">3.预渲染prerender-spa-plugin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-使用Phantomjs针对爬虫做处理"><span class="toc-text">4.使用Phantomjs针对爬虫做处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019
                  <span>
                    <a target="_blank" href="http://www.beian.miit.gov.cn/">粤ICP备15104739号-3</a>
                  </span>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/blog/js/app.js?rev=@@hash"></script>

</body>
</html>
